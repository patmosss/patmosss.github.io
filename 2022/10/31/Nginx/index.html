<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Nginx · Patmos</title><meta name="description" content="NGINX

[TOC]
Nginx 从入门到企业实战（一）Nginx 基础安装配置1、关于 Nginx 介绍​    Nginx 是异步框架的 web 服务器，也可以用作反向代理、负载均衡以及作为缓存服务器。Nginx 是目前互联网公司web服务器的主流技术，用于处理高并发甚至海量并发的网站数据。"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 5.4.2"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Patmos</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Arquivo</a></li><li><a href="/links">Links</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>Nginx</a></h3></div><div class="post-content"><center><h1>NGINX</h1></center>

<p>[TOC]</p>
<h1 id="Nginx-从入门到企业实战（一）"><a href="#Nginx-从入门到企业实战（一）" class="headerlink" title="Nginx 从入门到企业实战（一）"></a><code>Nginx</code> 从入门到企业实战（一）</h1><h2 id="Nginx-基础安装配置"><a href="#Nginx-基础安装配置" class="headerlink" title="Nginx 基础安装配置"></a><code>Nginx</code> 基础安装配置</h2><h3 id="1、关于-Nginx-介绍"><a href="#1、关于-Nginx-介绍" class="headerlink" title="1、关于 Nginx 介绍"></a>1、关于 <code>Nginx</code> 介绍</h3><p>​    <code>Nginx</code> 是异步框架的 <code>web</code> 服务器，也可以用作反向代理、负载均衡以及作为缓存服务器。<code>Nginx</code> 是目前互联网公司<code>web</code>服务器的主流技术，用于处理高并发甚至海量并发的网站数据。<code>Nginx</code>具有社区版和商业版，社区版是完全开源的，<code>Tengine</code> 就是淘宝在<code>Nginx</code>基础上进行二次开发，以获取更高的稳定性和并发能力，已经在淘宝、天猫等海量数据的电商网站上经过了“双十一”的技术洗礼，足以证明其稳定性和高性能。</p>
<h4 id="1-1-Nginx-主要特性"><a href="#1-1-Nginx-主要特性" class="headerlink" title="1.1 Nginx 主要特性"></a>1.1 <code>Nginx</code> 主要特性</h4><ul>
<li><strong>高并发</strong>、<strong>高性能</strong> 一台普通的服务器可以轻松处理上万并发连接，一般单台服务器最多建议处理三万左右的并发</li>
<li><strong>模块化设计</strong> 基于模块化设计，具有非常好的扩展性，可以通过加载、卸载某个模块（注意：模块动态加载在 <code>Nginx v1.9.11</code> 版本之后才支持）以实现相应的功能；</li>
<li><strong>热部署</strong>、<strong>热更新</strong> <code>Nginx</code> 支持配置文件的热更新，版本热升级、动态加载模块、日志热更换；</li>
<li><strong>内存低消耗</strong> 据统计在 <code>10000</code> 个 <code>keep-alive</code> 连接模式下的非活动连接，仅消耗内存 <code>2.5M</code>;</li>
<li><strong>配置、维护简单</strong>  <code>Nginx</code> 的配置非常简单，对于运维同学非常友好。</li>
</ul>
<h4 id="1-2-Nginx-基本功能"><a href="#1-2-Nginx-基本功能" class="headerlink" title="1.2 Nginx 基本功能"></a>1.2 <code>Nginx</code> 基本功能</h4><ul>
<li><code>web</code> <strong>服务器</strong>这是 <code>Nginx</code> 最基本的功能，也是非常重要的功能之一；</li>
<li><strong>反向代理服务器</strong>同样，<code>Nginx</code> 可以作为 <code>http</code> 协议的反向代理服务器，也是生产环境中最常用的功能之一；</li>
<li><code>FastCGI（php）</code> 、<code>uWSGID（python）</code> <strong>代理服务器</strong> 生产环境上经常使用 <code>Nginx</code> 作为客户端请求后端应用服务（注意：此时 <code>Nginx</code> 在用户看来依然是反向代理服务器，只不过这里代理的请求不再是 <code>http</code> 协议，而是跟后端服务器相关的协议，比如后端如果是 <code>php</code> 语言开发的，则是 <code>FastCGI</code> 协议代理）；</li>
<li><code>TCP/UDP</code> <strong>代理服务器</strong>，也即“<strong>调度器</strong>”生产环境中，在一些并发量不大的情况下，有时候也会使用 <code>Nginx</code> 作为四层调度器；</li>
<li><code>Mail</code> <strong>邮件代理服务器</strong> 可以作为邮件代理服务器，几乎不使用；</li>
</ul>
<h4 id="1-3-Nginx-基础架构"><a href="#1-3-Nginx-基础架构" class="headerlink" title="1.3 Nginx 基础架构"></a>1.3 <code>Nginx</code> 基础架构</h4><p>如下图，<code>Nginx</code> 为 <code>master/worker</code> 结构，一个 <code>master</code> 主进程，负责管理和维护多个 <code>worker</code> 进程，真正接收并处理用户请求的其实是 <code>worker</code> 进程，<code>master</code> 不对用户请求进行处理。即 <code>master</code> 主进程负责分析并加载配置文件，管理 <code>worker</code> 进程，接收用户信号传递以及平滑升级等功能。另外，<code>Nginx</code> 具有强大的缓存功能，其中<code>Cache Loader</code> 负责载入缓存对象，<code>Cache Manager</code> 负责管理缓存对象。</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210123190453595.png"></p>
<h3 id="2-Nginx-安装与访问测试"><a href="#2-Nginx-安装与访问测试" class="headerlink" title="2. Nginx 安装与访问测试"></a>2. <code>Nginx</code> 安装与访问测试</h3><p>我们先介绍 <code>yum</code> 安装方式，稍后再介绍编译安装。需要注意的是 <code>CentOS</code> 基础 <code>yum</code> 源中是没有 <code>Nginx</code> 包的，我们需要添加好 <code>EPEL</code> 源。</p>
<p><strong>【安装】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yum install epel-release</span><br><span class="line">或者</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo  http://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo  http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">[root@test ~]# yum -y install nginx</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>这里安装好的版本 <code>nginx version: nginx/1.16.1</code></strong></p>
</blockquote>
<p>我们可以看下 <code>Nginx</code> 生成了很多文件，其中 <code>/usr/sbin/nginx</code> 为主程序文件，<code>/etc/nginx/</code> 为 <code>nginx</code> 的配置目录，还有一些是帮助文件、默认网页文件，日志文件等，我们用到的时候再做介绍。我们先来看看 <code>/usr/sbin/nginx</code> 文件（这个是一个可执行二进制文件），如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# nginx -h</span><br><span class="line">nginx version: nginx/1.16.1</span><br><span class="line">Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -?,-h         : this help</span><br><span class="line">  -v            : show version and exit</span><br><span class="line">  -V            : show version and configure options then exit</span><br><span class="line">  -t            : test configuration and exit</span><br><span class="line">  -T            : test configuration, dump it and exit</span><br><span class="line">  -q            : suppress non-error messages during configuration testing</span><br><span class="line">  -s signal     : send signal to a master process: stop, quit, reopen, reload</span><br><span class="line">  -p prefix     : set prefix path (default: /usr/share/nginx/)</span><br><span class="line">  -c filename   : set configuration file (default: /etc/nginx/nginx.conf)</span><br><span class="line">  -g directives : set global directives out of configuration file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">为什么会有nginx用户</span></span><br><span class="line">[root@test ~]# id nginx</span><br><span class="line">uid=997(nginx) gid=994(nginx) groups=994(nginx)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">原因是下载nginx的时候依赖 nginx-filesystem</span></span><br><span class="line">[root@test ~]# rpm -q --scripts nginx-filesystem</span><br><span class="line">preinstall scriptlet (using /bin/sh):</span><br><span class="line">getent group nginx &gt; /dev/null || groupadd -r nginx</span><br><span class="line">getent passwd nginx &gt; /dev/null || \</span><br><span class="line">    useradd -r -d /var/lib/nginx -g nginx \</span><br><span class="line">    -s /sbin/nologin -c &quot;Nginx web server&quot; nginx</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>-V</code>：该参数用于显示 <code>nginx</code> 版本信息以及编译加载了哪些模块；</strong></p>
<p><strong><code>-t</code>：用于 <code>nginx </code>配置文件语法检测，我们在生产上修改好配置文件后，一定要先使用该参数进行语法检测；</strong></p>
<p><strong><code>-s</code>：给 <code>nginx</code> 传递信号，其中 <code>stop</code> 强制停止、<code>quit</code> 优雅退出；即等待连接关闭之后再退出；<code>reopen</code>用于重新打开日志文件，一般用于日志文件的切割；<code>reload</code> 重载（热部署）<code>nginx</code> 配置文件；</strong></p>
<p><strong><code>-g</code>：用于指定指令，该指令高于配置文件中的设置。如 <code>nginx -g &#39;daemon off&#39;</code>，将 <code>nginx</code> 设置为前台运行；</strong></p>
</blockquote>
<p><strong>【启动】</strong></p>
<blockquote>
<p>注意：为了避免防火墙以及 <code>&#39;selinux&#39;</code> 对我们的实验产生影响，先关闭掉防火墙 <code>&#39;firewalld/iptables&#39;</code> 以及 <code>&#39;selinux&#39;</code></p>
</blockquote>
<p><code>Nginx</code>启动非常简单，我们可以通过<code>systemctl start nginx</code>启动，也可以直接使用命令<code>nginx</code>进行启动，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">test</span> ~]<span class="comment"># nginx</span></span><br><span class="line">[root<span class="variable">@test</span> ~]<span class="comment"># netstat -nltup | grep nginx</span></span><br><span class="line">tcp        <span class="number">0</span>      <span class="number">0</span> <span class="number">0.0.0.0:80</span>              <span class="number">0.0.0.0</span>:*               LISTEN      <span class="number">961</span>/nginx: master p </span><br><span class="line">tcp6       <span class="number">0</span>      <span class="number">0</span> :::<span class="number">80</span>                   :::*                    LISTEN      <span class="number">961</span>/nginx: master p </span><br></pre></td></tr></table></figure>

<p><strong>【访问】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">test</span> html]<span class="comment"># curl -I localhost</span></span><br><span class="line">HTTP/<span class="number">1</span>.<span class="number">1</span> <span class="number">200</span> OK</span><br><span class="line">Server: nginx/<span class="number">1</span>.<span class="number">16</span>.<span class="number">1</span></span><br><span class="line">Date: Fri, <span class="number">22</span> Jan <span class="number">2021</span> <span class="number">14</span>:<span class="number">15</span>:<span class="number">57</span> GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">4833</span></span><br><span class="line">Last-Modified: Wed, <span class="number">20</span> Jan <span class="number">2021</span> <span class="number">09</span>:<span class="number">15</span>:<span class="number">36</span> GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: <span class="string">&quot;6007f4b8-12e1&quot;</span></span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<h3 id="3-Nginx-简单配置"><a href="#3-Nginx-简单配置" class="headerlink" title="3. Nginx 简单配置"></a>3. <code>Nginx</code> 简单配置</h3><p>我们通过 <code>yum</code> 方式安装的 <code>Nginx</code> 程序，配置文件采用**”一主多子”**的配置方式，即一个主配置文件，通过将不同功能或者不同模块的子配置文件进行包含引入的方式，这样可以做到配置文件的清晰、便于管理。这种配置方式的思想也是一个优秀的工程师需要借鉴的地方。下面我们来看 <code>Nginx</code> 默认的主配置文件，注意此处我省略了部分内容。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">test</span> nginx] <span class="comment"># cat nginx.conf | grep -v -E &#x27;^.*#|^$&#x27;</span></span><br><span class="line">user nginx;			<span class="comment">#worker_processes名称，lscpu</span></span><br><span class="line"><span class="attribute">worker_processes</span> auto;   <span class="comment">#设置auto，跟CPU的数量有关</span></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>; <span class="comment">#worker的连接数，默认是1024个</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line">    <span class="attribute">sendfile</span>            <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nopush</span>          <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">tcp_nodelay</span>         <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">keepalive_timeout</span>   <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">types_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line">    <span class="attribute">include</span>             /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>        application/octet-stream;</span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">10.4.7.100</span>;</span><br><span class="line">        <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">        <span class="section">location</span> /www/ &#123;</span><br><span class="line">		<span class="attribute">root</span> /data/;</span><br><span class="line">		<span class="attribute">index</span> index.html index.hmt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="section">location</span> /image/ &#123;</span><br><span class="line">		<span class="attribute">root</span> /data/;</span><br><span class="line">		<span class="attribute">autoindex</span> <span class="literal">on</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="section">location</span> / &#123;</span><br><span class="line">	<span class="attribute">root</span> html;</span><br><span class="line">	<span class="attribute">index</span> index.html index.htm;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">        <span class="section">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">        <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-man-配置段"><a href="#3-1-man-配置段" class="headerlink" title="3.1 man 配置段"></a>3.1 <code>man</code> 配置段</h4><p>其中：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;			     <span class="comment">#worker_processes名称，lscpu</span></span><br><span class="line"><span class="attribute">worker_processes</span> auto;   <span class="comment">#设置auto，跟CPU的数量有关</span></span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modules/<span class="regexp">*.conf</span>;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span> <span class="number">1024</span>; <span class="comment">#worker的连接数，默认是1024个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些配置为 <code>nginx</code> 核心配置（也称为主配置 <code>man</code>），可以使用的参数可以参考<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/">官方文档</a>。这里有一些参数非常重要，涉及到 <code>Nginx</code> 的性能优化，后面会详细讲解。此处我们仅介绍默认配置文件中的出现的参数：</p>
<p><code>user nginx</code>：用来指定运行 <code>nginx</code> 程序的用户，默认为 <code>nginx</code>，注意该用户是安装 <code>nginx</code> 时程序自动创建的，如果我们想要手动编译安装 <code>Nginx</code> 的话，这需要首先手动创建相应的用户。</p>
<blockquote>
<p>可以看到我们在安装 <code>nginx</code> 时，有一个依赖包，<code>依赖安装 nginx-filesystem-1:1.16.1-1.e17.noarch @epel</code> 被安装，我们可以查看下安装包安装时执行了什么脚本。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">test</span> ~]<span class="comment"># rpm -q --scripts nginx-filesystem</span></span><br><span class="line">preinstall scriptlet (using /bin/sh):</span><br><span class="line">getent group nginx &gt; /dev/null || groupadd -r nginx</span><br><span class="line">getent passwd nginx &gt; /dev/null || \</span><br><span class="line"> useradd -r -d /var/lib/nginx -g nginx \</span><br><span class="line"> -s /sbin/nologin -c <span class="string">&quot;Nginx web server&quot;</span> nginx</span><br><span class="line">exit <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>即：<code>nginx</code>用户就是在这个程序安装时添加的。</p>
</blockquote>
<p>需要注意的是，<code>Nginx</code> 主进程，即 <code>master</code> 进程会以 <code>root</code> 身份运行，<code>worker</code> 进程会以指定的 <code>nginx</code> 用户运行。所以用户的某个请求能否处理，则要看 <code>worker</code> 进程的用户权限是否足够。而能否监听某个端口，则是由<code>master</code> 用户请求决定的。</p>
<p><code>worker_processes auto</code>：用来指定 <code>worker</code> 进程的个数，<code>auto</code> 则会根据系统的 <code>cpu</code> 个数进行设置，比如有 <code>1</code> 颗 <code>cpu</code> ，则 <code>worker</code> 进程的个数就是 <code>1</code>。可以通过 <code>lscpu</code> 命令查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@test nginx]# lscpu | grep -E &#x27;^CPU\(s\)&#x27;</span><br><span class="line">CPU(s):                1</span><br><span class="line">[root@test nginx]# ps -ef | grep nginx</span><br><span class="line">root        961      1  0 08:23 ?        00:00:00 nginx: master process /usr/sbin/nginx</span><br><span class="line">nginx      1311    961  0 08:30 ?        00:00:00 nginx: worker process</span><br><span class="line">root       1817   1200  0 10:08 pts/0    00:00:00 grep --color=auto nginx</span><br></pre></td></tr></table></figure>

<p>我们也可以手动指定 <code>worker</code> 进程的个数，或者绑定某个 <code>worker</code> 进程在某个 <code>cpu</code>上运行，这个部分在调优部门深入介绍。</p>
<p><code>error_log /var/log/nginx/error.log</code>：用来定义 <code>nginx</code> 错误日志位置，我们也可以对不同的虚拟主机或者 <code>uri</code> 定义不同的错误日志，该参数可以在 <code>main</code> ，<code>http </code>，<code>mail</code> ，<code>stream</code> ，<code>server</code> ，<code>location </code> 部分应用。</p>
<p><code>pid /run/nginx.pid</code>：用来定义<code>nginx</code>主进程的<code>pid</code>文件路径，注意：对于<code>nginx</code>应用的启动、停止、重载等信号传递操作都是依赖于该文件；</p>
<p><code>include /usr/share/nginx/modules/*.conf</code>：用于指定 <code>nginx</code> 模块配置文件所包含的子配置文件；</p>
<p><code>events&#123;...&#125;</code>：用于定义事件驱动相关配置，该配置与连接的处理密切相关，其中最重要的几个指令如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">use</span> method; <span class="comment">#定义nginx使用哪种事件驱动类型，在Redhat/CentOS中性能最好的是epoll模型</span></span><br><span class="line"><span class="attribute">worker_connections</span> number; <span class="comment">#定义每个worker进程可以处理的连接数</span></span><br><span class="line"><span class="attribute">accept_mutex</span> <span class="literal">on</span> | <span class="literal">off</span>; <span class="comment">#处理新连接的方法，on是指由各个worker进程轮流处理，off则会通知所有worker进程，但是只有一个worker进程获得处理连接的权限。在CentOS（Linux 3.9+）将使用&quot;reuseport&quot;会有更好性能；</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：如果启用了 <code>accept_mutex on</code> 则会启用 <code>accept_mutex_delay 500ms;</code> 参数，时间可以设置，表示当一个 <code>worker</code> 进程在处理新连接时，多长时间以后才会重新接受下一个新的请求。</strong></p>
</blockquote>
<h4 id="3-2-http-模块配置段"><a href="#3-2-http-模块配置段" class="headerlink" title="3.2 http 模块配置段"></a>3.2 <code>http</code> 模块配置段</h4><p>在上面的配置文件示例中，处理<code>main</code>配置段，还有<code>http</code>模块配置段，这两个参数是平行关系，既不是包含与被包含的关系。与此平行关系的参数还有<code>mail</code>、<code>stream</code>，这些后面再说。本节内容我们只<code>http</code>配置做简单介绍。首先，认识下<code>http</code>的配置格式，除去一些配置参数，简单的架构如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">	···</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">server_name</span>  ke.byte-edu.com;</span><br><span class="line">           ···</span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">		   ···</span><br><span class="line">	     &#125;</span><br><span class="line">	     <span class="section">location</span> /img/ &#123;</span><br><span class="line">		   ···</span><br><span class="line">	     &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="section">server</span> &#123;</span><br><span class="line">		<span class="attribute">server_name</span> ke.byte-edu.com;</span><br><span class="line">		···</span><br><span class="line">		<span class="section">location</span> / &#123;</span><br><span class="line">		···</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="section">location</span> /course/ &#123;</span><br><span class="line">		···</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看到在 <code>http</code> 配置段中，我们可设置多个 <code>server</code> 配置，该 <code>server</code> 就是用来配置虚拟主机的，可以基于<code>IP</code>地址，也可以基于<code>PORT</code>，当然生产上更多的还是使用基于域名的方式来配置虚拟主机。在<code>server</code>配置段内还可以在配置多个<code>location</code>字段，该字段用来配置虚拟主机不同<code>uri</code>的响应方式，这就是<code>nginx</code>作为<code>web</code>应用的最简单配置格式。</p>
<p>无论是<code>http</code>、<code>server</code>还是<code>location</code>字段，其中都可以使用很多很多参数，我们会对生产上经常使用的参数进行介绍。本节内容，我们先简单的配置两个虚拟主机，后面的课程再作更深入的介绍。</p>
<h3 id="4-配置虚拟主机"><a href="#4-配置虚拟主机" class="headerlink" title="4.配置虚拟主机"></a>4.配置虚拟主机</h3><p>基于域名的最简单的配置：</p>
<p>我们在 <code>/etc/nginx/conf.d</code> 下创建子配置文件，至于为什么在这里创建，可以看上面的 <code>http</code> 配置段中<code>include /etc/nginx/default.d/*.conf</code>。生产环境中，我们一般一个虚拟主机会单独创建一个配置文件。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建几个备用目录。作为不同虚拟主机的家目录</span></span><br><span class="line">[root@test ~]# mkdir -pv /data/nginx/&#123;a,b,c&#125;</span><br><span class="line">mkdir: created directory ‘/data/nginx’</span><br><span class="line">mkdir: created directory ‘/data/nginx/a’</span><br><span class="line">mkdir: created directory ‘/data/nginx/b’</span><br><span class="line">mkdir: created directory ‘/data/nginx/c’</span><br></pre></td></tr></table></figure>

<p><strong>【创建域名<code>a.com|ww.a.com</code>的虚拟主机】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">test</span> conf.d]<span class="comment"># cat a.com.conf</span></span><br><span class="line">server &#123;</span><br><span class="line">    <span class="attribute">listen</span>	<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.a.com a.com;</span><br><span class="line">    <span class="attribute">root</span>	/data/nginx/a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们写了四行配置，其实<code>listen</code>可以省略，默认监听在80端口；<code>root</code>也可以省略，如果我们不再<code>server</code>中指定，则会继承<code>http</code>中定义的<code>root</code>目录作为自己的家目录。</p>
<p><strong>【创建域名<code>b.com|ww.b.com</code>的虚拟主机】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# cat b.com.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen         80;</span><br><span class="line">    server_name    www.b.com b.com;</span><br><span class="line">    root	   /data/nginx/b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【创建测试页面】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# echo &quot;This is a.com page&quot; &gt; /data/nginx/a/index.html</span><br><span class="line">[root@test conf.d]# echo &quot;This is b.com page&quot; &gt; /data/nginx/b/index.html</span><br></pre></td></tr></table></figure>

<p><strong>【测试基于域名的虚拟主机】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br><span class="line">[root@test conf.d]# nginx -s reload</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">curl www.a.com</span> </span><br><span class="line">This is a.com page</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">curl a.com</span> </span><br><span class="line">This is a.com page</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">curl www.b.com</span> </span><br><span class="line">This is b.com page</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">curl b.com</span> </span><br><span class="line">This is b.com page</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果我们想要通过域名测试，记得先在<code>hosts</code>中指定域名，我的<code>host</code>列表：</p>
<p><code>10.4.7.100 a.com b.com c.com www.a.com www.b.com www.c.com</code></p>
</blockquote>
<p><strong>【基于IP地址的虚拟主机】</strong></p>
<p>这种方式很少使用，我们做个简单示例：</p>
<p>创建配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# cat ip.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen 10.4.7.100;</span><br><span class="line">    root   /data/nginx/ip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建相应的测试目录与测试页面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# mkdir -p /data/nginx/ip</span><br><span class="line">[root@test conf.d]# echo &quot;This is IP server&quot; &gt; /data/nginx/ip/index.html</span><br><span class="line">[root@test conf.d]# nginx -s reload</span><br></pre></td></tr></table></figure>

<p>通过<code>IP</code>地址进行访问测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">curl 10.4.7.100</span></span><br><span class="line">This is IP server</span><br></pre></td></tr></table></figure>

<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210128232732875.png" alt="image-20210123190453595" style="zoom:35%;" />

<p>还记得我们刚安装好<code>nginx</code>通过<code>IP</code>的虚拟主机方式一样，多数都是用于内部应用。</p>
<p>创建相应的配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# cat port.conf </span><br><span class="line">server &#123;</span><br><span class="line">    listen  81;</span><br><span class="line">    root /data/nginx/port;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建相应的目录与网页文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# mkdir /data/nginx/port</span><br><span class="line">[root@test conf.d]# echo &quot;This is Port page&quot; &gt; /data/nginx/port/index.html</span><br><span class="line">[root@test conf.d]# nginx -s reload</span><br></pre></td></tr></table></figure>

<p>基于<code>IP</code>地址的访问测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# curl 10.4.7.100:81</span><br><span class="line">This is Port page</span><br></pre></td></tr></table></figure>

<p>结论：所谓基于域名、IP或者端口的虚拟主机其实就是指当客户端通过不同的域名、IP或者端口进行请求时，父亲端会给与不同的响应。</p>
<h1 id="Nginx-从入门到企业实战（二）"><a href="#Nginx-从入门到企业实战（二）" class="headerlink" title="Nginx 从入门到企业实战（二）"></a><code>Nginx</code> 从入门到企业实战（二）</h1><h2 id="Nginx-调优与背后原理"><a href="#Nginx-调优与背后原理" class="headerlink" title="Nginx 调优与背后原理"></a><code>Nginx</code> 调优与背后原理</h2><h3 id="1-Linux-网络-IO-流程"><a href="#1-Linux-网络-IO-流程" class="headerlink" title="1. Linux 网络 IO 流程"></a>1. <code>Linux</code> 网络 <code>IO</code> 流程</h3><p>​    我们访问一个网站，从我们在浏览器上打开输入网址到网页被打开，中间经历的哪些流程？如果网络比较好的情况下，通常在几秒之内就可以打开一个内容非常丰富的网站，但是背后的执行过程是非常复杂的，我们简单对其中的某些过程进行描述。而我们要描述的地方就是服务器网卡接收到用户请求数据开始，如何处理这些请求并将报文响应给用户。</p>
<p>​    这个过程我们省略了从用户发起请求一直到请求到达服务端的过程，这中间还涉及到 <code>DNS</code> 解析、路由查找等技术细节。</p>
<p>接收数据包是一个复杂的过程，涉及很多底层的技术细节，但大致需要以下几个步骤：</p>
<ol>
<li><p>网卡收到数据包。</p>
</li>
<li><p>将数据包从网卡硬件缓存转移到服务器内存中。</p>
</li>
<li><p>通知内核处理。</p>
</li>
<li><p>经过 <code>TCP/IP</code> 协议逐层处理。</p>
</li>
<li><p>应用程序通过 <code>read()</code> 从 <code>socket buffer</code> 读取数据。</p>
<hr>
<ol>
<li>数据包从外面的网络进入物理网卡。如果目的地不是该网卡，并且该网卡没有开启混杂模式，该包会被网卡丢弃。</li>
<li>网卡通过硬件中断( <code>IRQ</code> )告知 <code>CPU</code> 有数据来了。</li>
<li><code>CPU</code> 根据中断表，调用已经注册的中断函数，这个中断函数会调用驱动程序中相应的函数对数据进行处理。</li>
<li>驱动会一个接一个的读取网卡写到内存中的数据包，内存中数据包的格式只有驱动知道。</li>
<li>驱动程序将内存中的数据包转换成内核网络模块能识别的格式，数据包会被先存入到 <code>CPU</code> 的 <code>input_pkt_queue</code> 队列中，如果队列满了数据会被丢弃（注意：我们可以通过调整系统参数<code>net.core.netdev_max_backlog</code> 来调整队列大小）。</li>
<li>此时 <code>CPU</code> 从队列中获取数据并调用 <code>Linux</code> 网络协议栈相应的函数，将数据包交给协议栈处理。</li>
<li>通过协议分析将数据包传给链路层，此时放在该协议栈中的 <code>netfilter</code> 钩子函数（也就是我们通过<code>iptables</code>）设置的一些规则会对数据包进行处理，可以进行修改，也可能会进行丢弃。如果没有丢弃，则会继续交由网络层协议。</li>
<li>网络层协议对报文进行处理，查看<code>IP</code>地址是否为本机，为本机则接收。如果不为本机，要看是否开启了<code>ip_forward</code>即<code>IP 转发功能</code>，如果开启则进行网络报文转发，如果未开启则丢弃报文。假设报文的目的地址是本机，则会交由传输层协议进行处理，比如<code>TCP</code>或者<code>UDP</code>等。</li>
<li>传输层协议会根据数据包中的<code>IP</code>和端口来查找相应的<code>socket</code>，如果没有找到则丢弃该报文，如果找到则将数据放到<code>socket</code>的队列中（<strong>这里还涉及到连接的建立，半连接和全连接队列</strong>），然后由操作系统内核通知相关的应用来进行数据读取</li>
<li>应用层将请求报文打开后，假如请求读取某个文件，则应用会通过系统调用来读取该文件。</li>
<li>当内核完成数据的处理后，会将数据复制到应用内存中供应用读取（<strong>从内核缓存区拷贝到应用缓冲区</strong>）。应用读取到数据，构建响应包，通过网络协议簇将报文进行封装，通过链路层发送到网卡缓冲区队列中。</li>
<li>网卡再次通过中断函数调用网卡驱动完成数据的发送。</li>
</ol>
</li>
</ol>
<blockquote>
<p><strong>注意：上述步骤知识进行了简单描述，很多细节均没有提及，同时也省略了很多和协议以及硬件有关的描述.</strong></p>
</blockquote>
<p>详细流程可参考 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e6162bc984c8">Linux网络之数据包的接收过程</a></p>
<h3 id="2-Linux-网络-IO-模型"><a href="#2-Linux-网络-IO-模型" class="headerlink" title="2. Linux 网络 IO 模型"></a>2. <code>Linux</code> 网络 <code>IO</code> 模型</h3><p>上述内容即为<code>Linux</code>最简单的网络流程描述，或许你觉得已经很复杂了，但是下面我们介绍的内容只是整个流程中的很小很小一部分，也是咱们图中一笔带过的<code>nginx</code>对<code>OS kernel</code>使用系统调用的部分。</p>
<p>即：当应用接收到用户请求时，如何对请求进行处理，这里就设计到<code>Linux</code>网络<code>IO</code>模型。</p>
<ol>
<li>用户空间（<code>user space</code>）的应用程序通过系统调用让内核处理</li>
<li>进入内核空间（<code>kernel space</code>）将数据从硬盘读取到自己的内存缓冲区，拷贝到 <code>user space</code> 的内存缓冲区</li>
<li><code>user space</code> 对数据进行处理</li>
</ol>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210124202517349.png" alt="image-20210128232732875" style="zoom:50%;" />

<p>​    即当用户空间的应用程序需要读写硬盘上的数据时，会通过系统调用的方式让内核去处理，此时进入内核空间，内核去将数据从硬盘读取到自己的内存缓冲区中，然后进行数据的读写处理。将数据准备好之后，会把数据拷贝到应用程序的内存缓冲区，此时进入用户空间由应用程序再对数据进行处理，比如数据封包等。在这里会涉及到两个阶段：</p>
<ul>
<li><strong>等待数据准备就绪（ <code>Waiting for the data to be ready</code> ）</strong></li>
<li><strong>将数据从内核缓冲区拷贝到进程缓冲区中（ <code>Copying the data from the kernel to the process</code> ）</strong></li>
</ul>
<p>正是因为这两个阶段，<code>Linux</code> 系统产生了下面五种网络模式的方案：</p>
<ul>
<li><strong>阻塞式 <code>IO</code> 模型（ <code>blocking IO model</code> ）</strong></li>
<li><strong>非阻塞式 <code>IO</code> 模型（ <code>nonblocking IO model</code> ）</strong></li>
<li><strong>IO复用式 <code>IO</code> 模型（ <code>IO multiplexing model</code> ）</strong></li>
<li><strong>信号驱动式 <code>IO</code> 模型（ <code>signal-driven IO model</code> ）</strong></li>
<li><strong>异步式 <code>IO</code> 模型（ <code>asynchronous IO model</code>）</strong></li>
</ul>
<h4 id="2-1-阻塞式-IO-模型（-blocking-IO-model-）"><a href="#2-1-阻塞式-IO-模型（-blocking-IO-model-）" class="headerlink" title="2.1 阻塞式 IO 模型（ blocking IO model ）"></a>2.1 阻塞式 <code>IO</code> 模型（ <code>blocking IO model</code> ）</h4><p>在 <code>Linux</code> 中，默认情况下所有的 <code>IO</code> 操作都是 <code>blocking</code>，一个典型的读操作流程大概是这样：</p>
<p><img src="D:%5Chexo%5Cblog%5Cthemes%5Cfluid%5Csource%5Cimg%5Cblog_image%5CLinux_internetIO%5Cblocking.png" alt="image-20210124155106628"></p>
<p>​    当用户进程调用了 <code>recvfrom</code> 这个系统调用，<code>kernel</code>就开始了<code>IO</code>的第一个阶段：准备数据（对于网络 <code>IO</code> 来说，很多时候数据在一开始还没有到达。比如：还没有收到一个完整的 <code>UDP</code> 包。这个时候 <code>kernel</code> 就要等待足够的数据到来），而数据被拷贝到操作系统内核的缓冲区中是需要一个过程的，这个过程需要等待。此时用户进程会被阻塞（当然，是进程自己选择的阻塞）。当<code>kernel</code>一直等到数据准备好了，它就会将数据从<code>kernel</code>中拷贝到用户空间的缓冲区以后，然后<code>kernel</code>返回结果，用户进程才解除<code>block</code>的状态，重新运行起来。</p>
<p>所以：<code>blocking IO</code>的特点就是在 <code>IO</code> 执行的下两个阶段都被 <code>block</code> 了。</p>
<ul>
<li><strong>等待数据准备就绪（ <code>waiting for the data to be ready</code> ）<code>「阻塞」</code></strong></li>
<li><strong>将数据从内核拷贝到进程中（ <code>Copying the data from the kernel to the process</code> ）<code>「阻塞」</code></strong></li>
</ul>
<h4 id="2-2-非阻塞-I-O（-nonblocking-IO）"><a href="#2-2-非阻塞-I-O（-nonblocking-IO）" class="headerlink" title="2.2 非阻塞 I/O（ nonblocking IO）"></a>2.2 非阻塞 <code>I/O</code>（ <code>nonblocking IO</code>）</h4><p>在 <code>Linux</code> 中，可以通过设置<code>socket</code>使其变为<code>non-blocking</code>。</p>
<p><code>Socket</code>设置为<code>NONBLOCK</code>（非阻塞）就是告诉内核，当所有请求的 <code>I/O</code> 操作无法完成时，不要将进程睡眠，而是返回一个错误码（<code>EWOULDBLOCK</code>），这样请求就不会阻塞。当对一个 <code>non-blocking socket</code> 执行读操作时，流程是这个样子：</p>
<p><img src="D:%5Chexo%5Cblog%5Cthemes%5Cfluid%5Csource%5Cimg%5Cblog_image%5CLinux_internetIO%5CNon-blocking.png" alt="image-20210124164607871"></p>
<p>​    当用户进程调用了<code>recvfrom</code>这个系统调用，如果<code>kernel</code>中的数据还没有准备好，那么它并不会<code>block</code>用户进程，而是立刻返回一个<code>EWOULDBLOCK</code>错误代码。从用户进程角度讲，它发起一个<code>read</code>操作后，并不需要等待，而是马上得到了一个结果。用户进程判断结果是一个<code>EWOULDBLOCK</code>时，它就知道数据还没有准备好，此时用户进程可以进行其他操作。一旦<code>kernel</code>中的数据准备好了，并且又再次收到了用户进程的<code>system call</code>，那么它马上就将数据拷贝到了用户空间缓冲区，然后返回。</p>
<p>​    可以看到，<code>I/O</code>操作函数将不断的测试数据是否已经准备好，如果没有准备好，继续轮询，直到数据准备好为止。整个<code>I/O</code>请求的过程中，虽然用户线程每次发起<code>I/O</code>请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的<code>CPU</code>的资源。</p>
<p>所以， <strong><code>non blocking IO</code> 的特点是用户进程需要不断的主动询问 <code>kernel</code> 数据好了没有</strong>：</p>
<ul>
<li><strong>等待数据准备就绪（ <code>waiting for the data to be ready</code>）<code>非阻塞</code></strong></li>
<li><strong>将数据从内核拷贝到进程中（ <code>Copying the data from the kernel to the process</code> ）<code>阻塞</code></strong></li>
</ul>
<p>一般很少直接使用这种模型，而是在其他<code>I/O</code>模型中使用非阻塞<code>I/O</code>这一特性。这种方式对单个<code>I/O</code>请求意义不大，但给<code>I/O</code>多路复用铺平了道路。</p>
<h4 id="2-3-I-O多路复用（I-O-multiplexing）"><a href="#2-3-I-O多路复用（I-O-multiplexing）" class="headerlink" title="2.3 I/O多路复用（I/O multiplexing）"></a>2.3 I/O多路复用（I/O multiplexing）</h4><p><code>IO multiplexing</code>在我们使用中基本这种模型的代表就是常见的<code>select，poll，epoll</code>，有些地方也称这种<code>IO</code>方式为事件驱动模型<code>event driven IO</code>。<code>select/poll/epoll</code>的好处就在于**单个系统<code>process</code>就可以同时处理多个网络连接的<code>IO</code>**。它的基本原理就是<code>select，poll，epool</code>这些个<code>function</code>会不断的轮询所负责的所有<code>socket</code>，当某个<code>socket</code>有数据到达了，就通知用户进程。</p>
<p><img src="D:%5Chexo%5Cblog%5Cthemes%5Cfluid%5Csource%5Cimg%5Cblog_image%5CLinux_internetIO%5CMultiple.png" alt="image-20210124174845469"></p>
<p>​    当用户进程调用了<code>select</code>，那么整个进程会被 <code>block</code> ，而同时，<code>kernel</code>会“监视”所有<code>select</code>负责的<code>socket</code>，当任何一个<code>socket</code>中的数据准备好了，<code>select</code>就会返回。这个时候用户进程再调用<code>read</code>操作，将数据从<code>kernel</code>拷贝到用户进程。</p>
<p>所以，**<code>I/O</code> 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，<code>select()</code>函数就可以返回。**</p>
<p>这个图和<code>blocking IO</code>的图其实并没有太大的不同，事实上因为<code>IO</code>多路复用多了添加监视<code>socket</code>，以及调用<code>select</code>函数的额外操作，效率更差。还更差一些，因为这里需要使用两个<code>system call</code>（<code>select</code>和<code>recvfrom</code>），而<code>blocking IO</code>只调用了一个<code>system call</code>（<code>recvfrom</code>）。但是使用<code>select</code>以后最大的优势是用户可以在一个线程内同时处理多个<code>socket</code>的<code>I/O</code>请求。用户可以注册多个<code>socket</code>，然后不断地调用<code>select</code>读取被激活的<code>socket</code>，即可达到在同一个线程内同时处理多个<code>I/O</code>请求的目的。而在同步异阻塞模型中，必须通过多线程的凡是才能达到这个目的。</p>
<p><strong>所以，如果处理的连接数不是很高的话，使用 <code>select/epool</code> 的 <code>web server</code> 并没有性能优势，可能延迟还要更大。<code>select/epoll</code>的优势并不是单个连接能处理得更快，而是在于能处理更多的连接</strong></p>
<p>在<code>IO multipxing model</code>中，实际中，对于每一个<code>socket</code>，一般都设置为<code>non-blocking</code>，但是，如上图所示，整个用户的<code>process</code>其实是一直被<code>block</code>的。只不过<code>process</code>是被<code>select</code>这个函数<code>block</code>，而不是被<code>socket IO</code>给<code>block</code>。</p>
<p>因此对于<code>IO</code>多路复用模型来说：</p>
<ul>
<li><strong>等待数据准备就绪（ <code>Waiting for the data to be ready</code> ）<code>阻塞</code></strong></li>
<li><strong>将数据从内核拷贝到进程中（ <code>Copying the data from the kernel to the process</code> ）<code>阻塞</code></strong></li>
</ul>
<blockquote>
<p><strong>对于<code>select/poll/epoll</code>  可以根据调用时指定的参数不同，而决定是阻塞或者非阻塞.</strong></p>
</blockquote>
<h4 id="2-4-信号驱动式-IO-模型（-signal-driven-IO-model-）"><a href="#2-4-信号驱动式-IO-模型（-signal-driven-IO-model-）" class="headerlink" title="2.4 信号驱动式 IO 模型（ signal-driven IO model ）"></a>2.4 信号驱动式 <code>IO</code> 模型（ <code>signal-driven IO model</code> ）</h4><p>​    首先我们运行 <code>socket</code> 进行信号驱动 <code>I/O</code>，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个<code>SIGIO</code>信号，可以在信号处理函数中调用<code>I/O</code>操作函数处理数据。</p>
<h4 id="2-5-异步-I-O（-asynchronous-IO-）"><a href="#2-5-异步-I-O（-asynchronous-IO-）" class="headerlink" title="2.5 异步 I/O（ asynchronous IO ）"></a>2.5 异步 <code>I/O</code>（ <code>asynchronous IO</code> ）</h4><p>​    用户进程发起 <code>aio_read</code> 调用之后，立刻就可以开始去做其它的事。而另一方面，从<code>kernel</code>的角度，当它发现一个<code>asynchronous read</code>之后，首先它会立即返回，所以不会对用户进程产生任何 <code>block</code> 。然后，<code>kernel</code>会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，<code>kernel</code>会给用户进程发送一个<code>signal</code>，告诉它<code>read</code>操作完成了。</p>
<p>异步<code>I/O</code>模型使用了<code>Proactor</code>设计模式实现了这一机制。</p>
<p>因此对异步<code>IO</code>模型来说：</p>
<ul>
<li><strong>等待数据准备就绪（ <code>waiting for the data to be ready</code> ）<code>非阻塞</code></strong></li>
<li><strong>将数据从内核拷贝到进程中（ <code>Copying the data from the kernel to the process</code> ）<code>非阻塞</code></strong></li>
</ul>
<h4 id="2-6-各个-IO-model-的比较"><a href="#2-6-各个-IO-model-的比较" class="headerlink" title="2.6 各个 IO model 的比较"></a>2.6 各个 <code>IO model</code> 的比较</h4><p><img src="D:%5Chexo%5Cblog%5Cthemes%5Cfluid%5Csource%5Cimg%5Cblog_image%5CLinux_internetIO%5Cevery-model.png" alt="image-20210124201039496"></p>
<p>​    前四种模型的区别是阶段 <code>1</code> 不相同，阶段 <code>2</code> 基本相同（都是将数据从内核拷贝到调用者的缓冲区）。而异步<code>I/O</code> 的两个阶段都不同于前四个模型。同步 <code>I/O</code> 操作引起请求进程阻塞，直到 <code>I/O</code> 操作完成。异步 <code>I/O</code> 操作不引起请求进程阻塞。</p>
<p>​    同时通过上面的图片，可以发现 <code>non-blocking IO</code> 和 <code>asynchronous IO</code> 的区别还是很明显的。在<code>non-blocking IO</code>中，虽然进程大部分时间都不会被<code>block</code>，但是它仍然要求进程主动的<code>check</code>，并且当数据准备完成以后，也需要进程主动的再次调用<code>recvfrom</code>来将数据拷贝到用户内存。而<code>asynchronous IO</code>则完全不同。它就像是用户进程将整个<code>IO</code>操作交给了他人（<code>kernel</code>）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查<code>IO</code>操作的状态，也不需要主动的去拷贝数据。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lojunren/p/3856290.html">Linux下的I/O复用与epoll详解</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LittleHann/p/3897910.html">Linux Network IO Model</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1005481">大话 Select、Poll、Epoll</a></p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210125172219101.png" alt="image-20210124202517349"></p>
<hr>
<p>下面三种<code>IO</code>多路复用的对比，可以看到<code>epool</code>模型的性能比<code>select/poll</code>要高很多。</p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>select</th>
<th>poll</th>
<th>epoll</th>
</tr>
</thead>
<tbody><tr>
<td>操作方式</td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td>底层实现</td>
<td>数组<code>bitmap</code></td>
<td>链表</td>
<td>哈希表</td>
</tr>
<tr>
<td>查找就绪<code>fd</code>时间复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td>最大支持文件描述符数</td>
<td>一般有最大值限制</td>
<td>65535</td>
<td>65535</td>
</tr>
<tr>
<td>工作模式</td>
<td><code>LT</code> 水平触发</td>
<td><code>LT</code> 水平触发</td>
<td>支持 <code>ET</code> 高效模式</td>
</tr>
<tr>
<td><code>fd</code>拷贝</td>
<td>每次调用<code>select</code>都需要把<code>fd</code>集合从用户态拷贝到内核态</td>
<td>每次调用<code>poll</code>都需要把<code>fd</code>集合从用户态拷贝到内核态</td>
<td>使用 <code>map()</code> 文件映射内存来加速与内核空间的消息传递，减少复制开销</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>水平触发 <code>LT</code>：默认工作模式，即当 <code>epoll_wait</code> 检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用 <code>epoll_wait</code> 时，会再次通知此事件。</strong></p>
<p><strong>边缘触发 <code>ET</code>：当 <code>epoll_wait</code> 检测到某描述符事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用 <code>epoll_wait</code> 时，不会再次通知此事件。（直到你做了某些操作导致该描述符变成未就绪状态了，也就是说边缘触发只在状态由未就绪变为就绪时通知一次）。</strong></p>
</blockquote>
<p>下面是不同网络模型的性能对比：</p>
<p><img src="D:%5Chexo%5Cblog%5Cthemes%5Cfluid%5Csource%5Cimg%5Cblog_image%5CLinux_internetIO%5CLibevent_Benchmark.png" alt="image-20210124210250693"></p>
<blockquote>
<p>其中 <code>Kqueue</code> 是在 <code>FreeBSD</code> 平台上实现的 <code>I/O</code> 多路复用模型，跟 <code>Linux</code> 上的 <code>Epoll</code> 非常类似。</p>
</blockquote>
<h3 id="3-TCP-IP-协议简介"><a href="#3-TCP-IP-协议简介" class="headerlink" title="3. TCP/IP 协议简介"></a>3. <code>TCP/IP</code> 协议简介</h3><h4 id="3-1-TCP-三次握手四次断开简介"><a href="#3-1-TCP-三次握手四次断开简介" class="headerlink" title="3.1 TCP 三次握手四次断开简介"></a>3.1 <code>TCP</code> 三次握手四次断开简介</h4><p>​    简言之<code>TCP/IP</code>是指协议簇，也就是一组协议，而非单只<code>TCP</code>协议或者<code>IP</code>协议。我们今天要介绍的是这组协议中的<code>TCP</code>协议，主要会介绍跟<code>Nginx</code>调优相关的一些技术。首先我们要介绍著名的”<strong><code>TCP</code>协议的三次握手与四次挥手</strong>“，如下图：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210122200136865.png" alt="image-20210124214621677" style="zoom:50%;" />

<p>​    在咱们之前建立的<code>Nginx</code>服务器上，我们也可以通过抓包来查看这三次握手和四次挥手的过程，分别如下图所示的两个黑色选中部分，第一部分三个报文是建立<code>TCP</code>的三次握手，握手成功后开始建立<code>http</code>请求，与下面黑色部分之间则是数据报文的传递，客户端请求、服务端进行响应。后面的三行则是进行<code>TCP</code>的“四次挥手”（但是为什么只有三个报文，是因为我们请求的数据服务端已经完成了响应，没有额外需要发送的数据，所以客户端发送<code>FIN</code>标志位之后，服务端就直接回复<code>ACK</code>并且调用<code>close()</code>方法，也想客户端发送 了<code>FIN</code>标志，客户端接收到之后发送<code>ACK</code>确认信息，等待两个<code>MSL</code>周期之后关闭连接）</p>
<blockquote>
<p><strong>注意：两个最大段生命周期：<code>2MSL，2  MAXinum Segment Lifetime</code></strong></p>
</blockquote>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210125170007572.png" alt="image-20210124222117551"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">时区的修改：</span><br><span class="line">[root@test ~]# timedatectl set-timezone Asia/Shanghai</span><br><span class="line">[root@test ~]# date</span><br><span class="line">Sun Jan 24 22:30:00 CST 2021</span><br></pre></td></tr></table></figure>

<p>​    我们的优化部分会涉及到”<strong>三次握手和四次挥手</strong>“，当然这个跟系统级的优化也有关系。我们先来看下从网卡接收到数据包到交由<code>Linux</code>内核协议簇处理，再到建立<code>TCP</code>三次握手的简单过程，如下：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210124214621677.png" alt="image-20210125170007572"></p>
<p>如上图所示：对于<code>Client</code>端的一个请求，流程是这样的：</p>
<p>​    驱动程序将内存中的数据包转换成内核网络模块能识别的格式，数据包会被先存入到<code>CPU</code>的 <code>input_pkt_queue</code> 队列中（通过调整系统参数 <code>net.core.netdev_max_backlog</code>来调整队列大小），然后内核将<code>Client</code>首先发送的<code>SYN</code>连接信息放到<code>syn</code>队列中（该队列由内核参数<code>net.ipv4.tcp_max_syn_backlog</code>决定），这个时候队列中都处于半连接状态，同时返回一个<code>SYN+ACK</code>包给客户端，这里涉及到一个调优参数**<code>net.ipv4.tcp_synack_retries</code>**：即服务端向客户端返回<code>SYN+ACK</code>包给客户端，在<code>CentOS</code>上默认是5次（<code>ls + 2s + 4s + 8s + 16s = 31s</code>即会尝试5次，大概31s时间）。之后<code>Client</code>再次发送<code>ACK</code>包给服务端，内核会把连接从<code>syn</code>队列汇总取出，再把这个连接放到<code>accept</code>队列中，此时已经是<code>ESTABLISHED</code>状态。最后应用服务器调用<code>accept()</code>系统从<code>accept</code>队列中获取已经建立成功的连接套接字。这个里我们就涉及到以下内核调优参数，其中包含三个队列：</p>
<ul>
<li><p>**<code>net.core.netdev_max_backlog</code>**：接收自网卡，但未被内核协议栈处理的报文队列长度</p>
</li>
<li><p>**<code>net.ipv4.tcp_max_syn_backlog</code>**：<code>SYN_RCVD</code>状态（即半连接）队列长度</p>
</li>
<li><p><strong><code>backlog</code><strong>：全连接队列也就是我们图中标注的<code>accept队列</code>，该队列大小由系统参数和应用参数共同决定，即：</strong>全连接队列的大小取决于：<code>min(backlog,somaxconn)</code>，其中<code>backlog</code>是由应用程序传入，<code>somaxconn</code>是一个os级别的系统参数，通过设置<code>net.core.somaxconn</code>来调整</strong>。在<code>Nginx</code>中，<code>backlog</code>参数在<code>Listen</code>参数后面指定，在<code>CentOS</code>上，默认值为<code>511</code>。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl -a | grep <span class="string">&#x27;tcp_max_syn_backlog&#x27;</span></span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/core/somaxconn</span> </span><br><span class="line">10240</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_syn_retries（重试） <span class="comment">#半连接重试次数(default:6:63s)</span></span></span><br><span class="line">6 </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_synack_retries <span class="comment">#S→C: SYN+ACK重试次数（default:5:31s）1+2+4+8+16=31s</span></span></span><br><span class="line">5 #生产上会调到2</span><br></pre></td></tr></table></figure>

<h4 id="3-2-由三次握手引发的一些问题"><a href="#3-2-由三次握手引发的一些问题" class="headerlink" title="3.2 由三次握手引发的一些问题"></a>3.2 由三次握手引发的一些问题</h4><p>​    如果是 <code>syn队列</code> 满了，不开启 <code>syncookies</code>（由参数**<code>net.ipv4.tcp_syncookies</code><strong>决定）的时候，服务端会丢弃新来的<code>SYN</code>包，而<code>client</code>在多次重发<code>SYN</code>（由参数</strong><code>net.ipv4.tcp_syn_retries</code> **决定，默认为 <code>6</code> 次，大概是 <code>63s</code> 时间）包得不到响应而返回 <code>connection timeout</code> 报错。</p>
<blockquote>
<p><strong>注：<code>Client </code> 端在多次重发 <code>SYN</code> 包得不到响应而返回 <code>connection time out</code> 错误，通过命令行查看会有如下信息：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl -a | grep tcp_max_syn_backlog</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">netstat -s | grep LISTEN</span></span><br><span class="line">4375 SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure>

<p>即会显示<code>xxx SYNs to LISTEN sockets dropped</code>，也就是<code>SYN</code>包被丢弃。</p>
</blockquote>
<p>这里还涉及到另外一个内核参数<strong>net.ipv4.ip_local_port_range</strong>,默认值为<code>32768~60999</code>表示主动连接端可以建立的随机端口号范围。但是，当<code>Server</code>端开启了<code>net.ipv4.tcp_syncookies=1</code>，那么<code>SYN</code>半连接队列就没有逻辑上的最大值了。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment"># sysctl -a | grep &#x27;net.ipv4.ip_local_port_range&#x27; #主动连接端可以建立的随机端口号范围</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">net.ipv4.ip_local_port_range = 32768	60999</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment"># cat /proc/sys/net/ipv4/ip_local_port_range</span></span> </span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">32768	60999</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash"><span class="comment"># sysctl -a | grep net.ipv4.tcp_syncookies</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">net.ipv4.tcp_syncookies = 1</span></span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# ss -tnl #全连接</span><br><span class="line">State       Recv-Q Send-Q Local Address:Port                Peer Address:Port                  </span><br><span class="line">LISTEN      0      128                *:22                             *:*     </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">模拟出现溢出</span></span><br><span class="line">[root@test ~]# echo 1 &gt; /proc/sys/net/core/somaxconn </span><br><span class="line">[root@test ~]# systemctl restart sshd</span><br><span class="line">[root@test ~]# ss -tnl</span><br><span class="line">State       Recv-Q Send-Q Local Address:Port                Peer Address:Port                              </span><br><span class="line">LISTEN      0      1                  *:22                             *:*    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">写个脚本出现并发性的连接</span></span><br><span class="line">[root@test sh]# cat test.sh </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">for ((i=0;i&lt;100;i++));do &#123;</span><br><span class="line">	ssh root@10.4.7.100 &quot;date&quot;;</span><br><span class="line">&#125;&amp;</span><br><span class="line">done</span><br><span class="line">wait</span><br><span class="line">[root@test sh]# netstat -s | grep -i &#x27;listen&#x27;</span><br><span class="line">    104 times the listen queue of a socket overflowed #全连接溢出</span><br><span class="line">    104 SYNs to LISTEN sockets dropped #半连接溢出</span><br></pre></td></tr></table></figure>

<p>​    如果 <code>accept 队列</code> 即<strong>“全连接队列”</strong>满了之后，即使 <code>Client</code> 继续向 <code>server</code> 发送 <code>ACK</code> 的包，服务端会通过**<code>net.ipv4.tcp_abort_on_overflow</code>** 来决定如何响应，<code>0</code> 表示直接丢弃该 <code>ACK</code>，服务端过一段时间再次发送 <code>SYN+ACK</code> 给 <code>Client</code>（也就是重新走握手的第二步），如果 <code>Client</code> 超时等待比较短，就会返回 <code>read timeout</code>；<code>1</code> 表示发送 <code>RST</code> 通知 <code>Client</code> ，<code>Client</code> 端会返回 <code>connection reset by peer</code>。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sysctl -a | grep net.ipv4.tcp_abort_on_overflow</span></span><br><span class="line">net.ipv4.tcp_abort_on_overflow = 0</span><br></pre></td></tr></table></figure>

<p>我们来看下这个过程：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210124222117551.png" alt="image-20210125172219101"></p>
<p>​    这是我们正常的建立三次握手流程，其中半连接队列（<code>SYN Queue</code>）正常，全连接队列（<code>Accept Queue</code>）正常。如果半连接队列满了，但是全连接队列正常（这种情况很少），则请求发起方会在重复发送多次<code>SYN</code>后得不到响应而受到<code>connectioon timeout</code>错误。</p>
<p>但是如果全连接队列满了，半连接队列未满，此时同样会影响半连接的建立，应用程序读取正常连接速度较慢，如下：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210125220931312.png" alt="image-20210125172619227"></p>
<p>即当全连接队列满时，会发生下面四个行为：</p>
<ul>
<li><code>SYN</code>队列的入站<code>SYN</code>数据包将被丢弃</li>
<li><code>SYN</code>队列的入站<code>ACK</code>数据包将被丢弃</li>
<li><code>TcpExtListenOverflows</code>    <code>/  LINUX_MIB_LISTENOVERFLOWS</code>计数增加</li>
<li><code>TcpExtListenDrops</code>    <code>/  LINUX_MIB_LISTENDROPS</code>计数增加</li>
</ul>
<p>下面两个是<code>Linux</code>底层代码的逻辑数字大家不用关注，我们只需知道在全连接队列满了的情况下，半连接队列也是不会接收如栈数据的，至于为什么，这是因为系统的设计者希望让应用能够通过读取，读取全连接队列中的数据而慢慢的恢复。所以这也是为什么正常情况下，<code>sockets overflowed</code>会 ≥ <code>sockets ignored</code>，并且<code>overflowed</code>增加时<code>ignored</code>同步增加。</p>
<blockquote>
<p><strong>注：<code>sockets overflowed</code> 表示全连接队列溢出次数，<code>sockets ignored</code> 表示半连接队列溢出次数，如：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# netstat -s | egrep &quot;listen|LISTEN&quot;</span><br><span class="line">1641906 times the listen queue of a socket overflowed</span><br><span class="line">1641906 SYNs to LISTEN sockets ignored</span><br></pre></td></tr></table></figure>
</blockquote>
<p>我们可以通过<code>ss</code>命令来查看某个<code>IP:PORT</code>设置的全连接队列，以及当前正在使用的队列大小。如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@test sh]# ss -tnl sport = :80</span><br><span class="line">State       Recv-Q Send-Q Local Address:Port                Peer Address:Port              </span><br><span class="line">LISTEN      0      128                *:80                             *:*                  </span><br><span class="line">LISTEN      0      128             [::]:80                          [::]:*   </span><br><span class="line">[root@test sh]# cat /proc/sys/net/ipv4/tcp_max_syn_backlog </span><br><span class="line">10240</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><p><code>Recv-Q</code> 字段表示全连接队列中正在使用的队列大小；</p>
</li>
<li><p><code>Send-Q</code> 表示<code>backlog</code>设置的大小，注意该值的大小由<code>min(backlog,somaxconn)</code>决定。</p>
</li>
</ul>
<p>所以在生产环境中，我们要适当的调整这两个队列的参数的大小，以应对更大的数据流量。说到这里，我们就不得不引入一个常见的问题，叫做**<code>SYN</code>洪水攻击**。</p>
<h4 id="3-3-SYN-洪水攻击"><a href="#3-3-SYN-洪水攻击" class="headerlink" title="3.3 SYN 洪水攻击"></a>3.3 <code>SYN</code> 洪水攻击</h4><p>​    在第三次握手过程中，服务器发送<code>SYN-ACK</code>之后，收到客户端的<code>ACK</code>之前的<code>TCP</code>连接称为半连接<code>half-open connect</code>。此时服务器处于<code>SYN_RCVD</code>状态。当收到<code>ACK</code>后，服务器才能转入<code>ESTABLISHED</code>状态。</p>
<p>​    <code>SYN</code>攻击指的是，攻击客户端在短时间内伪造大量不存在的<code>IP</code>地址，向服务器不断地发送<code>SYN</code>包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断地重发直至超时，这些伪造的<code>SYN</code>包将长时间占用半连接队列，导致正常的<code>SYN</code>请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。也就是说只要填满<code>SYN</code>队列，就可以用很少的带宽成功地拒绝几乎所有<code>TCP</code>服务器的服务。</p>
<p>​    在<code>Linux</code>中我们可以通过设置参数<code>net.ipv4.tcp_syncookies = 1</code>来达到减少这种攻击的影响，如下图：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210125172619227.png" alt="image-20210125220931312"></p>
<p>​    当设置 <code>net.ipv4.tcp_syncookies = 1</code> 时，当 <code>SYN</code> 队列满了之后，新的<code>SYN</code>不进入队列，由服务端计算出<code>cookie</code>后再以<code>SYN+ACK</code>的方式返回给客户端，正常客户端发送报文时，服务器根据报文中携带的<code>cookie</code>信息重新恢复连接。</p>
<p>​    通过这个参数可以应对较小的<code>SYN</code>洪水攻击，如果攻击数量包太多，可能需要使用专业的防火墙。需要注意的是，如果启用了<code>tcp_syncookies</code>，则<code>TCP_FAST_OPEN</code>功能无法使用。</p>
<h4 id="3-4-关于-TFO-介绍"><a href="#3-4-关于-TFO-介绍" class="headerlink" title="3.4 关于 TFO 介绍"></a>3.4 关于 <code>TFO</code> 介绍</h4><p>这里跟大家再介绍一个参数**<code>net.ipv4.tcp_fastopen</code><strong>，我们来看下<code>TCP FastOpen</code>简称</strong>“TFO”<strong>过程，如下：在使用</strong>TFO**之前，<code>Client</code>首先需要通过一个普通的三次握手连接获取<code>FOC(Fast Open Cookie)</code></p>
<ul>
<li><code>Client</code>发送一个带有<code>Fast Open</code>选项的<code>SYN</code>包，同时携带一个空的<code>Cookie</code>域来请求一个<code>Cookie</code></li>
<li><code>Server</code>产生一个<code>Cookie</code>，然后通过<code>SYN+ACK</code>包的<code>Fast Open</code>选项来返回给<code>Client</code></li>
<li><code>Client</code>缓存这个<code>Cookie</code>以备将来使用<code>TFO</code>连接的时候使用</li>
</ul>
<p>这是第一次建立<code>TCP</code>连接时的过程，主要目的是获取<code>Cookie</code>，之后的连接需要通过该<code>Cookie</code>，如下：</p>
<ul>
<li><code>Client</code>发送一个带有请求数据的<code>SYN</code>包，同时在<code>Fast Open</code>选项中携带之前通过正常连接获取的<code>cookie</code></li>
<li><code>Server</code>验证这个<code>Cookie</code>，如果这个<code>cookie</code>是有效的，<code>Server</code>会返回<code>SYN+ACK</code>报文，同时会对请求的报文直接进行数据响应。如果这个<code>Cookie</code>是无效的，<code>server</code>会丢掉<code>SYN</code>包中的数据，同时返回一个<code>SYN+ACK</code>包来确认<code>SYN</code>包中的系列号进行普通握手。</li>
<li>剩下的连接处理就类似正常的<code>TCP</code>连接了，<code>Client</code>一旦获取到<code>FOC</code>，可以重复<code>Fast Open</code>直到<code>Cookie</code>过期。</li>
</ul>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210126133954178.png" alt="image-20210126133954178" style="zoom:50%;" />

<p><code>TFO</code>在<code>Linux</code>内核<code>2.6.34</code>中开始引入，<code>Nginx</code>也在版本<code>Release-1.5.8</code>支持了该功能，同样在<code>listen</code>字段中进行指定，下面我们就来介绍下这个参数：</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /proc/sys/net/ipv4/tcp_fastopen</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</blockquote>
<p>**<code>net.ipv4.tcp_fastopen</code><strong>：有四个可用值，分别为</strong>“0、1、2、3”**，含义如下：</p>
<ul>
<li><strong>禁用 <code>TFO</code> 功能；</strong></li>
<li><strong>作为客户端时可以使用 <code>TFO</code> 功能；</strong></li>
<li><strong>作为服务端是可以使用 <code>TFO</code> 功能；</strong></li>
<li><strong>无论是作为客户端还是服务端都可以使用 <code>TFO</code> 功能</strong></li>
</ul>
<p>另外，如果在 <code>Nginx</code> 服务中使用该功能，为了防止带有数据的 <code>SYN</code> 攻击，一般会限制 <code>TFO</code> 队列的连接长度，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">127.0.0.1:8000</span> fastopen=<span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p>​    在实际使用中需要客户端和服务端同时支持 <code>TFO</code> 功能才能启用（目前浏览器好像只有 <code>Chrome</code> 才支持），所以真正应用的场景并不太多。</p>
<h4 id="3-5-TCP-缓冲区优化设置"><a href="#3-5-TCP-缓冲区优化设置" class="headerlink" title="3.5 TCP 缓冲区优化设置"></a>3.5 <code>TCP</code> 缓冲区优化设置</h4><p><strong><code>net.ipv4.tcp_rmem = 4096 87380 6291456</code><strong>：读缓冲区</strong>最小值、默认值、最大值</strong>，单位为字节，其默认值与最大值会覆盖内核参数：<code>net.core.rmem_default</code>与<code>net.core.rmem_max</code>；</p>
<blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_rmem </span></span><br><span class="line">4096	87380	6291456</span><br><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_wmem </span></span><br><span class="line">4096	16384	4194304</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong><code>net.ipv4.tcp_wmem = 4096 16384 4194304</code><strong>：写缓冲区</strong>最小值、默认值、最大值</strong>，单位为字节，其默认值与最大值会覆盖内核参数：<code>net.core.wmem_default</code>与<code>net.core.wmem_max</code>；</p>
<p>如果指定了<code>tcp_wmem</code>，则<code>net.core.wmem_default</code>被<code>tcp_wmem</code>的覆盖。<code>send Buffer</code>在<code>tcp_wmem</code>的最小值和最大值之间自动调整。发送缓冲区的大小计算公式可以根据<strong>BDP带宽时延积</strong>来得出，比如客户端与服务端之间的带宽<code>100Mbps</code>，延时为<code>20ms</code>，那么<strong>BDP = 0.02s * (100Mb/8) = 256kbytes</strong>，此时我们可以将<code>net.ipv4.tcp_wmem</code>的默认值设置为<code>262144</code>，需要注意的是，我们的系统默认是可以自动调整发送，接收缓冲区大小的，所以一般程序不要设置该参数。我们只需要根据带宽和延迟给出比较合理的范围即可。</p>
<p>一般生产环境上会适当调大这两个参数。这里还有两个参数做个简单介绍：</p>
<p><strong><code>net.ipv4.tcp_mem = 1541646 2055528 3083292</code><strong>：分别表示</strong>系统无内存压力、启动压力模式阈值、最大值</strong>，单位为页的数量；</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">getconf PAGESIZE <span class="comment">#默认页的数量为4K</span></span></span><br><span class="line">4096</span><br></pre></td></tr></table></figure>
</blockquote>
<p>**<code>net.ipv4.tcp_moderate_rcvbuf = 1</code>**：表示开启自动调整缓存模式；</p>
<p>在<code>Nginx</code>中，我们同样可以在<code>listen</code>参数中对该参数进行设置，但是<strong>这种设置会破坏系统的自动调节能力，所以一般情况下我们不加指定。</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> address[:port] [rcvbuf=size] [sndbuf=size]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>关于TCP连接内存的使用，大家可以看下这篇文章 <a target="_blank" rel="noopener" href="https://blog.csdn.net/russell_tao/article/details/18711023">高性能网络编程7–tcp连接的内存使用</a></strong></p>
</blockquote>
<h4 id="3-6-TCP连接断开优化"><a href="#3-6-TCP连接断开优化" class="headerlink" title="3.6 TCP连接断开优化"></a>3.6 TCP连接断开优化</h4><p>我们来看下四次挥手过程中<strong>主动关闭一方</strong>和<strong>被动关闭一方</strong>两者不同时期的状态变化，如下图：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210126161342421.png" alt="image-20210126143447998"></p>
<p>我们可以看下当一方主动断开时，主动断开方和被动断开方之间的状态变化：</p>
<p>​    我们来对上面的过程（四次断开）做个简单的流程说明。数显需要跟大家明确的一点是，我们图中标注的**”客户端A”<strong>不一定是指咱们的浏览器或者某个<code>app</code>应用，也可以是服务器。比如当我们使用<code>Nginx</code>做网络代理时，其实此时的<code>Nginx</code>服务器就作为用户的服务器，同时也作为后端真正应用服务器的客户端。为了方便说明问题，我们将主动断开的一方此处称为</strong>“客户端A”<strong>（或者如下图的<code>Client</code>），将被动断开的一方此处称为</strong>“服务器B”**（或者下图的<code>Server</code>）。</p>
<ul>
<li>客户端如果希望断开连接会向服务端发送带有<code>FIN</code>标志位的报文，此时客户端连接由<code>ESTABLISHED</code>状态变成<code>FIN_WAIT1</code>；</li>
<li>服务器端在收到客户端发送的<code>FIN</code>请求报文后，此时服务端可能还有报文需要发送，会带着未发送完的数据和（客户端<code>FIN</code>报文的确认信息）<code>ACK</code>信息返回给客户端，同时连接也会由<code>ESTABLISHED</code>状态变为<code>CLOSE_WAIT</code>；</li>
<li>当客户端收到服务端发来的<code>ACK</code>确认报文后，就变成<code>FIN_WAIT2</code>状态，等待服务器端的断开；</li>
<li>如果服务器端数据已经发送完了，调用<code>close</code>方法，将向客户端发送<code>FIN</code>报文，申请关闭连接，此时服务器端由<code>CLOSE_WAIT</code>状态变为<code>LAST_ACK</code>状态，等待客户端的确认信息；</li>
<li>客户端在收到服务端的<code>FIN</code>报文后，会向服务器端发送<code>ACK</code>确认信息，同时从<code>FIN_WAIT2</code>状态变为<code>TIME_WAIT</code>状态；</li>
<li>服务器端再收到客户端的<code>ACK</code>确认信息之后，会立即关闭连接（<code>CLOSED</code>）</li>
<li>客户端再等待<code>2MSL</code>之后，也会关闭己方维护的连接，至此客户端与服务端完成<code>TCP</code>的四次断开</li>
</ul>
<blockquote>
<p>​    <strong>注意：有时候断开连接可能只需要三次，即当被动断开方在收到主动断开方的<code>FIN</code>报文后，也无额外数据响应，此时就会连同<code>ACK</code>确认号以及<code>FIN</code>标志一起发送给主动断开方，同时进入<code>LAST_ACK</code>阶段。我们上面的抓包示例图其实就是三次断开。</strong></p>
</blockquote>
<h5 id="3-6-1-被动断开方异常"><a href="#3-6-1-被动断开方异常" class="headerlink" title="3.6.1 被动断开方异常"></a>3.6.1 被动断开方异常</h5><ul>
<li>被动断开一方（多为<code>RealServer</code>）上有大量的<code>CLOSE_WAIT</code>状态连接，一定是我们的应用程序有<code>Bug</code>，也就是没有判断数据读取为 <code>0</code> 或者说数据发送完之后，没有调用<code>close()</code>方法，导致一直处于<code>CLOSE_WAIT</code>阶段；</li>
<li>被动断开一方（多为<code>RealServer</code>）上有大量的<code>LAST_ACK</code>状态连接，则一般是无法收到主动断开方的<code>ACK</code>报文，一般这种情况出现时多时网络故障，和系统与应用层面的关系不大；</li>
</ul>
<h5 id="3-6-2-主动断开方异常"><a href="#3-6-2-主动断开方异常" class="headerlink" title="3.6.2 主动断开方异常"></a>3.6.2 主动断开方异常</h5><p>​    这里我们说的主动断开方，更多的场景是在<code>Nginx</code>作为反向代理时，一般情况下服务器上我们很少会看到<code>FIN_WAIT1</code>和 <code>FIN_WAIT2</code> 状态（除非网络层面故障），关于这两种状态我们有两个内核参数可以进行优化，如下：</p>
<p>​    **<code>net.ipv4.tcp_orphan_retries = 0</code>**：用来表示发送 <code>FIN</code> 报文的重试次数，默认为 <code>8</code> 次，<code>0</code> 次也表示 <code>8</code> 次，如果服务器上有大量的<code>FIN_WAIT1</code>连接，肯定是网络层面出现问题，即使我们调下这个值，也之后减少该状态值出现的时间，而不能解决根本问题，即治标不治本。但是适当的调小此时有利于在网络层面出现问题的情况下直接暴露出来，而不是长时间的尝试等待。一般在 <code>Web</code> 服务器上，我们会把值设置为 <code>2</code> 或者 <code>3</code> 即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">下面这段代码诠释了为什么值为0的时候也相当于8；</span></span><br><span class="line">&#123;</span><br><span class="line">	int retries = sysctl_tcp_orphan_retries; /* May be zero. */</span><br><span class="line">	/* We know from an ICMP that something is wrong. */</span><br><span class="line">	if (sk-&gt;sk_err_soft &amp;&amp; !alive)</span><br><span class="line">			retries = 0;</span><br><span class="line">	/* However, if socket sent something recently, select some safe</span><br><span class="line">	 * number of retries. 8 corresponds to &gt;100 seconds with minimal</span><br><span class="line">	 * RTO of 200msec. */</span><br><span class="line">	if (retries == 0 &amp;&amp; alive)</span><br><span class="line">			retries = 8;</span><br><span class="line">	return retries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    **<code>net.ipv4.tcp_fin_timeout = 60</code>**：表示主动断开连接端保持在<code>FIN_WAIT2</code>状态的超时时间。这种情况的出现跟被动断开的<code>CLOSE_WAIT</code>大量出现问题相似，也有可能是被动断开端应用未调用<code>close()</code>方法发送<code>FIN</code>报文导致，当然也有可能是网络层面原因。在<code>web</code>服务的生产环境中，一般会适当调下该值，比如我们可以设置10或者15（单位秒）。</p>
<p>​    在主动关闭一方，<code>FIN_WAIT1</code>与<code>FIN_WAIT2</code>这种状态在正常情况下很少会看到，但是<code>TIME_WAIT</code>状态则经常会遇到，下面我们来讨论下<code>TIME_WAIT</code>状态存在的含义，这个值如果设置的太小或者不存在会有什么影响以及该如何优化等问题。</p>
<p>首先我们来讨论下<code>TIME_WAIT</code>时间过短或者不存在会发生什么问题？</p>
<ul>
<li><strong>数据报文重复</strong> 造成的数据混乱问题</li>
</ul>
<p>如下图：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210126173208158.png" alt="image-20210126161342421" style="zoom:50%;" />

<p>​    即客户端（主动断开方）在发送<code>FIN</code>报文之前，服务端给我们发送了三个报文，但是由于网络原因，客户端只能收到前两个报文，于是服务器又重新发送了第三个报文。客户端在接收到这个报文后发起了断开连接请求，也就是我们前面介绍的四次挥手。但是这时如果我们<code>TIME_WAIT</code>时间设置过短，直接关闭了客户端连接。此时又与服务器建立了新连接，并且凑巧的建立连接的网络四元组（<strong>Client IP，Client PORT &amp; Server IP，Server PORT</strong>）恰好一致，同时服务器端也发送了三号报文，这时上次连接的三号报文恰好被服务器端接收，就会造成数据报文的重复混乱，这种概率很小，但是网络数据报文数据量非常大，所以这个问题会给我们造成非常大的困扰。</p>
<ul>
<li><strong>ACK报文丢失</strong> 造成的连接被重置问题</li>
</ul>
<p>如下图：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210126143447998.png" alt="image-20210126173208158" style="zoom:50%;" />

<p>​    同样，如果<code>TIME_WAIT</code>时间过短或者不存在，导致客户端向服务器端发送最后一个<code>ACK</code>报文丢失而没能重发（因为<code>TIME_WAIT</code>时间太短，客户端已经自己关闭了这个连接），此时客户端连接已经关闭，但是服务器仍于处<code>LAST_ACK</code>阶段，等待最后一个<code>ACK</code>报文的到来。如果这个时候客户端期望建立新的连接，向服务器端发送了<code>SYN</code>报文，此时服务器端会直接回复<code>RST</code>报文而重置此连接，这时客户端就会产生异常。</p>
<p>​    以上两个问题就是<code>TIME_WAIT</code>为什么要存在，且存在周期那么长的原因。同样，因为存在时间过长，所以可能导致大量的资源被浪费，包括端口资源，协议栈队列，所以大量的<code>TIME_WAIT</code>会影响<code>socket</code>建立新连接，这点特别在高性能的<code>web</code>服务器中很讲究，如何进行相关的优化呢？</p>
<p>​    首先我们可以考虑挣增大服务器允许的<code>TIME_WAIT</code>数量值，通过修改内核参数**<code>net.ipv4.tcp_max_tw_buckets</code><strong>来调整，默认值是<code>16384</code>，比如我们可以调大至<code>262144</code>，超过该数量后直接关闭连接。但是这只能解决<code>TIME_WAIT</code>过多导致的无法建立新连接的问题，而不能解决资源浪费的问题。当然。如果你的服务器资源并不富裕，那么你可以调小这个值，让</strong><code>TIME_WAIT</code>**始终处于一个低值（比如<code>5000</code>）,以避免造成资源浪费。所以，根据自己需求调整。</p>
<blockquote>
<p><strong>注意：<code>net.ipv4.tcp_max_tw_buckets</code>（buckets：桶的量）表示系统同时保持<code>TIME_WAIT</code>的最大数量，如果超过这个量，<code>TIME_WAIT</code>将打印警告信息：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TCP: time wait bucket table overflow</span><br><span class="line">TCP: time wait bucket table overflow</span><br><span class="line">TCP: time wait bucket table overflow</span><br><span class="line">TCP: time wait bucket table overflow</span><br><span class="line">TCP: time wait bucket table overflow</span><br></pre></td></tr></table></figure>

<p>超限的时候后面产生的 <code>TIME_WAIT</code> 直接不处理，释放资源。注意：是新的连接直接释放资源。老的连接还是处于 <code>TIME_WAIT</code> 状态。</p>
</blockquote>
<p>我们可以考虑使用这个内核参数：</p>
<p><strong><code>net.ipv4.tcp_tw_reuse = 1</code><strong>：开启后，我们在作为客户端时可以使用仍然处于<code>TIME_WAIT</code>状态的端口，与服务端使用之前维持的连接，但是同样需要解决上面的两个问题，即 <strong>数据报文重复</strong> 造成的数据混乱问题以及</strong>ACK报文丢失</strong> 造成的连接被重置问题。</p>
<p>对于 <strong>数据报文重复</strong> 问题，引入了<code>timestamp</code>即时间戳，让操作系统可以拒绝迟到的报文。因此如果想要启动<code>net.ipv4.tcp_tw_reuse</code>必须先设置**<code>net.ipv4.tcp_timestamps = 1</code>**（默认即为启用）</p>
<p>对于<strong>ACK 报文丢失</strong>造成的连接被重置问题，在我们复用了客户端<code>TIME_WAIT</code>连接之后，<code>socket</code>五元组并没有变化，因此客户端使用该连接的地址和端口向服务端发送<code>SYN</code>报文，不会被服务端<code>RST</code>，但是因为未收到客户端的<code>ACK</code>报文，所以会再次发送<code>FIN+ACK</code>报文，这时客户端看到此报文后认为异常，会重置<code>RST</code>服务器端连接，此时客户端再次发送<code>SYN</code>请求握手，服务器端返回<code>SYN+ACK</code>，然后重新建立新的连接。</p>
<p>其原理如下：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210126192853493.png" alt="image-20210126192853493" style="zoom:50%;" />



<p>如果客户端最后一个ACK没有丢失怎么办？没有丢失的话当然更好了。因为此时服务器端已经正常端口连接了，我们在客户端复用 <code>TIME_WAIT</code> 端口重新与服务端建立新连接即可。</p>
<p>跟<code>TIME_WAIT</code>端口复用的还有一个参数，也是基于<code>timestamp</code>才能启用的，即：</p>
<p><code>net.ipv4.tcp_tw_recycle</code>：启动该参数后，同时作为客户端和服务器都可以使用<code>TIME_WAIT</code>状态的端口，这个会带来很多不安全问题，同时经常会因为报文延迟、重复给新连接造成混乱（虽然也可以通过<code>timestamp</code>来避免），但是另外一个重要的弊端则无法解决。即：当作为服务端时，用户经过<code>NAT</code>网络访问时，其源<code>IP</code>地址都会转换成相同的出口地址，当来自同一个<code>IP</code>地址（任意源端口号）后来的数据包中<code>TCP</code>选项字段如果有<code>timestamp</code>且比前面的数据包中的<code>timestamp</code>小，则<code>server</code>不做<code>ACK</code>响应。目前在高版本<code>Linux 4.12</code>已经移除了该参数，所以大家尽量不要启动该功能，即设置<code>net.ipv4.tcp_tw_recycle=0</code>。</p>
<h4 id="3-7-其他内核参数优化"><a href="#3-7-其他内核参数优化" class="headerlink" title="3.7 其他内核参数优化"></a>3.7 其他内核参数优化</h4><p>下面介绍两个关于 <code>TCP</code> 丢包重传的参数：</p>
<p>**<code>net.ipv4.tcp_retries1 = 3</code>**：（<code>retries</code>：重试）默认值为 <code>3</code>，表示到达上限后，更新路由缓存；</p>
<p>**<code>net.ipv4.tcp_retries2 = 15</code>**：默认值为 <code>15</code>，表示到达上限后，关闭<code>TCP</code>连接；</p>
<p>需要注意的是，这两个值在生产上使用不合适，实际情况下可能还没到达<code>retries</code>次数就已经达到时间上限，所以生产上我们一般会调整两个参数的值，比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_retries1 = 2</span><br><span class="line">net.ipv4.tcp_retries2 = 3</span><br></pre></td></tr></table></figure>

<p>下面在介绍下关于<strong>TCP KeepAlive</strong>的参数：</p>
<p>我们知道在实际使用中，<strong>为了减少<code>TCP</code>建立连接的次数，<code>TCP</code>连接保持一段时间之后再断开是一个非常好的优化手段</strong>，但是如果一个<code>TCP</code>连接如果长时间打开而不使用，则会很大程度上浪费服务器资源，因此我们会适当调整系统级与应用级参数，以最大限度的提升服务器性能。</p>
<p>**<code>net.ipv4.tcp_keepalive_time = 7200</code>**：表示多久对一个<code>TCP</code>空闲连接发送一次心跳探测报文，单位是秒，所以默认是 <code>2</code>小时；</p>
<p>**<code>net.ipv4.tcp_keepalive_intvl = 75</code>**：探测包每次发送的时间间隔；</p>
<p>**<code>net.ipv4.tcp_keepalive_probes = 9</code>**：探测包发送次数；</p>
<p>因为系统级的配置会影响所有应用，所以这几个参数都是设置的非常“宽松”，因此我们应该根据自己的业务区适当调整，其实最好去调整某个具体应用。这里我们给出一个相对较为妥善的参考值：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.<span class="attribute">tcp_keepalive_time</span> = <span class="number">600</span> <span class="comment">#每十分钟对一个TCP空闲连接发送一次心跳探测报文</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl = <span class="number">2</span> <span class="comment">#探测包每次发送的时间间隔</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes = <span class="number">9</span> <span class="comment">#探测包发送次数</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：一般生产情况下，最好尽量去设置某个应用的连接超时时间，因为修改系统值会影响到所有的应用。不过我们设置为10-30 分钟作用也是一个对各个应用来说差不多都可以接受的值。</strong></p>
</blockquote>
<p>在<code>Nginx</code>中，我们也可以针对<code>Nginx</code>应用做单独设置，配置方式如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> so_keepalive=<span class="literal">on</span>|<span class="literal">off</span>|[keepalive]:[keepintvl]:[keepcnt]</span><br><span class="line"> 						   [多长时间发送一次心跳检测]:[探测包发送的时间间隔]:[探测包发送的次数]</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> so_keepalive=<span class="number">5m</span>::<span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>如果某个参数没有指定，则会使用系统的默认参数，比如我们没有指定探测包发送时间间隔，则会根据系统内核参数<code>net.ipv4.tcp_keepalive</code>来进行设置。</p>
<blockquote>
<p><strong>注意：该参数是针对 TCP keepalive 行为，并不是http的keep-alive 即长连接功能，两者无论是设计作用还是功能都不一样。关于 TCP keepalive 和 HTTP keep-alive的区别大家可以参考这篇文章：<a target="_blank" rel="noopener" href="https://www.byte-edu.com/">HTTP Keep-Alive 和 TCP Keepalive</a></strong></p>
</blockquote>
<p>除此之外，还有几个和文件句柄相关的内核参数，我们知道在<code>Linux</code>中除了进程外，一切皆文件，<code>socket</code>当然也是文件，所以我们能建立多少<code>socket</code>并维持多少连接，和我们能打开的文件句柄数有直接联系。</p>
<p><strong>【系统级全局限制】</strong></p>
<p>**<code>fs.file-max = 398458</code>**：表示操作系统可以使用的最大句柄数，该值默认值太小，我们需要调整为<code>fs.file-max = 40000500</code></p>
<p>**<code>fs.file-nr = 768 0 398458</code>**：这个参数不用设置，是用来查看 <strong>当前已经分配、正使用、最大值</strong>（与<code>fs.file-max</code>一致）的文件句柄数；</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">test</span> ~]<span class="comment"># sysctl -a | grep fs.file-max  ##文件最大句柄数</span></span><br><span class="line">fs.file-max = <span class="number">95106</span></span><br><span class="line"></span><br><span class="line">[root<span class="variable">@test</span> ~]<span class="comment"># sysctl -a | grep fs.file-nr ##查看 当前已经分配、正使用、最大值的文件句柄数</span></span><br><span class="line">fs.file-nr = <span class="number">1312</span>	<span class="number">0</span>	<span class="number">95106</span></span><br><span class="line"></span><br><span class="line">[root<span class="variable">@test</span> ~]<span class="comment"># sysctl -a | grep fs.nr_open ##单个进程可以打开的文件句柄数</span></span><br><span class="line">fs.nr_open = <span class="number">1048576</span></span><br></pre></td></tr></table></figure>

<p>**<code>fs.nr_open = 1048576</code>**：表示单个进程可以打开的文件句柄数。默认值已经很大了，</p>
<p>但是如果是分布式图片服务器可能还是不足，可以适当调整。</p>
<p>除了系统级全局限制，还有针对用户的限制，我们可以通过创建文件<code>/etc/security/limits.d/nofile.conf</code>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# vim /etc/security/limits.d/nofile.conf</span><br><span class="line">*		soft		nofile		65535</span><br><span class="line">*		hard		nofile		65535</span><br><span class="line">root	soft		nofile		65535</span><br><span class="line">root	hard		nofile		65535</span><br></pre></td></tr></table></figure>

<p>除此之外，还有应用层面的限制，比如在<code>Nginx</code>中，我们可以这样设置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">worker_flimit_nofile</span> number;</span><br><span class="line">Default: -</span><br><span class="line">Context: main</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Changes the limit on the maximum number of open files (<code>RLIMIT_NOFILE</code>) for worker processes.</strong></p>
</blockquote>
<p>至此，系统级相关的参数功能以及优化设置我们就整理的差不多了，限制我们可以总结一下。</p>
<hr>
<h3 id="4-Linux内核优化"><a href="#4-Linux内核优化" class="headerlink" title="4. Linux内核优化"></a>4. Linux内核优化</h3><p>首先，你需要修改<code>/etc/sysctl.conf</code>来更改内核参数。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">服务端向客户端返回SYN+ACK包给客户端，CentOS上默认是5次（31s）1+2+4+8+16</span></span><br><span class="line">net.ipv4.tcp_synack_retries = 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据包会被先存入到CPU的input_pkt_queue队列中，如果队列满了数据会被丢弃,通过调整系统参数来调整队列大小</span></span><br><span class="line">net.core.netdev_max_backlog = 250000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内核将Client首先发送的SYN连接信息放到syn队列中,SYN_RCVD状态（即半连接）队列长度</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">全连接队列的大小取决于：min(backlog,somaxconn)，其中backlog是由应用程序传入，somaxconn是一个os级别的系统参数，通过设置net.core.somaxconn来调整。</span></span><br><span class="line">net.core.somaxconn = 10240</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当设置net.ipv4.tcp_syncookies = 1时，当SYN队列满了之后，新的SYN不进入队列，由服务端计算出cookie后再以SYN+ACK的方式返回给客户端，正常客户端发送报文时，服务器根据报文中携带的cookie信息重新恢复连接。</span></span><br><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果是syn队列满了，不开启syncookies（由参数net.ipv4.tcp_syncookies决定）的时候，服务端会丢弃新来的SYN包，而client在多次重发SYN（由参数net.ipv4.tcp_syn_retries决定，默认为6次，大概是63s时间）包得不到响应而返回connection <span class="built_in">timeout</span>报错。netstat -s | grep LISTEN 4375 SYNs to LISTEN sockets dropped 1+2+4+8+16+32=63</span></span><br><span class="line">net.ipv4.tcp_syn_retries = 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">内核参数net.ipv4.ip_local_port_range,默认值为32768~60999表示主动连接端可以建立的随机端口号范围。但是，当Server端开启了net.ipv4.tcp_syncookies=1，那么SYN半连接队列就没有逻辑上的最大值了。</span></span><br><span class="line">net.ipv4.ip_local_port_range = 32768 65000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果accept 队列，即 全连接队列 满了之后，即使Client继续向server发送ACK的包，服务端会通过net.ipv4.tcp_abort_on_overflow来决定如何响应，0表示直接丢弃该ACK，服务端过一段时间再次发送SYN+ACK给Client（也就是重新走握手的第二步），如果Client超时等待比较短，就会返回<span class="built_in">read</span> <span class="built_in">timeout</span>；1表示发送RST通知Client，Client端会返回connection reset by peer。</span></span><br><span class="line">net.ipv4.tcp_abort_on_overflow = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_rmem = 4096 87380 6291456：读缓冲区 最小值、默认值、最大值，单位为字节，其默认值与最大值会覆盖内核参数：net.core.rmem_default与net.core.rmem_max；</span></span><br><span class="line">net.ipv4.tcp_rmem = 16384 1048576 12582912</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_wmem = 4096 16384 4194304：写缓冲区 最小值、默认值、最大值，单位为字节，其默认值与最大值会覆盖内核参数：net.core.wmem_default与net.core.wmem_max；</span></span><br><span class="line">net.ipv4.tcp_wmem = 16384 1048576 12582912</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">net.ipv4.tcp_mem = 1541646 2055528 3083292：分别表示 系统无内存压力、启动压力模式阈值、最大值，单位为页的数量；</span></span><br><span class="line">net.ipv4.tcp_mem = 1541646 2055528 3083292</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_moderate_rcvbuf = 1：表示开启自动调整缓存模式；在`Nginx`中，我们同样可以在`listen`参数中对该参数进行设置，但是**这种设置会破坏系统的自动调节能力，所以一般情况下我们不加指定。**</span></span><br><span class="line">net.ipv4.tcp_moderate_rcvbuf = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_orphan_retries = 0：用来表示发送`FIN`报文的重试次数，默认为8次，0次也表示8次，如果服务器上有大量的`FIN_WAIT1`连接，肯定是网络层面出现问题，即使我们调下这个值，也之后减少该状态值出现的时间，而不能解决根本问题，即治标不治本。但是适当的调小此时有利于在网络层面出现问题的情况下直接暴露出来，而不是长时间的尝试等待。一般在`Web`服务器上，我们会把值设置为2或者3即可。</span></span><br><span class="line">net.ipv4.tcp_orphan_retries = 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_fin_timeout = 60：表示主动断开连接端保持在`FIN_WAIT2`状态的超时时间。这种情况的出现跟被动断开的`CLOSE_WAIT`大量出现问题相似，也有可能是被动断开端应用未调用`close()`方法发送`FIN`报文导致，当然也有可能是网络层面原因。在`web`服务的生产环境中，一般会适当调下该值，比如我们可以设置10或者15（单位秒）。</span></span><br><span class="line">net.ipv4.tcp_fin_timeout = 15</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">首先我们可以考虑挣增大服务器允许的`TIME_WAIT`数量值，通过修改内核参数net.ipv4.tcp_max_tw_buckets来调整，默认值是`16384`，比如我们可以调大至262144，超过该数量后直接关闭连接。但是这只能解决TIME_WAIT过多导致的无法建立新连接的问题，而不能解决资源浪费的问题。当然。如果你的服务器资源并不富裕，那么你可以调小这个值，让TIME_WAIT始终处于一个低值（比如5000）,以避免造成资源浪费。所以，根据自己需求调整。</span></span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 5000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_tw_reuse = 1：开启后，我们在作为客户端时可以使用仍然处于`TIME_WAIT`状态的端口，与服务端使用之前维持的连接，但是同样需要解决上面的两个问题，即 数据报文重复 造成的数据混乱问题以及ACK报文丢失 造成的连接被重置问题。</span></span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_tw_recycle：启动该参数后，同时作为客户端和服务器都可可以使用`TIME_WAIT`状态的端口，这个会带来很多不安全问题，同时经常会因为报文延迟、重复给新连接造成混乱（虽然也可以通过`timestamp`来避免），但是另外一个重要的弊端则无法解决。即：当作为服务端时，用户经过`NAT`网络访问时，其源`IP`地址都会转换成相同的出口地址，当来自同一个`IP`地址（任意源端口号）后来的数据包中`TCP`选项字段如果有`timestamp`且比前面的数据包中的`timestamp`小，则`server`不做`ACK`响应。目前在高版本`Linux 4.12`已经移除了该参数，所以大家尽量不要启动该功能，即设置`net.ipv4.tcp_tw_recycle=0`。</span></span><br><span class="line">net.ipv4.tcp_tw_recycle = 0</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">对于 数据报文重复 问题，引入了timestamp即时间戳，让操作系统可以拒绝迟到的报文。因此如果想要启动net.ipv4.tcp_tw_reuse必须先设置net.ipv4.tcp_timestamps = 1（默认即为启用）</span></span><br><span class="line">net.ipv4.tcp_timestamps = 1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_retries1 = 3：默认值为3，表示到达上限后，更新路由缓存；</span></span><br><span class="line">net.ipv4.tcp_retries1 = 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_retries2 = 15：默认值为15，表示到达上限后，关闭`TCP`连接；</span></span><br><span class="line">net.ipv4.tcp_retries2 = 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_keepalive_time = 600：表示多久对一个`TCP`空闲连接发送一次心跳探测报文，单位是秒，所以默认是2小时；</span></span><br><span class="line">net.ipv4.tcp_keepalive_time = 600</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_keepalive_intvl = 75：探测包每次发送的时间间隔；</span></span><br><span class="line">net.ipv4.tcp_keepalive_intvl = 2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">net.ipv4.tcp_keepalive_probes = 9：探测包发送次数；</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes = 3</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">fs.file-max = 398458：表示操作系统可以使用的最大句柄数，该值默认值太小，我们需要调整为fs.file-max = 40000500</span></span><br><span class="line">fs.file-max = 500000000</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">fs.nr_open = 1048576：表示单个进程可以打开的文件句柄数。默认值已经很大了，</span></span><br><span class="line">fs.nr-open = 10000000</span><br></pre></td></tr></table></figure>

<h3 id="5-Nginx-调优"><a href="#5-Nginx-调优" class="headerlink" title="5. Nginx 调优"></a>5. <code>Nginx</code> 调优</h3><h4 id="5-1主配置段优化"><a href="#5-1主配置段优化" class="headerlink" title="5.1主配置段优化"></a>5.1主配置段优化</h4><p>在介绍完关于系统部分的优化内容后，<code>Nginx</code>自身也提供了一些优化参数，我们一起来看下。</p>
<p><strong>【设置进程静态优先级】</strong> </p>
<p>我们从宏观层面上看一颗<code>CPU</code>好像可以同时执行很多进程，但其实从微观意义上来看，这些进程其实是串行执行的，也就是<code>CPU</code>把进程的运行时间分成了一个个的时间片，然后<code>CPU</code>在通过系统调度某个进程，然后最多执行该进程时间片的时间。所以，如果进程时间分成一个个的时间片，那么他的执行优先级就更高，在<code>Linux</code>中我们可以通过调整<code>NICE</code>即静态优先级 <code>-20 ~ 19</code> 的大小来实现。数值越小，优先级越高，因此我们可以将<code>Nginx</code>优先级设置为<code>-20</code>，设置参数如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">worker_priority</span> number；</span><br><span class="line">Default: worker_priority <span class="number">0</span>;</span><br><span class="line">Context: main</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：在<code>Nginx</code>官方文档中提到可以将该值设置为<code>-20 ~ 20</code>，其实从<code>Linux</code>系统层面来说超过<code>-20 ~ 19</code>都是无意义的。</strong> </p>
</blockquote>
<p>设置完成后，需要重启 <code>Nginx</code> 才能生效，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# vi /etc/nginx/nginx.conf</span><br><span class="line">主配置段</span><br><span class="line">worker_priority -20;</span><br><span class="line"></span><br><span class="line">[root@test ~]# top -u nginx</span><br><span class="line">   PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                 </span><br><span class="line">  1484 nginx      0 -20  109016   4828    556 S  0.0  0.5   0:00.00 nginx </span><br></pre></td></tr></table></figure>

<p><strong>【设置 <code>worker</code> 进程数】</strong></p>
<p>现在我们的处理器一般都是多核<code>CPU</code>，进程的数量一般设置要大于<code>CPU</code>核心数，但是在<code>Nginx</code>的体系中，<code>worker</code>进程是用来处理用户请求的进程非常繁忙，所以最好设置成与<code>CPU</code>核心数一样，以免多个<code>worker</code>进程争抢一颗<code>CPU</code>，同时最好将<code>worker</code>进程与<code>CPU</code>核心进行绑定，以便更好的利用<code>CPU</code>的多级缓存。目前关于<code>worker</code>进程数的设置语法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: worker_processes number | auto;</span><br><span class="line">Default: worker_processes 1;</span><br><span class="line">Context: main</span><br></pre></td></tr></table></figure>

<p>如果设置成<code>auto</code>则会根据<code>CPU</code>核心数自动创建相同个数的<code>worker</code>进程，在<code>CentOS</code>中可以通过如下命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@test ~]# lscpu  | grep CPU\(s\) </span><br><span class="line">CPU(s):                1</span><br><span class="line">On-line CPU(s) list:   0</span><br><span class="line">NUMA node0 CPU(s):     0</span><br><span class="line"></span><br><span class="line">[root@test ~]# vi /etc/nginx/nginx.conf</span><br><span class="line">主配置段</span><br><span class="line">worker_processes 1;</span><br></pre></td></tr></table></figure>

<p>比如，我的虚拟机上的<code>Linux</code>系统的<code>CPU</code>核心数是1。</p>
<p><strong>【CPU绑定提供缓存命中率】</strong></p>
<p>为了适应<code>CPU</code>的高速取值，现在的<code>CPU</code>一般会有三级缓存，其中一级<code>L1</code>缓存速度最好，二级<code>L2</code>次之，三级<code>L3</code>最慢，其中<code>L1</code>与<code>L2</code>为单插槽上单核<code>CPU</code>独享，<code>L3</code>则是单插槽上多核<code>CPU</code>共享，如下：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210127140009522.png" alt="image-20210127132142578"></p>
<p>因此，为了让<code>worker</code>能够更好的使用<code>CPU</code>的高速缓存，我们建议将<code>worker</code>与<code>CPU</code>核心进行一对一绑定，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">worker_cpu_affinity</span> cpumask ...;</span><br><span class="line">        <span class="attribute">worker_cpu_affinity</span> auto [cpumask];</span><br><span class="line">Default: -</span><br><span class="line">Context: main</span><br></pre></td></tr></table></figure>

<p>示例：对于四颗核心的<code>CPU</code>应该这样绑定：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes    4;</span><br><span class="line">worker_cpu_affinity 0001 0010 0100 1000;</span><br></pre></td></tr></table></figure>

<p>假如我只想启动2个<code>worker</code>进程，并且指定仅使用<code>CPU0</code>与<code>CPU3</code>，可以这样设置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes    2;</span><br><span class="line">worker_cpu_affinity 0001 1000;</span><br></pre></td></tr></table></figure>

<p>还有一种写法比较特殊，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker_processes    2;</span><br><span class="line">worker_cpu_affinity 0101 1010;</span><br></pre></td></tr></table></figure>

<p>则表示第一个<code>worker</code>进程被绑定到<code>CPU0/CPU2</code>，第二个<code>worker</code>进程被绑定到<code>CPU1/CPU3</code>。这种使用方式较少见。</p>
<p>我们可以查看自己节点上<code>CPU</code>的三级缓存大小，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1级缓存大小</span></span><br><span class="line">[root@test nginx]# cat /sys/devices/system/cpu/cpu0/cache/index1/size </span><br><span class="line">32K</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2级缓存大小</span></span><br><span class="line">[root@test nginx]# cat /sys/devices/system/cpu/cpu0/cache/index2/size </span><br><span class="line">256K</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3级缓存大小</span></span><br><span class="line">[root@test nginx]# cat /sys/devices/system/cpu/cpu0/cache/index3/size </span><br><span class="line">6144K</span><br></pre></td></tr></table></figure>

<p>我们知道 3 级缓存是一个<code>CPU</code>插槽上所有核心共享的，可以看下哪几个核心在一个插槽上：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test nginx]# cat /sys/devices/system/cpu/cpu0/cache/index3/shared_cpu_list </span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>可以看到在我们的机器上，<code>CPU0</code>在一个插槽上</strong></p>
</blockquote>
<p><strong>【 <code>worker</code> 进程间的负载均衡】</strong></p>
<p>​    如何让多个<code>worker</code>进程间的响应处理达到比较合理的均衡值，<code>Nginx</code>引入了<code>accept_mutex</code>参数，如果启用该参数表示多个<code>worker</code>进程间顺序接收新连接，关闭的话则会所有<code>worker</code>进程会同时被唤醒，但是只有一个<code>worker</code>进程能接收处理该连接。在<code>Nginx 1.11.3</code>版本以前，该参数默认是启用的，但是这种处理方式在处理并发连接较多时性能特别差，下面是三种机制的性能测试对比：</p>
<p><a target="_blank" rel="noopener" href="https://www.nginx.com/blog/socket-sharding-nginx-release-1-9-1/">数据出处</a></p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210127135307582.png" alt="image-20210127135307582" style="zoom:50%;" />

<p>这里还有一组实验数据：</p>
<table>
<thead>
<tr>
<th></th>
<th><code>Latency (ms)</code></th>
<th><code>Latency stdev (ms)</code></th>
<th><code>CPU Load</code></th>
</tr>
</thead>
<tbody><tr>
<td><code>Default</code></td>
<td>15.65</td>
<td>26.59</td>
<td>0.3</td>
</tr>
<tr>
<td><code>accept_mutex off</code></td>
<td>15.59</td>
<td>26.48</td>
<td>10</td>
</tr>
<tr>
<td><code>reuseport</code></td>
<td>12.35</td>
<td>3.15</td>
<td>0.3</td>
</tr>
</tbody></table>
<p>可以看下未启用<code>reuseport</code>和启用<code>reuseport</code>时，<code>worker</code>处理进程的差异方式：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210127151920177.png"></p>
<p>​                   <strong>未启用<code>reuseport</code></strong>                                                 <strong>启用<code>reuseport</code></strong></p>
<p>需要注意的是<code>reuseport</code>需要<code>Linux</code>内核支持，即必须<code>Linux 3.9+</code>以上才可以使用，这种方式从内核层实现了<code>worker</code>进程间的赋值均衡调度，效果非常好。启用语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">listen</span> address[:port] [reuseport]</span><br></pre></td></tr></table></figure>

<p>需要注意的是，在使用<code>reuseport</code>时，请设置<code>accept_mutex off;</code></p>
<blockquote>
<p><strong>There is no need to enable accept_mutex on systems that support the EPOLLEXCLUSIVE flag (1.11.3) or when using reuseport</strong></p>
</blockquote>
<p><strong>【单个 <code>worker</code> 进程允许同时打开的连接数】</strong></p>
<p>​    我们可以通过配置<code>worker_connections</code>；修改单个<code>worker</code>进程可以同时打开的连接数，默认是 <code>512</code>，需要调大该值，但是不能超过<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_rlimit_nofile">worker_rlimit_nofile</a>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">worker_connections</span> number;</span><br><span class="line">Default: <span class="attribute">worker_connections</span> <span class="number">512</span>;</span><br><span class="line">Context: events</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Set the maximum number of simultaneous connections that can be opened by a worker process.</strong></p>
</blockquote>
<p><strong>【所有 <code>worker</code> 进程允许同时打开的文件数】</strong></p>
<p>​    一般<code>worker_rlimit_nofile</code>表示所有<code>worker</code>进程可以打开的文件句柄数，该值默认值未设置，将会受到系统级、用户级限制（注意：<code>Nginx worker</code>进程的默认用户是<code>nginx</code>）。</p>
<blockquote>
<p><strong>maximum number of open files (RLIMIT_NOFILE) for worker processes.</strong></p>
</blockquote>
<p>配置语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">worker_rlimit_nofile</span> number;</span><br><span class="line">Default: -</span><br><span class="line">Context: main</span><br></pre></td></tr></table></figure>

<p><strong>【使用 <code>epoll</code> 事件模型】</strong></p>
<p>​    对于这个参数我们不用过多赘述了，在<code>REHL/CentOS</code>系统中<code>Nginx</code>编译后默认就是使用的<code>epoll</code>模型，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">use</span> method;</span><br><span class="line">Default: -</span><br><span class="line">Context: events</span><br></pre></td></tr></table></figure>

<h4 id="5-2-HTTP-配置段优化"><a href="#5-2-HTTP-配置段优化" class="headerlink" title="5.2 HTTP 配置段优化"></a>5.2 <code>HTTP</code> 配置段优化</h4><p>​    我们这里简单介绍一些关于<code>http</code>配置段的一些比较通用的优化参数，另外还有一些会结合具体业务在后面配置应用课程中再做介绍。</p>
<p>​    同样的，在<code>HTTP</code>配置段中的**”优化”<strong>我们也从</strong>“文件IO”<strong>与</strong>“网络IO”<strong>以及</strong>“网络连接”*<em>等三个核心层面进行介绍，不过说到底其实这三者之间也是紧密联系的，比如</em>我们可以通过将文件压缩以实现更快的网络发送与接收。*</p>
<h5 id="5-2-1-文件-IO-优化方向"><a href="#5-2-1-文件-IO-优化方向" class="headerlink" title="5.2.1 文件 IO 优化方向"></a>5.2.1 文件 <code>IO</code> 优化方向</h5><ul>
<li>优化读取速度</li>
<li>减少磁盘写入</li>
</ul>
<p><strong>【优化读取速度之 <code>sendfile</code>】</strong></p>
<p>​    当然，升级高效的 <strong><code>SSD</code></strong> 固态硬盘效果最明显，这是属于硬件层面升级，我们来看下应用层面该如何优化。相信很多接触过 <code>Nginx</code> 的都会听说过这么一个参数 **<code>sendfile</code>**，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">sendfile</span> <span class="literal">on</span> | <span class="literal">off</span></span><br><span class="line">Default: sendfile <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span>, if in localtion</span><br></pre></td></tr></table></figure>

<p>​    需要注意的是这个参数其实并不是适用于任何场景，我们来解析下这个参数。在正式介绍 <code>sendfile</code> 这个参数时，我们首先介绍下<code>CPU</code>是如何处理磁盘或者网卡中断以及关于 <code>DMA</code> 的相关知识。</p>
<p><strong>关于DMA小知识</strong>：</p>
<blockquote>
<p>​    <strong><code>DMA</code>的全称叫<em>直接内存存取</em>（<code>Direct Memory Access</code>），是一种允许外围设备（硬件子系统）直接访问系统主内存的机制。也就是说，基于 <code>DMA</code> 访问方式，<em>系统主内存于硬盘或者网卡之间的数据传输可以绕开</em> <code>CPU</code> 的全程调度。目前大多数的硬件设备，包括磁盘控制器、网卡、显卡、以及声卡等都支持 <code>DMA</code> 技术</strong> </p>
<p>​    <strong>整个数据传输操作在一个 <code>DMA</code> 控制器的控制下进行的。 <code>CPU</code> 除了在数据传输开始和结束时做一点处理外（开始和结束时候要做中断处理），在传输过程中 <code>CPU</code> 可以继续进行其他的工作。这样在大部分时间里，<code>CPU</code> 计算和 <code>I/O</code> 操作都处于并行操作，使整个计算机系统的效率大大提高。</strong> </p>
</blockquote>
<p>下面即为硬件设备 <strong>不支持/支持 DMA</strong> 时的 <strong>CPU</strong> 的工作流程：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210204205210340.png" alt="image-20210127151522383"></p>
<p>基于 <code>DMA</code> 访问方式，<em>系统主内存于硬盘或者网卡之间的数据传输可以绕开</em> <code>CPU</code> 的全程调度。</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210127151522383.png" alt="image-20210127151920177"></p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210127170854937.png" alt="image-20210204205210340"></p>
<p>这个步骤流程如下：</p>
<ul>
<li>用户进程向内核发起一次 <code>read()</code> 调用，上下文从用户态切换为内核态。（第一次上下文切换）</li>
<li><code>CPU</code> 通知 <code>DMA</code> 控制器从外部存储设备拷贝数据到内核缓冲区。（<code>DMA Copy</code>）</li>
<li><code>CPU</code> 将内核缓冲区的数据拷贝到用户缓冲区，上下文从内核态切换到用户态（<code>CPU Copy</code>，第二次上下文切换）</li>
<li>用户进程向内核发起一次 <code>write()</code> 调用，上下文从用户态切换到内核态。（第三次上下文切换）</li>
<li><code>CPU</code> 从用户缓冲区拷贝数据到内核空间的 <code>Socket</code> 缓冲区。（<code>CPU Copy</code>）</li>
<li><code>CPU</code> 通知 <code>MDA</code> 控制器将 <code>Socket</code> 缓冲区的数据拷贝到网卡进行传输，上下文从内核态切换为用户态并返回。（<code>DMA Copy</code>，第四次上下文切换）</li>
</ul>
<p><strong>传统的I/O方式在进行一次读写的时候共涉及了4次上下文切换，2次DMA拷贝以及2次CPU拷贝。</strong></p>
<p>为了减少这种频繁的上下文切换以及数据拷贝，<code>Linux kernel-2.1</code> 引入了多种实现方案，我们这里主要介绍与 <code>Nginx</code> 相关的，其中一种方案就是 <code>sendfile</code>技术，原理如下：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210127160835515.png" alt="image-20210127160835515"></p>
<p><strong>用户程序通过 <code>sendfile</code> 系统调用，数据可以直接在内核空间内部进行 <code>I/O</code> 传输，从而省去了数据在用户空间和内核空间之间的来回拷贝。</strong> </p>
<p><strong>基于 <code>sendfile  </code>系统调用的零拷贝方式，整个过程会发送 2 次上下文切换， 1 次CPU拷贝和 2 次DMA拷贝</strong> </p>
<p><code>sendfile</code> 系统调用方式下，用户程序读写数据的流程如下：</p>
<ul>
<li>用户进程通过 <code>sendfile()</code> 函数向内核（<code>kernel</code>）发起系统调用，上下文从用户态（<code>user space</code>）切换为内核态（<code>kernel space</code>）。</li>
<li><code>CPU</code> 利用 <code>DMA</code> 控制器将数据从主存或硬盘拷贝到内核空间（<code>kernel space</code>）的读缓冲区（<code>read buffer</code>）。</li>
<li><code>CPU</code> 将读缓冲区（<code>read buffer</code>）中的数据拷贝到的网络缓冲区（<code>socket buffer</code>）。</li>
<li><code>CPU</code> 利用 <code>DMA</code> 控制器将数据从网络缓冲区（<code>socket buffer</code>）拷贝到网卡进行数据传输。</li>
<li>上下文内核态（<code>kernel space</code>）切换回用户态（<code>user space</code>），<code>sendfile</code> 系统调用执行返回。</li>
</ul>
<p>相比较于传统 <code>I/O</code> 来说，<code>sendfile</code> 减少了上下文切换和数据拷贝次数，但是 <code>sendfile</code> 存在的问题是用户程序不能对数据进行修改（比如 <code>Nginx</code> 通过对文件进行压缩以实现网络高速传输就不能使用 <code>sendfile</code>），而只是单纯地完了一次数据传输过程。</p>
<blockquote>
<p><strong><code>Nginx</code> 中打开 <code>sendfile</code> 配置选项即可享受 <code>sendfile</code> 系统调用所带来的的优化，但仍需注意该优化仅针对<font color=red>静态资源</font>处理有效，对<font color=green>反向代理</font>并不起作用，这是因为 <code>sendfile</code> 中数据源句柄只能是文件句柄，而反向代理的双端都是 <code>socket</code> 句柄，导致不能使用 <code>sendfile</code>。</strong></p>
<p><strong>由于 <code>sendfile</code> 系统调用导致数据不经过 <code>user space</code> ，因此与 <code>nginx</code> 中 <code>output-filter</code> 存在冲突，比如在同一个上下文中同时打开 <code>gzip</code> 与 <code>sendfile</code> 会导致 <code>sendfile</code> 失效。</strong></p>
</blockquote>
<p>另外，在 <code>sendfile</code> 实现方案中，如果硬件支持 <code>DMA Gather</code> 操作（<code>Linux 2.4</code> 版本的内核对 <code>sendfile</code> 系统调用进行修改，为 <code>DMA</code> 拷贝引入了 <code>gather</code> 操作），<code>sendfile</code> 拷贝方式不再从内核缓冲区的数据拷贝到 <code>socket</code> 缓冲区，取而代之的仅仅是<strong>缓冲区文件描述符和数据长度</strong>的拷贝，这个 <code>DMA</code> 引擎直接利用 <code>gether</code> 操作将页缓存中数据打包发送到网络中即可。</p>
<blockquote>
<p><code>DMA gether</code> 将内核空间（<code>kernel space</code>）的读缓冲区（<code>read buffer</code>）中对应的数据描述信息（内存地址、地址偏移量）记录到相应的网络缓冲区（<code>socket buffer</code>）中，由 <code>DMA</code> 根据内存地址、地址偏移量将数据批量地从读缓冲区（<code>read buffer</code>）拷贝到网卡设备中，这样就省去了内核空间中仅剩 1 次 <code>CPU</code> 拷贝操作，如下图：</p>
</blockquote>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210127132142578.png" alt="image-20210127170854937"></p>
<p>基于 <code>sendfile + DMA gather copy</code> 系统调用的零拷贝方式，整个拷贝过程会发生 2 次上下文切换、 0 次CPU拷贝以及 2 次DMA拷贝。</p>
<p>用户程序读写数据的流程如下：</p>
<ul>
<li>用户进程通过 <code>sendfile()</code> 函数向内核（<code>kernel</code>）发起系统调用，上下文从用户态（<code>user space</code>）切换为内核态（<code>kernel sapce</code>）。</li>
<li><code>CPU</code> 领用 <code>DMA</code> 控制器将数据从主存或硬盘拷贝到内核空间（<code>kernel space</code>）的读缓冲区（<code>read buffer</code>）。</li>
<li><code>CPU</code> 把读缓冲区（<code>read buffer</code>）的文件描述符（<code>file descriptor</code>）和数据长度拷贝到网络缓冲区（<code>socket space</code>）。</li>
<li>易于已拷贝的文件描述符（<code>file descriptor</code>）和数据长度，<code>CPU</code>利用<code>DMA</code>控制器的<code>gether/scatter</code>操作直接批量地数据从内核的读缓冲区（<code>read buffer</code>）拷贝到网卡进行数据传输。</li>
<li>上下文从内核态（<code>kernel space</code>）切换回用户态（<code>user space</code>），<code>sendfile()</code>系统调用执行返回。</li>
</ul>
<p><code>sendfile + DMA gether copy</code>拷贝方式同样存在用户程序不能对数据进行修改的问题，而且本身需要硬件的支持。</p>
<p><strong>【优化读写速度之direct I/O】</strong></p>
<p>我们知道一般数据<strong>I/O</strong>时，一定会经过内核缓冲区、应用缓冲区，这是因为缓冲区的速度往往较<strong>I/O</strong>设备高很多，可以极大程度提升数据的读写效率。但是有些场景、也有些应用不适应使用。在<code>Nginx</code>中也是支持<code>Direct I/O</code>模式，相关的参数为<code>directio</code>，<strong>应用的常见主要是读取大文件时</strong>。基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Synctax: <span class="attribute">directio</span> size | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">directio</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br><span class="line">This directive appeared in version <span class="number">0</span>.<span class="number">7</span>.<span class="number">7</span>.</span><br></pre></td></tr></table></figure>

<p><strong>凡是通过直接I/O方式进行数据传输，数据均直接在用户空间的缓冲区和磁盘之间直接进行传输，完全不需要页缓存的支持。</strong>操作系统层提供的缓存往往会使应用程序在读写数据的时候获得更好的性能，但是对于某些特殊的应用程序，比如说数据库管理系统这类应用，他们更倾向于选择他们自己的缓存机制，因为数据库管理系统往往比操作系统更了解数据库中存放的数据，数据库管理系统可以提供一种更加有效的缓存机制来提高数据库中数据的存取性能。</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210128140730923.png" alt="image-20210128140730923"></p>
<p>下图是 <strong>标准访问文件方式</strong> 和 <strong>Direct I/O的访问方式</strong> 流程图对比：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210128141542256.png" alt="image-20210128141542256"></p>
<p>标准访问文件方式 <code>Direct I/O</code> 的访问方式</p>
<blockquote>
<p><code>Linux 2.6</code>内核中直接 <code>I/O</code>的设计与实现</p>
<p>在块设备或者网络设备中执行直接 <code>I/O</code>完全不用担心实现直接 <code>I/O</code>的问题，<code>Linux 2.6</code>操作系统内核中高层代码以及设置和使用了直接IO，驱动程序级别的代码甚至不需要知道已经执行了直接IO；但是对于字符设备来说，执行直接IO是不可行的，<code>Linux 2.6</code>提供了函数<code>get_user_pages()</code>用于实现直接IO；</p>
</blockquote>
<p><code>Direct I/O</code>的特点就是 <strong>数据传输不经过操作系统内核缓冲区</strong> </p>
<p>​    用户态<code>Direct I/O</code>使得应用程序或者运行在用户态（<code>user space</code>）下的库函数直接访问硬件设备，数据直接跨过内核进行传输，内核在数据传输过程除了进行必要的虚拟存储配置工作之外，不参与任何其他工作，这种方式能够直接绕过内核，极大提高了性能。<strong>用户态<code>Direct I/O</code>只能适用于不需要内核缓冲区处理的应用程序，这些应用程序通常在进程地址空间有自己的数据缓存机制，称为自缓存应用程序，如数据库管理系统就是一个代表。</strong>其次，这种零拷贝机制会直接操作磁盘 <code>I/O</code> ，由于<code>CPU</code>和磁盘<code>I/O</code>之间的执行时间差距，会造成大量资源的浪费，解决方案是配合异步<code>I/O</code>使用。</p>
<p><strong>【优化读写速度之 异步I/O】</strong> </p>
<p>​    <code>Linux</code>异步<code>I/O</code>是<code>Linux 2.6.22</code>中的一个标准特性，<code>CPU</code>处理其他任务和<code>I/O</code>操作可以重叠执行，在<code>Nginx</code>中启用异步<code>I/O</code>的参数为<strong>aio</strong>。基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">aio</span> <span class="literal">on</span> | <span class="literal">off</span> | threads[=<span class="literal">poll</span>]</span><br><span class="line">Default: aio <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br><span class="line">This directive appeared in version <span class="number">0</span>.<span class="number">8</span>.<span class="number">11</span>.</span><br></pre></td></tr></table></figure>

<p>​    其本质思想即是 进程发出数据传输请求之后，进程不被阻塞，也不用等待任何操作完成，进程可以在数据传输的时候继续执行其他的操作。相对于同步访问文件的方式来说，异步访问文件的方式可以提高应用程序的效率，并且提高系统资源利用率。直接<code>I/O</code>进程会和异步访问文件的方式结合在一起使用。</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210208150120409.png" alt="image-20210128143550175"></p>
<p><strong>标准访问文件方式 异步 <code>I/O</code> 的访问方式</strong> </p>
<p><strong>小结：</strong></p>
<p><strong>在 <code>Nginx</code> 中我们会把 <code>directio</code> 与异步 <code>I/O</code> 即 <code>aio</code>一起使用，以免造成数据读取阻塞。</strong></p>
<p><strong>在 <code>Nginx</code> 中我们同样会将 <code>sendfile</code>与 异步<code>I/O</code> 一起使用，<code>aio</code> 会为 <code>sendfile</code>提前预加载数据。</strong> </p>
<p><strong>在 <code>Nginx</code> 中在使用 <code>directio</code> 时会自动禁用 <code>sendfile</code>。</strong> </p>
<p>使用示例：</p>
<blockquote>
<p><strong><code>Nginx</code> 中打开 <code>sendfile</code> 配置选项即可享受 <code>sendfile</code> 系统调用所带来的的优化，但仍需注意该优化仅针对<font color=red>静态资源</font>处理有效，对<font color=green>反向代理</font>并不起作用，这是因为 <code>sendfile</code> 中数据源句柄只能是文件句柄，而反向代理的双端都是 <code>socket</code> 句柄，导致不能使用 <code>sendfile</code>。</strong></p>
<p><strong>由于 <code>sendfile</code> 系统调用导致数据不经过 <code>user space</code> ，因此与 <code>nginx</code> 中 <code>output-filter</code> 存在冲突，比如在同一个上下文中同时打开 <code>gzip</code> 与 <code>sendfile</code> 会导致 <code>sendfile</code> 失效。</strong></p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /video/ &#123;</span><br><span class="line">	<span class="attribute">sendfile</span> <span class="literal">on</span>; <span class="comment">#sendfile 减少了上下文切换和数据拷贝次数。sendfile 存在的问题是用户程序不能对数据进行修改（比如 Nginx 通过对文件进行压缩（gzip）以实现网络高速传输就不能使用 sendfile），而只是单纯地完了一次数据传输过程。</span></span><br><span class="line">	<span class="attribute">aio</span>	<span class="literal">on</span>;      <span class="comment">#进程发出数据传输请求之后，进程不被阻塞，也不用等待任何操作完成，进程可以在数据传输的时候继续执行其他的操作。相对于同步访问文件的方式来说，异步访问文件的方式可以提高应用程序的效率，并且提高系统资源利用率。直接I/O进程会和异步访问文件的方式结合在一起使用。</span></span><br><span class="line">	<span class="attribute">directio</span> <span class="number">8m</span>; <span class="comment">#应用的常见主要是读取大文件。Direct I/O的特点就是 数据传输不经过操作系统内核缓冲区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示当文件大小超过<code>8M</code>时，启动<code>AIO</code>与<code>Direct I/O</code>，此时的<code>sendfile</code>会自动禁用；当文件小于<code>8M</code>时，<code>AIO</code>与<code>sendfile</code>一起使用，此时<code>Direct I/O</code>不生效。</p>
<p>关于 <code>Linux</code> 直接 <code>I/O</code> 相关内容介绍，可以参考<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-directio/index.html">文档</a>，以及 <code>Linux</code> 零拷贝技术 <a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-cn-zerocopy2/index.html">相关文档</a></p>
<p><strong>【静态内容缓存优化】</strong></p>
<p>在 <code>Nginx</code> 中我们可以使用 <code>open_file_cache</code> 进一步提高性能，<code>Nginx</code> 缓存将最近使用的文件描述符和相关元数据（如修改时间，大小等）、目录结构信息等存储在缓存中。需要注意的是缓存不会存储所请求文件的内容。<strong>存储的是文件描述符和相关元数据，与数据内容无关</strong>。</p>
<blockquote>
<p>可以缓存的信息有：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">open file descriptors, ther sizes and modification times;</span><br><span class="line">information on existence of directories;</span><br><span class="line">file lookup errors, such as &quot;file not found&quot;, &quot;no read permission&quot;, and so on</span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果要设置文件缓存，需要设置该参数 <code>open_file_cache</code>，基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">open_file_cache</span> <span class="literal">off</span>;</span><br><span class="line">		<span class="attribute">open_file_cache</span> max=N [incative=time]</span><br><span class="line">Default: open_file_cache <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>该参数默认没有启用，如果要启用的话可以设置<code>open_file_caceh max=N [inactive=time]</code>，其中：</p>
<p><code>max</code>：用来设置缓存项的上限，当达到上限后将采用<code>LRU</code>算法进行管理；</p>
<p><code>inactive</code>：缓存项的非活动时长（闲置时长），在指定的时长内未被命中的即为非活动项，将被删除；另外，下面还有一个参数<strong>open_file_cache_min_uses</strong>与该处的非活动时长有关，该参数表示在设置的非活动时长内，命中的次数少于<code>open_file_cache_min_uses</code>指定的次数，也会被删除；</p>
<p><strong>open_file_cache_min_uses</strong>：默认值为1，基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">open_file_cache_min_uses</span> number</span><br><span class="line">Default: open_file_cache_min_uses <span class="number">1</span>;</span><br><span class="line">Context: http, server, localtion</span><br></pre></td></tr></table></figure>

<p>我们知道缓存的内容可以是查找文件时的一些错误信息，但是这需要我们手动设置，该参数为：</p>
<p><strong>open_file_cache_errors</strong>，基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">open_file_cache_errors</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">open_file_cache_errors</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server. <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>另外，<strong>open_file_cache_valid</strong> 用来指定缓存有效性的检查频率，默认为<code>60s</code>，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">open_file_cache_valid</span> time;</span><br><span class="line">Default: <span class="attribute">open_file_cache_valid</span> <span class="number">60s</span></span><br><span class="line">Context: http, server, location</span><br></pre></td></tr></table></figure>

<p>综上，结合上面的参数内容结束，生产上我们可以这样配置：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">open_file_cache 设置文件缓存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">max=10240 用来设置缓存项的上限，当达到上限后将采用LRU算法进行管理；</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">incative=20s; 缓存项的非活动时长，在指定的时长内未被命中的即为非活动项，将被删除</span></span><br><span class="line">open_file_cache			max=10240 incative=20s;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">用来指定缓存有效性的检查频率，默认为60s</span></span><br><span class="line">open_file_cache_valid	30s;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">与非活动时长有关，该参数表示在设置的非活动时长内，命中的次数少于open_file_cache_min_uses指定的次数，也会被删除</span></span><br><span class="line">open_file_cache_min_uses 2;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">缓存的内容可以是查找文件时的一些错误信息，但是这需要我们手动设置</span></span><br><span class="line">open_file_cache_errors on;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要根据自己的实际业务做适当调整</p>
</blockquote>
<hr>
<p><strong>【客户端请求缓存优化】</strong></p>
<p>还有一些参数，是客户端对服务端发起的请求时，服务端同样会把请求的头部以及<code>body</code>信息先放到缓存区中，相关的一些配置参数有：</p>
<p><strong>client_header_buffer_size</strong>：设置客户端请求报文首部缓冲区大小，默认值为<code>1K</code>。有时客户端请求首部带有<code>cookie</code>很大的信息，会造成<code>400</code>错误，强烈建议增大大小。配置语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">client_header_buffer_size</span> size;</span><br><span class="line">Default: <span class="attribute">client_header_buffer_size</span> <span class="number">1k</span>;</span><br><span class="line">Context: http, server</span><br></pre></td></tr></table></figure>

<p>我们一般将该缓冲区大小设置为系统分页大小，可以使用 <code>getconf PAGESIZE</code> 来进行查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">getconf PAGESIZE</span></span><br><span class="line">4096</span><br></pre></td></tr></table></figure>

<p>所以我们可以这样设置 <code>client_header_buffer_size 4k;</code></p>
<p>需要注意的是，如果我们设置的 <code>client_header_buffer_size</code> 大小不够用户存储客户端请求头，那么会使用：</p>
<p>**<code>large_client_header_buffers</code>**：该参数在 <code>client_header_buffer_size</code> 不足时使用，动态按需分配。默认配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">large_client_header_buffers</span> number size;</span><br><span class="line">Default: <span class="attribute">large_client_header_buffers</span> <span class="number">4</span> <span class="number">8k</span>;</span><br><span class="line">Context: http,server</span><br></pre></td></tr></table></figure>

<p>一般使用默认配置即可。</p>
<p><code>client_body_buffer_size</code>：用来缓存用户请求体的大小，在<code>32bit</code>系统上默认大小为<code>8k</code>，在<code>64bit</code>系统上，默认大小为<code>16k</code>，一般我们使用默认值即可；</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	<span class="attribute">client_body_buffer_size</span> size;</span><br><span class="line">Default: <span class="attribute">client_body_buffer_size</span> <span class="number">8k</span>|<span class="number">16K</span></span><br><span class="line">Context: http,server,location</span><br></pre></td></tr></table></figure>

<p>当用户请求体<code>body</code>太大 时，则将其暂存在磁盘上由<code>client_body_temp_path</code>指定的位置，所以为了更好的性能，我们建议使用高性能磁盘来作为存储位置。</p>
<p><code>client_body_temp_path</code>：基本用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">client_body_temp_path</span> path [level1 [level2 [level3 ]]];</span><br><span class="line">Default: <span class="attribute">client_body_temp_path</span> client_body_temp;</span><br><span class="line">Context: http,server,<span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>用来指定存储路径和目录结构，注意目录结构最多为三级结构，每级结构最多支持两位 <code>16进制</code> 数量的目录，<code>1</code> 表示一个 <code>16进制</code>，<code>2</code> 表示两个 <code>16进制</code>，比如可以这样设定 <code>1</code>、<code>1 2</code> 或 <code>1 2 2</code>，其中 <code>1 2 2</code> 表示的含义如下：</p>
<p><strong>1</strong>：<code>1</code> 级目录占 <code>1</code> 位 <code>16</code> 进制，可以创建 <code>16^1</code> 即 <code>16</code> 个目录，目录名称为<code>0~f</code>；</p>
<p><strong>2</strong>：<code>2</code> 级目录占 <code>2</code> 位 <code>16</code> 进制，可以创建 <code>16^2</code> 即 <code>256</code> 个目录，目录名称为<code>00~ff</code>；</p>
<p><strong>2</strong>：<code>3</code> 级目录占 <code>2</code> 位 <code>16</code> 进制，可以创建 <code>16^1</code> 即 <code>16</code> 个目录，目录名称为<code>00~ff</code>；</p>
<p>假设我们设置为<code>1 2</code>两层目录结构，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">client_body_temp_path</span> /spool/nginx/client_temp <span class="number">1</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>那么存储的文件路径可能是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/spool/nginx/client_temp/7/45/00000123457</span><br></pre></td></tr></table></figure>

<p>注意看该文件 <code>hash</code> 值的后面 <strong>3</strong> 位。如果我们设置为 <code>3</code> 级结构，那么该文件存储的位置一定是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/spool/nginx/client_temp/7/45/23/00000123457</span><br></pre></td></tr></table></figure>

<p><strong><code>client_max_body_size</code><strong>：用来设置客户端请求体大小，该大小可以从<code>Content-Length</code> 看到，默认大小是 <code>1m</code>，基本上能够满足常见的请求体，如果请求体超过该参数，则会报 <code>413 (Request Entity Too Large)</code> 错误。如果 <code>Nginx</code> 作为上传文件服务器，那么这个值可能就不够了。需要注意的是：</strong>上传会受限与该参数，但是文件下载跟这个参数没有关系</strong>。</p>
<hr>
<h5 id="5-2-2-网络-IO-优化方向"><a href="#5-2-2-网络-IO-优化方向" class="headerlink" title="5.2.2 网络 IO 优化方向"></a>5.2.2 网络 <code>IO</code> 优化方向</h5><p>如上所述，除了在文件层面进行优化外，我们还可以从网络层面来实现网络<code>IO</code>性能优化。</p>
<p><strong>【全连接队列长度】</strong></p>
<p>之前我们介绍了在 <code>Linux</code> 中，<code>Client端 </code>和 <code>Server端</code> 建立连接涉及到三个重要的队列，即：</p>
<p><code>net.core.netdev_max_backlog</code>：接收网卡，但未被内核协议栈处理的报文队列长度</p>
<p><code>net.ipv4.tcp_max_syn_backlog</code>：<code>SYN_RCVD</code> 状态（即半连接）队列长度</p>
<p><code>backlog</code>：全连接队列也就是我们图中标注的 <code>accept 队列</code>，该队列大小由系统参数和应用参数共同决定，即：<strong>全连接队列的大小取决于：<code>min(backlog,somaxconn)</code>，其中<code>backlog</code> 是由应用程序传入，<code>somaxconn</code>是一个OS级别的系统参数，通过设置<code>net.core.somaxconn</code>来调整。</strong>在<code>Nginx</code>中，<code>backlog</code>参数在<code>Listen</code>参数后面指定，在<code>CentOS</code>上，默认值为<code>511</code>，如果并发连接比较多，我们可以适当调大此队列长度，配置语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">listen</span> address[:port] [backlog=number]</span><br><span class="line">Default: listen *:<span class="number">80</span> | *:<span class="number">8000</span>;</span><br><span class="line">Context: server</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">127.0.0.1:80</span> backlog=<span class="number">4096</span></span><br></pre></td></tr></table></figure>

<p><strong>【tcp_nodelay】</strong></p>
<p>该配置参数其实是关于是否启用 <code>Nagle</code> 算法（延迟算法），所谓 <code>Nagle</code> 算法特性可以简单描述如下：</p>
<ul>
<li>避免同一个连接上同时存在大量小报文<ul>
<li>合并多个小报文一起发送</li>
<li>最多只存在一个小报文（即连接上的最后一个小报文，无其他报文与之合并）</li>
</ul>
</li>
<li>提供带宽利用率</li>
</ul>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210203174210386.png" alt="image-20210203174210386" style="zoom:50%;" />

<p>启用 <code>Nagle</code> 算法 <code>tcp_nodelay off</code> </p>
<p>禁用 <code>Nagle</code> 算法 <code>tcp_nodelay on</code></p>
<p>所以，是否启用该参数，决定与你的网站业务类型或者你期望侧重于网站的哪些特性，比如：</p>
<ul>
<li><strong>吞吐量优先</strong>：启用<code>Nagle</code>算法，设置<code>tcp_nodelay off</code>；</li>
<li><strong>低时延优先</strong>：禁用<code>Nagle</code>算法，设置<code>tcp_nodelay on</code>；</li>
</ul>
<p>在<code>Nginx</code>的配置模块<code>http</code>与<code>stream</code>配置段都有此参数，需要注意的是，在<code>http</code>配置段中，<code>tcp_nodelay</code>仅对<code>HTTP Keep-Alive</code>连接有效。</p>
<blockquote>
<p>Enables or disables the use of the <code>TCP_NODELAY</code> option. The option is enabled when a connection is transitioned into the keep-alive state.</p>
</blockquote>
<p><code>http</code>模块中<code>tcp_nodelay</code>配置语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">tcp_nodelay</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">tcp_nodelay</span> <span class="literal">on</span>;</span><br><span class="line">Context: http,server,<span class="section">location</span></span><br></pre></td></tr></table></figure>

<p><code>stream</code>模块中<code>tcp_nodelay</code>配置语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">tcp_nodelay</span> <span class="literal">on</span> | <span class="literal">off</span></span><br><span class="line">Default: tcp_nodelay <span class="literal">on</span>;</span><br><span class="line">Context: stream,<span class="attribute">server</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">9</span>.<span class="number">4</span>.</span><br></pre></td></tr></table></figure>

<p>另外，在<code>Nginx</code>的<code>http</code>配置段，我们也可以通过设置**<code>postpone_output</code>**的大小来避免发送小报文。在<code>Nginx</code>中该参数默认是启用的，设置的报文发送阈值为<code>1460</code>字节，这个参数和<code>Nagle</code>类似，也允许带有<code>FIN</code>标志位的小报文发送。配置语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">postpone_output</span> size;</span><br><span class="line">Default: <span class="attribute">postpone_output</span> <span class="number">1460</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>【tcp_nopush】</strong></p>
<p>该配置参数是用来设置是否用 <code>CORK</code> 算法，<code>CORK</code> 就是”<strong>塞子</strong>“的意思，形象的理解就是用 <code>CORK</code> 将连接塞住，使得数据先不发出去。启用该算法后，内核会尽力把小数据包拼接成一个大的数据包（一个<code>MTU</code>）再发送出去，当然若一定时间后（一般为<code>200ms</code>，该值尚待确认），内核仍然没有组合一个 <code>MTU</code> 时也必须发送现有的数据。</p>
<p>然而，<code>TCP_CORK</code> 的实现可能并不像你想象的那么完美，<code>CORK</code> 并不会将连接完全塞住。内核其实并不知道应用层到底什么时候会发送第二批数据用于和第一批数据拼接以达到 <code>MTU</code> 的大小，因此内核会给出一个时间限制，在该时间内没有拼接成一个大包（努力接近 <code>MTU</code>）的话，内核就会无条件发送。也就是说应用程序发送小包数据的间隔不够短时，<code>TCP_CORK</code> 就没有一点作用，反而失去了数据的实时性（每个小包数据都会延时一定时间再发送）。</p>
<p><code>CORK</code>算法可以理解成一种加强的<code>Nagle</code>算法，都是累计数据然后发送。但它没有<code>Nagle</code>中一个小报文的限制，它是可以实现完全禁止所有小报文的发送。</p>
<p>在<code>Nginx</code>中我们可以通过设置<code>tcp_nopush</code>参数来决定是否启用<code>CORK</code>算法，配置语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">tcp_nopush</span> <span class="literal">on</span> | <span class="literal">off</span></span><br><span class="line">Default: tcp_nopush <span class="literal">off</span>;</span><br><span class="line">Context: http,server,<span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>tcp_nopush</code> 参数只有在 <code>sendfile on</code> 时才有效。</p>
<blockquote>
<p>The options are enabled only when <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html%23sendfile">sendfile</a> is used.</p>
</blockquote>
<hr>
<h5 id="5-2-3-网络连接层面优化"><a href="#5-2-3-网络连接层面优化" class="headerlink" title="5.2.3 网络连接层面优化"></a>5.2.3 网络连接层面优化</h5><p><strong>【HTTP 长连接】</strong></p>
<p>在 <code>http</code> 配置段中，默认是启用 <code>http</code> 长连接的，我们知道 <code>TCP</code> 在建立连接时需要进行三次握手，断开连接需要进行四次挥手，是非常消耗时间的。因此我们希望在 <code>http</code> 请求中可以重复使用建立的连接通道，这就是 <code>http</code> 长连接，这在连接请求比较多时是非常高效且能够有效降低网络拥塞的一种方案，配置方式如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">keepalive_timeout</span> timeout [header_timeout];</span><br><span class="line">Default: <span class="attribute">keepalive_timeout</span> <span class="number">75s</span>;</span><br><span class="line">Context: http,server,<span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>长连接超时时间默认为 <code>75s</code>，如果服务端比较繁忙，可以适当的调小此值，比如设置成 <code>60s</code> 或者 <code>30s</code> 。不过 <code>MSIE</code> 会在 <code>60s</code> 左右时主动端口长连接请求。</p>
<p>另外还有一个参数需要注意，就是在一个长连接上允许发送的请求个数，默认是 <code>100</code> 个，配置语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">keepalive_requests</span> number;</span><br><span class="line">Default: <span class="attribute">keepalive_requests</span> <span class="number">100</span>;</span><br><span class="line">Context: http,server,<span class="section">location</span></span><br><span class="line">This directive appeared in version <span class="number">0</span>.<span class="number">8</span>.<span class="number">0</span>.</span><br></pre></td></tr></table></figure>

<p><strong>【以RST代替四次挥手】</strong></p>
<p>我们知道正常的 <code>TCP</code> 连接端口需要经历四次报文的传递，这个过程还是比较耗时间的，不过为了安全的端口连接，这也是可以接受的。但是有些时候，可能由于客户端的一些错误导致连接关闭，这个时候如果再等待四次挥手就比较耗费时长，而且毫无意义。所以，在 <code>Nginx</code> 中有这样一个参数 <code>reset_timedout_connection</code> ，可以在连接断开的响应码为 <code>444</code> 时，直接以 <code>RST</code> 代替正常的四次挥手，快速释放内存。配置语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">reset_timedout_connection</span> <span class="literal">on</span> | <span class="literal">off</span></span><br><span class="line">Default: reset_timedout_connection <span class="literal">off</span>;</span><br><span class="line">Context: http,server,<span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>我们只需要设置 <code>reset_timedout_connection on;</code> 即可。</p>
<p><strong>【<code>TLS/SSL</code> 优化握手】</strong></p>
<p>我们现在绝大多数的 <code>Web</code> 应用都可以使用 <code>TLS/SSL</code> 进行加密，但是建立 <code>TLS/SSL</code> 连接的速度非常慢（比如密钥协商、密钥交换等），所以如果我们能为客户将加密会话缓存起来，这样就可以极大的提升 <code>TLS/SSL</code> 的请求连接速度了。</p>
<p><strong><code>Session</code> 复用，是指将握手时算出来的对称密钥存起来，后续请求中直接使用。在 <code>TLS/SSL</code> 会话建立时，最消耗资源的就是通过非对称加密加算出对称密钥来。</strong></p>
<p>在 <code>Nginx</code> 中，我们可以使用这参数 <code>ssl_session_cache</code> ，该参数的使用方式如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">ssl_session_cache</span> <span class="literal">off</span> | <span class="literal">none</span> | [builtin[:size]] [shared:name:size];</span><br><span class="line">Default: <span class="attribute">ssl_session_cache</span> <span class="literal">none</span>;</span><br><span class="line">Context: http, server</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>ssl_session_cache</code> 有四个可以使用的值，每个值的含义如下：</p>
<ul>
<li><p><code>off</code>：不使用 <code>session</code> 缓存，且 <code>Nginx</code> 在协议中明确告诉客户端不使用缓存；</p>
</li>
<li><p><code>none</code>：不使用 <code>session</code> 缓存，但是 <code>Nginx</code> 在协议中告诉客户端可能会使用缓存，但是自身根本不存储会话存储；</p>
</li>
<li><p><code>builtin</code>：使用 <code>openssl</code> 的缓存，由于在内存中使用，所以仅当同一个客户端在两次连接都命中到同一个 <code>worker</code> 进程时，<code>session</code> 缓存才会生效；</p>
</li>
<li><p><code>shared</code>：定义共享缓存，为所有的 <code>worker</code> 进程提供 <code>session</code> 缓存服务，官方文档上给出的统计值为 <code>1MB</code> 内存大概可以缓存 <code>4000 session</code> 会话；所以生产环境单节点中共享缓存的方案使用最多，一般设置大小 <code>10M - 20M</code> 足够使用了；比如，我们可以这样定义：</p>
</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_session_cache</span> shared:SSL:<span class="number">10M</span></span><br></pre></td></tr></table></figure>

<p>还有一个参数 <code>ssl_session_timeout</code> 用来设置<em><strong>会话复用</strong></em>的超时时间，注意，不是会话的超时时间，而是复用会话的超时时间，默认为 <code>5m</code> ；生产上可以根据业务不同可以适当的调整此值，比如一个供用户上传下载的网站：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_session_timeout</span> <span class="number">60m</span>;</span><br></pre></td></tr></table></figure>

<p>而一个简单的浏览性的网站，可以设置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">ssl_session_timeout</span> <span class="number">10m</span>;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，这种方式可以极大的提高 <code>TLS/SSL</code> 连接建立速度，但是只能使用与单个节点，如果是集群环境，则需要借助其他的技术手段。比如，我们可以引入 <code>redis</code> 来存储会话，<code>lua-nginx-redis</code> 可以让我们把 <code>session id </code> 的内容放到 <code>redis</code> 中，这样在整个 <code>Nginx</code> 集群之间就可以复用会话连接。还有一种方式，可以使用另外一个参数：<code>ssl_session_tickets</code>，使用语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">ssl_session_tickets</span> <span class="literal">on</span> | <span class="literal">off</span></span><br><span class="line">Default: ssl_session_tickets <span class="literal">on</span>;</span><br><span class="line">Context: http,<span class="attribute">server</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">5</span>.<span class="number">9</span>.</span><br></pre></td></tr></table></figure>

<p>启用 <code>ssl_session_tickets</code> 会让 <code>Nginx</code> 将会话 <code>session</code> 中的信息作为 <code>tickets</code> 加密发给客户端，当客户端下次发起 <code>TLS</code> 连接时带上 <code>tickets</code>，再由 <code>Nginx</code> 进行解密验证，通过后则恢复用该会话 <code>session</code> 会话票证一般会在 <code>Nginx</code> 集群中使用，但是破坏了 <code>TLS/SSL</code> 的安全机制，有安全风险，必须频繁更换 <code>tickets</code> 密钥。加密 <code>tickets</code> 的密钥文件配置参数如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">ssl_session_ticket_key</span> file;</span><br><span class="line">Default: -</span><br><span class="line">Context: http,<span class="attribute">server</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">5</span>.<span class="number">7</span>.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>file</code> 必须包含 80 或者 48 位的随机数据，我们可以使用这个命令创建：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand 80 &gt; ticket.key</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：<code>ssl_session_cache</code> 与 <code>ssl_session_tickets</code> 两种解决方案最好不要同时使用。</p>
<h5 id="5-2-4-模板层面优化"><a href="#5-2-4-模板层面优化" class="headerlink" title="5.2.4 模板层面优化"></a>5.2.4 模板层面优化</h5><p>除了上面提到的优化方案，我们还可以通过引入一些模块，让 <code>Nginx</code> 具有更好的性能，我们介绍几个比较常用的模块。</p>
<p><strong>【<code>ngx_http_gzip_module</code>】</strong></p>
<p>该模块在 <code>Nginx</code> 中默认已经被编译进去，可以直接使用，如果不想使用，也可以在编译的时候通过 <em><code>--without-http_gizp_module</code></em> 选项来禁止加载该模块。<code>ngx_http_gzip_module</code> 模块通过设置参数 <code>gzip on</code> 启用，用来实时压缩 <code>http</code> 包体，以提升网络传输效率。看下在 <code>Nginx</code> 该如何配置 <code>gzip</code> 以及相关参数，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">gzip</span> <span class="literal">off</span>;</span><br><span class="line">Context: http,server,<span class="section">location</span>, if in <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p><code>gzip_min_length</code> ：用来指定当报文长度达到多少字节时才启用压缩，默认是20字节，这个值我们一般需要调大，比如 <code>gzip_min_length 1024</code>；基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_min_length</span> length;</span><br><span class="line">Default: <span class="attribute">gzip_min_length</span> <span class="number">20</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p> <code>gzip_types</code> ：指定对何种响应报文进行压缩，默认为 <code>text/html</code>，不用显式指定，否则可能会报错，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_types</span> mime-type ···;</span><br><span class="line">Default: <span class="attribute">gzip_types</span> text/html;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>一般生产上，我们会调整压缩类型，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_types</span> text/plain text/css text/xml application/javascript</span><br><span class="line">application/json application/xml+rss</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意1：支持的压缩资源我们可以通过 <code>/etc/nginx/mime.types</code> （通过 <code>yum</code> 方式安装）查找。</p>
<p>注意2：我们不要去压缩图片、视频等静态资源，因为这些资源已经被压缩过了，再压缩一遍也不会变小，白白浪费 <code>CPU</code> 资源。</p>
</blockquote>
<p><code>gzip_comp_level</code>：指定压缩级别，可以支持 <code>1-9</code> 压缩级别，级别越高（数字越大）压缩程度越高，同时耗时越长，相应的消耗的 <code>CPU</code> 资源越高。基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_comp_level</span> level;</span><br><span class="line">Default: <span class="attribute">gzip_comp_level</span> <span class="number">1</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>一般我们不建议将压缩级别设置太高，会消耗 <code>CPU</code> 资源，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_comp_level</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p><code>gzip_disable</code>：设置对于哪些客户端不进行压缩，判断依据是根据字段 <code>User-Agent</code> 进行正则匹配，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_disable</span> regex ···;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br><span class="line">This directive appeared in version <span class="number">0</span>.<span class="number">6</span>.<span class="number">23</span>.</span><br></pre></td></tr></table></figure>

<p>比如：我们可以这样设置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">gzip_disable</span> <span class="string">&quot;MSIE[1-6]\.&quot;</span></span><br></pre></td></tr></table></figure>

<p>禁止对客户端为 <code>IE1-IE6</code> 进行报文压缩。</p>
<p><code>gzip_vary</code>：用来设置当浏览器启用 <code>gzip</code> 、<code>gzip_static</code>、<code>gunzip</code> 模块时。是否在响应报文中显示 <code>Vary: Accept-Encoding</code>；生产上如果不想显示，就设置 <code>gzip_vary off;</code> 即可，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_vary</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">gzip_vary</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>除此之外还有 <code>gzip_buffers</code> 用来设置压缩报文时的缓冲区数量和大小，一般大小设置为1个内存页大小，使用默认值即可：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_buffers</span> number size;</span><br><span class="line">Default: <span class="attribute">gzip_buffers</span> <span class="number">32</span> <span class="number">4k</span>|<span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p><code>gzip_http_version</code>：设置最小支持压缩的 <code>http</code> 协议版本号，默认为 <code>http 1.1</code>，基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">0</span> | <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">Default: <span class="attribute">gzip_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>这个值一般不用配置，使用默认即可，但是下面还有一个非常重要的参数，即：</p>
<p><code>gzip_proxied</code>：设置对上游服务器的响应进行压缩处理，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_proxied</span> <span class="literal">off</span> | expired | <span class="literal">no</span>-cache | <span class="literal">no</span>-store | private | no_last_modified | no_etag | auth | any ···;</span><br><span class="line">Default: <span class="attribute">gzip_proxied</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>可以使用的值如下：</p>
<ul>
<li><p><code>off</code>：不对上游服务器的响应进行压缩；</p>
</li>
<li><p><code>expired</code>：如果上游服务器响应中含有 <code>Expires</code> 字段，且其值中间的时间与系统时间对比确定不会，则压缩响应；</p>
</li>
<li><p><code>no-cache</code>、<code>no-store</code>、<code>private</code>：如果上游服务器响应报文含有 <code>Cache-Control</code> 首部，并且其值含有响应的 <code>no-cache</code> 、<code>no-store</code> 、<code>private</code> 值，则压缩响应；</p>
</li>
<li><p><code>no_last_modified</code>：如果上游服务器响应中没有 <code>Last-Modified</code> 头部，则压缩响应；</p>
</li>
<li><p><code>no_etag</code>：如果上游服务器响应中没有 <code>ETag</code> 头部，则压缩响应；</p>
</li>
<li><p><code>auth</code>：如果 <strong>客户端请求报文</strong> 中含有 <code>Authorization</code> 头部，则压缩响应；</p>
</li>
<li><p><code>any</code>：压缩所有来自上游的响应；</p>
</li>
</ul>
<p><strong>注意：一般情况下，如果上游服务器是我们自己配置的，最好在上游服务器配置中觉得是否进行压缩；如果是代理加速别人的上游节点，则最好不要压缩响应，因为有些客户端时不支持压缩的，我们在代理层压缩之后很可能导致客户端访问源站报错。</strong></p>
<p>虽然，我们使用 <code>ngx_http_gzip_module</code> 模块将数据压缩之后进行响应可以提高网络响应速度，但是由于对数据进行压缩导致我们调用 <code>sendfile</code> 方法不再生效，所以一个比较好的方式是先将文件进行压缩好，当客户端请求时直接用这个压缩好的文件进行响应。这里就需要使用另一个模块 <code>ngx_http_gzip_static_module</code> ，这个模块不是 <code>Nginx</code> 默认模块，但是在 <code>EPEL</code> 源中的版本已经帮我们把他编译进来了，如果是自己编译的话，只需要加上 <code>--with-http_gzip_static_module</code>即可。</p>
<p><strong>【ngx_http_gzip_static_module】</strong></p>
<p>通过参数 <code>gzip_static</code> 设置该模块，基础语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gzip_static</span> <span class="literal">on</span> | <span class="literal">off</span> | always;</span><br><span class="line">Default: <span class="attribute">gzip_static</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>可以使用的值有：</p>
<p><code>on</code> 或者 <code>off</code>：用来决定检查是否存在预压缩文件（以文件+ <code>.gz</code> 结尾，如果存在则发送），设置成 <code>on</code> 还会根据客户端是否支持 <code>gzip</code> 解压缩来确定是否发送压缩文件；</p>
<p><code>always</code>：无论客户端是否支持 <code>gzip</code> 解压缩，均会检查 <code>.gz</code> 文件是否存在，存在就发送。这种情况在磁盘上没有未压缩的文件时，结合 <code>ngx_http_gunzip_module</code> 模块一起使用。</p>
<blockquote>
<p>注意1：<code>always</code> 需要结合 <code>ngx_http_gunzip_module</code> 模块一起使用！</p>
<p>注意2：如果我们想要使用 <code>gzip_static</code> 模块，需要使用 <code>gzip</code> 提前压缩好相应的文件。</p>
<p>The files can be compressed using the <code>gzip</code> command, or any other compatible one. It is recommended that the modification date and time of original and compressed files be the same.</p>
</blockquote>
<p><strong>【ngx_http_gunzip_module】</strong></p>
<p>该模块需要我们自己编译，使用 <code>--with-http_gunzip_module</code> ，该模块的主要功能是当客户端不支持 <code>gzip</code> 解压时，并且磁盘上仅有压缩文件，则将文件实时解压并发送给客户端。该模块只有两个相关的配置参数：</p>
<p><code>gunzip</code> ：用来指定是否启用该模块，基础语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gunzip</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">gunzip</span> <span class="literal">off</span>;</span><br><span class="line">Context:  http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>还有一个配置 <code>gunzip</code> 使用的缓存区数量与大小，该参数与系统平台相关，即 <code>gunzip_buffers</code> 我们保持默认即可，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">gunzip_buffers</span> number size;</span><br><span class="line">Default: <span class="attribute">gunzip_buffers</span> <span class="number">32</span> <span class="number">4k</span> | <span class="number">16</span> <span class="number">8k</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>gunzip</code> 模块会在客户端不支持 <code>gzip</code> 压缩并且服务依然返回 <code>.gz</code> 文件时才会启用，这就要求我们在 <code>gzip_static</code> 必须设置为 <code>always</code> ，否则一旦检测到客户端不支持 <code>gzip</code> 压缩，则不会发送压缩文件（因为 <code>gzip_static</code> 处理阶段在 <code>gunzip</code> 之前），此时如果服务端仅有压缩文件，就会报 <code>404</code> 错误，需要特别注意！</p>
</blockquote>
<hr>
<p>另外还有些优化参数，我们需要集合应用场景以及自身业务去调整，等介绍到相关模块后再做细述，所以，综上所述，在 <code>Nginx</code> 的 <code>http</code> 模块配置段，上述内容即为比较通用的优化参数，我们可以在自己的网站中进行调整后应用。下面的课程我们将重点介绍 <code>Nginx</code> 的相关应用、配置等内容，其中也会涉及到一些相关的调优参数。</p>
<hr>
<h1 id="Nginx-从入门到企业实战（三）"><a href="#Nginx-从入门到企业实战（三）" class="headerlink" title="Nginx 从入门到企业实战（三）"></a><code>Nginx</code> 从入门到企业实战（三）</h1><h2 id="Nginx-模块介绍"><a href="#Nginx-模块介绍" class="headerlink" title="Nginx 模块介绍"></a><code>Nginx</code> 模块介绍</h2><p>我们知道 <code>Nginx</code> 可以作为 <code>web</code> 服务、<code>HTTP</code> 代理服务、<code>mail</code> 邮件服务以及 <code>TCP/UDP</code> 四层代理服务，其中最常见的就是作为 <code>web</code> 与 <code>http</code> 代理服务器，实现该功能的就是 <code>HTTP</code> 的相关模块，我们将对该模块中常见的配置及用法做详细的介绍。</p>
<h3 id="1-Nginx-核心模块"><a href="#1-Nginx-核心模块" class="headerlink" title="1. Nginx 核心模块"></a>1. <code>Nginx</code> 核心模块</h3><p>这个模块 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html"><code>Core functionality</code></a> 作为 <code>Nginx</code> 的全局配置模块，影响 <code>Nginx</code> 的所有功能，该模块中涉及到的配置参数我们在前面的调优课程中几乎都介绍过了，比如：</p>
<p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_processes"><code>use</code></a> 、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_processes"><code>worker_connections</code></a> 、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_processes"><code>worker_cpu_affinity</code></a> 、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_processes"><code>worker_priority</code></a> 、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_processes"><code>worker_processes</code> </a>、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_rlimit_nofile"><code>worker_rlimit_nofile</code></a> 、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23accept_mutex"><code>accept_mutex</code></a></p>
<p>其中还有几个参数与优化无关，仅和配置相关，比如：</p>
<h4 id="user"><a href="#user" class="headerlink" title="user"></a><code>user</code></h4><p>​    **<code>user</code>**：用来指定运行 <code>Nginx worker</code> 进程的用户名；</p>
<h4 id="daemon"><a href="#daemon" class="headerlink" title="daemon"></a><code>daemon</code></h4><p>​    **<code>daemon</code>**：用来指定是否让 <code>Nginx</code> 以 <code>daemon</code> 方式运行，即后台运行，默认为 <code>on</code> ，但是有时我们在调试的时候可以需要前台运行，以及在 <code>docker</code> 中，我们同样会让 <code>Nginx</code> 关闭后台运行，即 <code>daemon off;</code>；</p>
<h4 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a><code>error_log</code></h4><p>​    **<code>error_log</code>**：用来定义 <code>Nginx</code> 错误日志输出位置以及错误日志级别，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">error_log</span> file [level];</span><br><span class="line">Default: <span class="attribute">error_log</span> logs/<span class="literal">error</span>.log <span class="literal">error</span>;</span><br><span class="line">Context: http, mail, stream, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以支持的日志级别：<code>debug</code> ，<code>info</code> ，<code>notice</code> ，<code>warn</code> ，<code>error</code> ，<code>crit</code> ，<code>alert</code> ，or <code>emerg</code></p>
</blockquote>
<p>​    默认输出到本地的 <code>/var/log/nginx/error.log</code> ，我们也可以配置定义输出到 <code>syslog</code> 中，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_log</span> syslog:server=<span class="number">192.168.1.1</span> <span class="literal">debug</span>;</span><br><span class="line"><span class="attribute">access_log</span> syslog:server=unix:/var/log/nginx.sock,nohostname;</span><br></pre></td></tr></table></figure>

<p>​    另外，错误日志也支持发送到内存中，即在内存中开辟一段空间，<code>Nginx</code> 会将日志循环写入到该空间中，一般用来在线调试：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">error_log</span> memory:<span class="number">32m</span> <span class="literal">debug</span>;</span><br></pre></td></tr></table></figure>

<p>​    注意：这种方式需要我们在编译 <code>Nginx</code> 时，需要修改 <code>Nginx</code> 的 <code>makefile</code> 文件，设置 <code>CFLAGS = -pipe -W -Wall -Wpointer-arith -Wno-unused-parameter -g -O0</code>，即新增 <code>-O0</code> 和 <code>-g</code> 选项；<code>-O0</code> 代表不进行优化，<code>-g</code> 代表调试模式，或者在我们编译 <code>Nginx</code> 时指定编译参数：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="attribute">configure</span> --with-cc-opt=<span class="string">&#x27;-g -O0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>​    这个方式，我们需要通过 <code>gdb</code> 脚本 <code>nginx.gdb</code> 来查看日志，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set $log = ngx_cycle-&gt;log</span><br><span class="line"></span><br><span class="line">while $log-&gt;writer != ngx_log_memory_writer</span><br><span class="line">	set $log = $log-&gt;next</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">set $buf = (ngx_log_memory_buf_t *) $log-&gt;wdata</span><br><span class="line">dump binary memory debug_log.txt $buf-&gt;start $buf-&gt;end</span><br></pre></td></tr></table></figure>

<p>​    然后我们再执行 <code>gdb -p [Nginx Worker 进程ID] -ex &quot;nginx.gdb&quot; --batch</code>，这样就会把日志文件输出到 <code>debug_log.txt</code> 文件中。</p>
<p>​    默认错误日志级别为 <code>error</code> ，除此之外还有 <code>debug</code> ，<code>info</code> ，<code>notice</code> ，<code>warn</code> ，<code>error</code> ，<code>crit</code> ，<code>alert</code> ，<code>emerg</code> ，一般情况下我们使用默认的 <code>error</code> 即可。</p>
<p>**<code>include</code>**：用来指定 <code>Nginx</code> 主配置文件中引入一些配置段，基本用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">include</span> file | mask;</span><br><span class="line">Default: -</span><br><span class="line">Context: any</span><br></pre></td></tr></table></figure>

<p>​    生产比较常用是：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"><span class="attribute">include</span> /usr/share/nginx/modeules/<span class="regexp">*.conf</span>;</span><br><span class="line"><span class="attribute">include</span> mime.types;</span><br><span class="line"><span class="attribute">include</span> vhosts/<span class="regexp">*.conf</span>;</span><br></pre></td></tr></table></figure>

<p>​    其中 <code>http</code> 配置段中的 <code>include /etc/nginx/default.d/*.conf;</code> 就解释了为什么我们之间在 <code>/etc/nginx/default.d/</code> 创建的 <code>a.conf</code>、<code>b.conf</code> 等配置文件可以被 <code>Nginx</code> 正常加载。</p>
<p>**<code>load_module</code>**：用来指定 <code>Nginx</code> 加载的模块位置。基本用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">load_module</span> file;</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="attribute">main</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">9</span>.<span class="number">11</span>.</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">load_module</span> modules/ngx_mail_module.so;</span><br></pre></td></tr></table></figure>

<p>​    其中有个 <code>mod-http-perl.conf</code> 位于 <code>/usr/share/nginx/modules/</code>，其内容为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test nginx]# cat /usr/share/nginx/modules/mod-http-perl.conf </span><br><span class="line">load_module &quot;/usr/lib64/nginx/modules/ngx_http_perl_module.so&quot;;</span><br></pre></td></tr></table></figure>

<p>​    **<code>pid</code>**：用来指定 <code>Nginx</code> 的 <code>pid</code> 文件，很简单：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">pid</span> file;</span><br><span class="line">Default: <span class="attribute">pid</span> logs/nginx.pid;</span><br><span class="line">Context: main</span><br></pre></td></tr></table></figure>

<p>​    需要注意的是，我们在通过 <code>systemctl</code> 对 <code>nginx</code> 进程或者直接使用 <code>/usr/sbin/nginx</code> 进行管理时，是基于该配置文件的（需要根据这个配置文件找到 <code>Nginx</code> 的进程号），如果删除了则无法正常管理，会提示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx: [error] invalid PID number &quot;&quot; in &quot;/run/nginx.pid&quot;</span><br></pre></td></tr></table></figure>

<p>​    我们可以通过查找 <code>Nginx master</code> 的进程号进行重新创建，或则直接 <code>kill</code> 掉。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@test sbin]# ps -ef | grep nginx</span><br><span class="line">root        996      1  0 09:36 ?        00:00:00 nginx: master process /usr/sbin/nginx</span><br><span class="line">nginx       997    996  0 09:36 ?        00:00:00 nginx: worker process</span><br></pre></td></tr></table></figure>

<p>​    以上这些就是在 <code>Nginx Core</code> 配置中比较常见的指令，很多我们保持默认配置即可。</p>
<hr>
<h3 id="2-Nginx-HTTP-核心模块"><a href="#2-Nginx-HTTP-核心模块" class="headerlink" title="2. Nginx HTTP 核心模块"></a>2. <code>Nginx HTTP</code> 核心模块</h3><p>该模块 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html"><code>nginx_http_core_module</code></a>是 <code>Nginx</code> 作为 <code>Web</code> 服务器的核心模块，很多参数需要我们重点掌握，其中有些参数在优化课程中我们已经介绍，这里会一带而过。本节内容重点是介绍 <code>Nginx</code> 作为 <code>Web</code> 服务器该如何使用。</p>
<h4 id="server"><a href="#server" class="headerlink" title="server"></a><code>server</code></h4><p>​    **<code>server</code>**：用来配置 <code>Nginx</code> 的虚拟主机，非常重要！</p>
<p>我们从 <code>Nginx</code> 安装（通过 <code>EPEL</code> 源安装）后的默认配置讲起：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">      <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">      <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">      <span class="attribute">server_name</span>  <span class="number">10.4.7.100</span>;</span><br><span class="line">      <span class="attribute">root</span>         /usr/share/nginx/html;</span><br><span class="line">  </span><br><span class="line">      <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">      <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">      <span class="section">location</span> / &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">      <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">      <span class="section">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">      <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>server</code> 中第一个核心指令 <code>listen</code> ,如下：</p>
<h4 id="listen"><a href="#listen" class="headerlink" title="listen"></a><code>listen</code></h4><p>​    **<code>listen</code>**：用来指定虚拟主机的监听地址（可以是 <code>IPv4</code> 或者 <code>IPv6</code>）与端口，以及一些与套接字相关的配置，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">listen</span> address[:port] [default_server] [ssl] [http2 | spdy]</span><br><span class="line">[proxy_protocol]</span><br><span class="line">				[setfib=number] [fastopent=number] [backlog=number]</span><br><span class="line">[rcvbuf=size]</span><br><span class="line">				[sndbuf=size] [accept_filter=filter] [deferred] [bind]</span><br><span class="line">[ipv6only=<span class="literal">on</span>|<span class="literal">off</span>]</span><br><span class="line">				[reuseport] [so_keepalive=<span class="literal">on</span>|<span class="literal">off</span>|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line">		<span class="attribute">listen</span> port [default_server] [ssl] [http2 | spdy] [proxy_protocol]</span><br><span class="line">[setfib=number]					[fastopen=number] [backlog=number]</span><br><span class="line">[rcvbuf=size]	[sndbuf=size]</span><br><span class="line">[accpet_filter=filter] [deferred] [bind] [ipv6only=<span class="literal">on</span> | <span class="literal">off</span>] [reuseport]</span><br><span class="line">[so_keepalive=<span class="literal">on</span>|<span class="literal">off</span>|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line">		<span class="attribute">listen</span> unix:path [default_server] [ssl] [http2 | spdy]</span><br><span class="line">[proxy_protocol]							[backlog=number] [rcvbuf=size]</span><br><span class="line">[sndbuf=size] [accept_filter=filter]</span><br><span class="line">				[deferred] [bind] [so_keepalive=<span class="literal">on</span>|<span class="literal">off</span>|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line">Default: <span class="attribute">listen</span> *:<span class="number">80</span> | *:<span class="number">8000</span>;</span><br><span class="line">Context: server</span><br></pre></td></tr></table></figure>

<p>​    我们在第一节课演示了虚拟主机可以基于<strong>IP地址</strong>（监听的 <code>IP</code> 地址不同）、<strong>PORT</strong>端口（监听的端口号不同）以及<strong>域名</strong>（指定的域名不同）等三种方式实现，其中 <code>IP地址</code> 与 <code>端口</code> 的实现就是通过 <code>listen</code> 指令实现，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">127.0.0.1:8000</span>;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">127.0.0.1</span>;</span><br><span class="line"><span class="attribute">listen</span> <span class="number">8000</span>;</span><br><span class="line"><span class="attribute">listen</span> *:<span class="number">8000</span>;</span><br><span class="line"><span class="attribute">listen</span> localhost:<span class="number">8000</span>;</span><br></pre></td></tr></table></figure>

<p>​    如果默认没有指定端口的话，则监听在 <code>80</code> 端口；另外，除了监听在端口上之外，我们还可以监听在 <code>unix</code> 套接字上，以实现本机的快速访问，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> unix:/var/run/nginx.sock;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不过这种方式很少使用。</p>
</blockquote>
<p>​    在 <code>listen</code> 指令中，有几个与调优相关的参数，我们需要在配置上添加上，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">listen</span> <span class="number">0.0.0.0:80</span> backlog=<span class="number">10240</span> reuseport so_keepalive=<span class="number">10m</span>::<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>​    除此之外，还有</p>
<h4 id="default-server"><a href="#default-server" class="headerlink" title="default_server"></a><code>default_server</code></h4><p>​    **<code>default_server</code>**：用来指定默认的虚拟主机，即当用户请求的域名与当前节点配置的域名均不匹配时，由该虚拟主机进行响应。如果所有虚拟主机均为配置 <code>default_server</code> 字段，那么配置的第一个虚拟主机作为默认的虚拟主机。</p>
<h4 id="ssl"><a href="#ssl" class="headerlink" title="ssl"></a><code>ssl</code></h4><p>​    **<code>ssl</code>**：配置 <code>https</code> 类型的虚拟主机，指定 <code>ssl</code> 时，需要指定 <code>ssl</code> 监听端口，默认为 <code>443</code>；</p>
<blockquote>
<p>使用 <code>opensll</code> 快速创建私有证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout ./nginx.key -out ./nginx.crt</span><br></pre></td></tr></table></figure>

<p>查看证书信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in nginx.crt -noout -text</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    在使用 <code>ssl</code> 会话加密时，我们至少要指定监听端口号，域名证书以及域名私钥，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>	/data/nginx/a/ssl/nginx.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>	/data/nginx/a/ssl/nginx.key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>证书和私钥我们最好设置为 <code>600</code> 或者 <code>400</code> 权限。</p>
</blockquote>
<hr>
<h4 id="server-name"><a href="#server-name" class="headerlink" title="server_name"></a><code>server_name</code></h4><p>​    <code>server_name</code>：用来指定虚拟主机域名，可以指定多个域名，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> example.com www.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    也支持使用 <code>*</code> 作为通配符，</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> example.com <span class="regexp">*.example.com</span> <span class="regexp">ww.example.*</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    当使用通配符时，需要注意：<strong>左侧通配符优先于右侧通盘符匹配！</strong></p>
<p>​    还可以支持正则表达式，如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> www.example.com ~^www\d+\.example\.com$;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>但是非常影响性能，慎重使用！</strong></p>
<p>总结一下，<code>server_name</code> 的优先级顺序：</p>
<ul>
<li>精确匹配，比如 <code>www.example.com </code>；</li>
<li>左侧通配符匹配，比如 <code>*example.com</code>；</li>
<li>右侧通配符匹配，比如 <code>www.example.*</code>；</li>
<li>正则表达式匹配，比如 <code>~^.*\.example\.com$</code>；</li>
<li>默认主机，即 <code>default_server</code></li>
</ul>
<p>生产上我们一般仅使用精确匹配或者泛域名以及默认主机，几乎不用正则匹配！</p>
<hr>
<h4 id="root"><a href="#root" class="headerlink" title="root"></a><code>root</code></h4><p>​    **<code>root</code>**：用于定义资源路径，该指令出现在 <code>http</code>，<code>server</code>，<code>location</code>，<code>if in location</code> 匹配段中，内层未定义时会继承自外层，内层中定义了则会覆盖外层定义，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">root</span> path;</span><br><span class="line">Default: <span class="attribute">root</span> html;</span><br><span class="line">Context: http, server, location. <span class="attribute">if</span> in location;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> 			<span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>	/data/nginx/a/ssl/nginx.crt;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> /data/nginx/a/ssl/nginx.key;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    此时，假如我们访问的 <code>url</code> 路径是：<code>http://www.a.com/fstab.txt</code> ，那么请求 <code>Nginx</code> 站点的文件路径为：<code>/data/nginx/a/fstab.txt</code>；</p>
<p>​    如果我们没有在 <code>server</code> 中设定 <code>root</code> ，则会继承自 <code>http</code> 配置段中的 <code>root</code>，即：<code>http --&gt; server --&gt; location</code>。</p>
<hr>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a><code>location</code></h4><p>​    **<code>location</code> **：用来设定不同 <code>URI</code> 的文件系统的路径映射，一个 <code>server</code> 中可以设置多个 <code>location</code>，<code>Nginx</code> 会根据用户请求的 <code>URI</code> 地址来逐个判断 <code>location</code> ，找出最佳匹配规则，然后应用该 <code>location</code> 中定义的配置。</p>
<p>​    <code>location</code> 是 <code>Nginx</code> 使用频繁非常非常高的指令，匹配规则以及匹配优先级是 <code>location</code>指令较复杂的地方。我们先来看下基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax:	<span class="section">location</span> [ = | <span class="regexp">~ |</span> <span class="regexp">~* |</span><span class="regexp"> ^~</span> ] uri &#123; ... &#125;</span><br><span class="line">		<span class="section">location</span> <span class="variable">@name</span> &#123; ... &#125;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>其中：</p>
<p>​    <code>=</code>：对 <code>uri</code> 做精确匹配，优先级最高，如果匹配成功，则停止向下搜索，并立即处理此请求；比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> = / &#123;</span><br><span class="line">    ...	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当请求 <code>http://www.a.com/</code> 时匹配，但当访问 <code>http://www.a.com/index.html</code> 则不匹配；</p>
<p><code>^~</code>：对 <code>uri</code> <strong>起始字符</strong> 做字符串匹配（注意：不是正则匹配），区分大小写，会检索所有匹配项，以匹配长度为优先，一旦匹配上，不再进行正则匹配；</p>
<p><code>~</code>：对 <code>uri</code> <strong>（可以不是起始字符）</strong>做正则表达式匹配，区分大小写；</p>
<p><code>~*</code>：对 <code>uri</code><strong>（可以不是起始字符）</strong>做正则表达式匹配，不区分大小写；</p>
<p>不带符号：匹配 <strong>起始于此字符</strong> 串的所有 <code>uri</code>，区分大小写；</p>
<blockquote>
<p>注意：字符串匹配（无论是 ^~ 还是 无符号 匹配），后面都必须以 <code>/</code> 开头，否则将永远无法匹配上。</p>
</blockquote>
<p>针对以上几种匹配规则，匹配度优先级为：</p>
<p>​    <code>=</code> &gt; <code>^~</code> &gt; <code>~</code> = <code>~*</code> &gt; <code>不带符号</code></p>
<blockquote>
<p>注意：我们还可以以 <code>@</code> 符号前缀来定义名称 <code>location</code> 段，这种定义方式不是用于外部请求，一般用于内部跳转。</p>
<p>稍后我们在 <code>error_page</code> 指令中跟大家介绍。定义方式如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">localtion</span> <span class="variable">@fallback</span> &#123;</span><br><span class="line"> <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>​    需要注意的是，前缀匹配根据匹配长度作为优先级，正则表达式是根据配置文件中的顺序（也就是说<strong>正则表达式的匹配是根据匹配规则出现的先后决定优先级，跟匹配长度、大小写是否敏感无关</strong>），比如 <code>A</code> 和 <code>B</code> 同时匹配，但是 <code>A</code> 写下 <code>B</code> 前就是通过 <code>A</code> 响应，反之则通过 <code>B</code> 响应；</p>
<p>​    下面是关于 “正则表达式” 的一些知识点，我们需要了解。</p>
<blockquote>
<p>正则表达式非常重要，我们常用的语言都在存在，但是这块知识初始了解时可能觉得比较抽象，需要多多练习。</p>
</blockquote>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210128143550175.png" alt="image-20210206153806134"></p>
<p><strong>注意：其中元字符匹配仅能匹配一个字符，如果要重复匹配则需要借助匹配代码实现！</strong></p>
<blockquote>
<p><strong>知识点1</strong>：在 <code>CentOS</code> 中，我们经常使用 <code>grep</code> 用来做正则匹配，但是这个命令只能使用普通的正则功能，我们可以使用 <code>egrep</code> 或者 <code>grep -E</code> （<code>Extended RegEx</code>）来启用扩展的正则功能，或者使用 <code>grep -P</code> 来启用 <code>Perl RegEx</code>。</p>
<p><strong>知识点2</strong>：上面的元字符 <code>\d</code>，<code>grep</code>，与 <code>egrep</code> 是不支持的，但是 <code>grep -P</code> 支持。</p>
</blockquote>
<p>下面我们将对 <code>location</code> 的匹配优先级做实例演示，配置文件 <code>a.con.conf</code> 如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/a;</span><br><span class="line">    <span class="section">location</span> = / &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">701</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">702</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span><span class="regexp"> ^~</span> /sta/ &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">703</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span><span class="regexp"> ^~</span> /stat &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">704</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> <span class="regexp"> ^~</span> /static &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">705</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.(gif|jpg|jpeg)$</span> &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">706</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /images/</span> &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">707</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ /Images/</span> &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">708</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> /abc &#123;</span><br><span class="line">        <span class="attribute">return</span> <span class="number">709</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【精确匹配测试】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/</span></span><br><span class="line">HTTP/1.1 701 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:42:14 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/index.html</span></span><br><span class="line">HTTP/1.1 702 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:42:46 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>可以看到只有请求 <code>uri = /</code> ，即 <code>http://www.a.com/</code> 时，才会精确匹配到，优先级最高。</p>
<p><strong>【前缀匹配与正则匹配优先级测试】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/staticfile/a.jpeg</span></span><br><span class="line">HTTP/1.1 705 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:45:15 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>uri = staticfile/a.jpeg</code> 其实匹配到了规则 <code>location ^~ /static</code> ，也就是前缀匹配字符串中含有部分字符串 <code>static</code> ，就比正则表达式完全匹配优先级高。其实：</p>
<p><strong>前缀匹配优先级比正则表达式高，一旦前缀匹配到，则不会再进行正则匹配</strong></p>
<p><strong>【前缀匹配之间优先级测试】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/sta/a.jpeg</span></span><br><span class="line">HTTP/1.1 703 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:49:32 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/stat/a.jpeg</span></span><br><span class="line">HTTP/1.1 704 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:49:47 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/stati/a.jpeg</span></span><br><span class="line">HTTP/1.1 704 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:49:56 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/static/a.jpeg</span></span><br><span class="line">HTTP/1.1 705 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:49:58 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>可以得到结论：</p>
<ol>
<li><p><strong>前缀匹配首先匹配规则的匹配度</strong></p>
<p>比如 <code>http://www.a.com/stat/a.jpeg</code> 与 <code>http://www.a.com/stati/a.jpeg</code> 匹配到的规则则是 <code>location ^~ /stat</code> ，因为该 <code>location</code> 中的字符是完全匹配，而 <code>location ^~ /sta/</code> 与 <code>location ^~ /static</code> 都不能完全匹配</p>
</li>
<li><p><strong>前缀匹配（同样会和无符号匹配比较长度）其次比较匹配长度</strong></p>
<p>比如 <code>http://www.a.com/static/a.jpeg</code> 可以匹配到 <code>location ^~ /stat</code> 与 <code>location ^~ /static</code> ，但是后者长度比前者大，因此由后者设置生效</p>
</li>
</ol>
<p><strong>【正则表达式之间的匹配】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/Images/a.jpeg</span></span><br><span class="line">HTTP/1.1 706 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:57:58 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/images/a.jpeg</span></span><br><span class="line">HTTP/1.1 706 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 13:58:04 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>可以看到无论 <code>uri</code> 中是否含有大小写，都可以看到是 <code>location ~* \.(gif|jpg|jpeg)$</code> 规则匹配到了。那么我们调整下配置文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen              80;</span><br><span class="line">    server_name         www.a.com a.com;</span><br><span class="line">    root                /data/nginx/a;</span><br><span class="line">    location = / &#123;</span><br><span class="line">        return  701;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        return  702;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ^~ /sta/ &#123;</span><br><span class="line">        return  703;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ^~ /stat &#123;</span><br><span class="line">        return  704;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location  ^~ /static &#123;</span><br><span class="line">        return  705;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* /images/ &#123;</span><br><span class="line">        return  707;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">        return  706;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ /Images/ &#123;</span><br><span class="line">        return  708;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    locatin /abc &#123;</span><br><span class="line">        return 709;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要调整了 <code>location ~* /images/</code> 和 <code>location ~* \.(gif|jpg|jpeg)$</code> 位置，请求测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@test conf.d]# curl -I http://www.a.com/images/a.jpeg</span><br><span class="line">HTTP/1.1 707</span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 14:06:29 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>可以看到是 <code>location ~* /images/</code> 匹配到了请求规则，这里我们可以得到下面一个结论：</p>
<p><strong>在正则匹配中，优先级遵循匹配顺序，即先匹配到的优先级越高。</strong></p>
<p><strong>【无符号匹配优先级测试】</strong></p>
<p>我们再做一个测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/haha</span></span><br><span class="line">HTTP/1.1 702 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 14:09:02 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/abcdefg</span></span><br><span class="line">HTTP/1.1 709 </span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Sun, 07 Feb 2021 14:09:16 GMT</span><br><span class="line">Content-Length: 0</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>所以，我们可以得出结论：</p>
<ol>
<li><strong>无符号匹配优先级最低</strong></li>
<li><strong>无符号匹配先检查准确度，再检查匹配长度（和前缀匹配类似）</strong></li>
</ol>
<blockquote>
<p>需要注意：<code>uri</code> 匹配是不包含 <code>query_string</code> 的，比如你请求的地址为 <code>http://ww.a.com/abc</code> 和 <code>http://www.a.com/abc?param1&amp;param2</code> 在 <code>location</code> 规则看到的 <code>uri</code> 是一样的。</p>
</blockquote>
<p>关于 <code>location</code> 的匹配大家需要熟悉这些内容，一般我们在生产环境中至少会写三种匹配规则，如下：</p>
<ul>
<li><strong>作为静态应用服务</strong></li>
</ul>
<p>可以使用下面两种匹配规则中的任意一种，也可以同时使用</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span><span class="regexp"> ^~</span> /static/ &#123;</span><br><span class="line">    <span class="attribute">root</span>	/webroot/static/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* \.(gif|jpg|jpeg|png|css|js|ico)$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span>	/webroot/res/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>作为代理服务器</strong></li>
</ul>
<p>至少有一条规则，可以在其他规则都匹配不到时能够生效</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>	http://tomcat:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="alias"><a href="#alias" class="headerlink" title="alias"></a><code>alias</code></h4><p>​    **<code>alias</code>**：路径别名，用来定义路径映射。</p>
<p><strong>注意：<code>alias</code> 仅能用于 <code>location</code> 中！</strong></p>
<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">alias</span> path;</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /i/ &#123;</span><br><span class="line">    <span class="attribute">alias</span>	/data/w3/images/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们此时访问的是 <code>http://www.a.com/i/top.gif</code> 那么 <code>Nginx</code> 使用的文件查找路径是：<code>/data/w3/images/top.gif</code> 。</p>
<blockquote>
<p>注意：如果在定义了正则表达式的路径使用了 <code>alias</code> ，那么正则表达式中应该含有匹配组，并且 <code>alias</code> 应该引用这些匹配组（0.7.40版）来组成一个完整的文件路径。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ ^/users/(.+\.(?:gif|jpe?g|png))$</span> &#123;</span><br><span class="line"> <span class="attribute">alias</span>	/data/nginx/images/<span class="variable">$1</span>; <span class="comment">#指定明确的路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>此时我们请求 <code>http://www.a.com/users/a.jpeg</code> ，则会查找 <code>/data/nginx/images/a.jpeg</code> ，如果我们请求的是：<code>http://www.a.com/users/b.gif</code>，则会查找 <code>/data/nginx/images/b.gif</code>，具体演示请参考视频课程。</p>
<blockquote>
<p>关于：<code>(?:gif)</code> 的正则表达式释义</p>
<p>比如：<code>(?:x)</code> 表示匹配 <code>x</code> 但是不记住匹配项。这种括号叫作 非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。看看这个例子 <code>/(?:foo)&#123;1,2&#125;/</code>。如果表达式是 <code>/foo&#123;1,2&#125;/</code> ，<code>&#123;1,2&#125;</code> 将只应用于 <code>foo</code> 的最后一个字符 <code>o</code> 。如果使用非捕获括号，则 <code>&#123;1,2&#125;</code> 会应用于整个 <code>foo</code> 单词。</p>
</blockquote>
<p>我们知道 <code>root</code> 也是用来定义文件路径的，这两个有什么区别呢？</p>
<ul>
<li><strong>首先是两者使用的位置不同，<code>root</code> 可以在 <code>http</code>、<code>server</code>、<code>location</code>、<code>if in location</code> 配置段中，而 <code>alias</code> 仅可以用于 <code>location</code> 配置段中。</strong></li>
<li><strong><code>root</code> 指定的路径，替换掉 <code>location</code> 中 <code>/uri/</code> 起始 <code>/</code> 左侧的部分，而 <code>alias</code> 指定的路径替换掉 <code>location</code> 中 <code>/uri/</code> 起始 <code>/</code> 的右侧部分（注意是右侧所有部分）。</strong>示意图如下：</li>
</ul>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212112855698.png" alt="image-20210208150120409"></p>
<p>示例：</p>
<p>我们创建两个文件，文件内容是该文件所在的路径，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test images]# echo &quot;/data/nginx/images/a.jpeg&quot; &gt; /data/nginx/images/a.jpeg </span><br><span class="line">[root@test images]# echo &quot;/data/nginx/a.jpeg&quot; &gt; /data/nginx/a.jpeg</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用 <code>.jpeg</code> 作为文件名，是有点奇怪！但是注意再次证明在 <code>linux</code> 上后缀名不重要</p>
</blockquote>
<p><strong>【<code>root</code> 指定路径】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /images/ &#123;</span><br><span class="line">        <span class="attribute">root</span>    /data/nginx/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.a.com/images/a.jpeg</span><br><span class="line">/data/nginx/images/a.jpeg</span><br></pre></td></tr></table></figure>

<p>当我们访问 <code>http://www.a.com/images/a.jpeg</code> 时对应的文件路径是 <code>/data/nginx/images/a.jpeg</code>；</p>
<p>即：<code>root</code> 个定的路径 <code>/data/nginx/</code> 替代了 <code>/images/</code> 左侧的 <code>/</code> ，变成了 <code>/data/nginx/images/</code> 。</p>
<p><strong>【<code>alias</code> 指定路径】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> 	/images/ &#123;</span><br><span class="line">    <span class="attribute">alias</span>	/data/nginx/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.a.com/images/a.jpeg</span><br><span class="line">/data/nginx/a.jpeg</span><br></pre></td></tr></table></figure>

<p>此时我们访问 <code>http://www.a.com/images/a.jpeg</code> ，对应的路径是 <code>/data/nginx/a.jpeg</code>；</p>
<p>即：<code>alias</code> 给定的路径 <code>/data/nginx/</code> 替代了 <code>/images/</code> 起始 <code>/</code> 右侧的部分，变成了 <code>/data/nginx/a.jpeg</code> </p>
<p>生产上，我们可能会结合正则表达式使用，但<strong>一定要注意需要在 <code>alias</code> 中指定明确的文件路径。</strong></p>
<hr>
<h4 id="index"><a href="#index" class="headerlink" title="index"></a><code>index</code></h4><p>​    <strong><code>index</code><strong>：定义默认</strong>索引/首页</strong>文件，该指令由 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_index_module.html%23index"><code>ngx_http_index_module</code></a>提供。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">index</span> file ...;</span><br><span class="line">Default: <span class="attribute">index</span> index.html;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>我们可以通过 <code>nginx</code> 来指定上线问的默认首页文件，支持三种写法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">index</span> index.<span class="variable">$geo</span>.html index.<span class="number">0</span>.html /index.html;</span><br></pre></td></tr></table></figure>

<p>即：<strong>正常文件名称</strong>、可以 <strong>支持变量</strong>，也可以 <strong>使用 <code>/</code> 表示绝对路径</strong>，但是需要注意的是</p>
<ul>
<li><strong>使用 <code>/</code> 绝对路径必须出现在最后一个配置选项中；</strong></li>
<li><strong>该绝对路径是相当于当前上下文的 <code>/</code> ，也就是实际的 <code>root</code> 配置。</strong></li>
</ul>
<p>比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com	a.com;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/a;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>       index.<span class="variable">$remote_addr</span>.html /index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的 <code>/index.html</code> 表示的路径就是 <code>/data/nginx/a/index.html</code> ，但是如果我们此时 <code>location</code> 中配置了 <code>root</code> 路径，即如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span>	default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/a;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>       index.<span class="variable">$remote_addr</span>.html /index.html;</span><br><span class="line">        <span class="attribute">root</span>	    /data/nginx/a/location;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么此时的 <code>/index.html</code> 表示的路径是 <code>/data/nginx/a/location/index.html</code> ，即是根据当前上下文中的 <code>root</code> 来匹配。</p>
<p>注意：<strong>我们如果在 <code>index</code> 中配置了多个页面，则会依次查找，找到哪个用哪个进行默认响应。</strong></p>
<p><strong>【由 <code>index</code> 指令导致的内部重定向问题】</strong></p>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/a;</span><br><span class="line">    <span class="section">location</span> = / &#123;</span><br><span class="line">        <span class="attribute">index</span>	    index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>	    /data/nginx/a/location;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>/data/nginx/a/index.html</code> 文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test domain]# cat /data/nginx/a/index.html </span><br><span class="line">This is a.com page</span><br></pre></td></tr></table></figure>

<p>而 <code>/data/nginx/a/location/inxex.html</code> 文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@test domain]# cat /data/nginx/a/location/index.html </span><br><span class="line">/data/nginx/a/location</span><br></pre></td></tr></table></figure>

<p>此时我们请求 <code>http://www.a.com/</code>，响应内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl http://www.a.com/</span><br><span class="line">/data/nginx/a/location</span><br></pre></td></tr></table></figure>

<p>即当我们访问 <code>www.a.com</code> 时，实际上是被 <code>Nginx</code> 将地址修改为 <code>www.a.com/index.html</code> ，于是匹配到了 <code>location /</code>，因此为该 <code>location</code> 下的配置进行响应。</p>
<p><strong>生产上使用 <code>index</code> 指令时，需要注意内部重定向问题。</strong></p>
<p><strong>【趣味测试】</strong></p>
<p>根据用户的 <code>IP</code> 地址不同，使用不同的默认页面，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建两个不同的页面</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /data/nginx/a/index.10.4.7.100.html</span></span><br><span class="line">10.4.7.100</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /data/nginx/a/index.10.4.7.101.html</span></span><br><span class="line">10.4.7.101</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /data/nginx/a/index.html</span></span><br><span class="line">This is a.com page</span><br></pre></td></tr></table></figure>

<p>我现在希望当我通过客户端 <code>10.4.7.100</code> 访问 <code>www.a.com</code> 时，响应 <code>10.4.7.100</code>，通过客户端 <code>10.4.7.101</code> 访问 <code>www.a.com</code> 时，响应 <code>10.4.7.101</code> ，当使用其他地址时，则响应 <code>This is a.com page</code> ，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/a;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span> index.<span class="variable">$remote_addr</span>.html index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="error-page"><a href="#error-page" class="headerlink" title="error_page"></a><code>error_page</code></h4><p>​    **<code>error_page</code>**：用来定义不同错误的响应 <code>uri</code> ，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">error_page</span> code ... [=[response]] uri;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span>, if in <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>关于 <code>error_page</code> 的使用，比较绕的一点在于 <code>[=[response]]</code> 这部分内容，我们将从简入深，跟大家介绍这几种用法。</p>
<p><strong>【普通用法】</strong></p>
<p>服务端配置文件：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span> 	www.a.com a.com;</span><br><span class="line">    <span class="section">location</span>	<span class="regexp">~*	/images/</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/;</span><br><span class="line">        <span class="attribute">error_page</span>	<span class="number">404</span>	 /notfound.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> 	/	&#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">        <span class="attribute">error_page</span>	<span class="number">404</span>	 /notfound.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们准备两个 <code>notfound.html</code> 文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /data/nginx/a/notfound.html</span></span><br><span class="line">&lt;h1&gt;Not Found the Page From /data/nginx/a Directory&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>放在 <code>location /</code> 定义的 <code>root</code> 路径下。</p>
</blockquote>
<p>测试 <code>error_page</code> 中定义的 <code>/notfound.html</code> 究竟是从哪个路径下获取该文件。我们现在可能会有两种猜想：</p>
<ul>
<li><code>/notfound.html</code> 页面的请求路径是 <code>location</code> + <code>/notfound.html</code> ，即当我们请求的页面 <code>www.a.com/images/a.jpeg</code> 页面不存在时，会跳转到 <code>www.a.com/images/notfound.html</code>；</li>
<li><code>/notfound.html</code> 页面的请求路径是 <code>/notfound.html</code> ，即当我们请求的页面 <code>www.a.com/images/a.jpeg</code> 页面不存在时，会跳转到 <code>www.a.com/notfound.html</code>；</li>
</ul>
<p>如果是第一种情况，那么我们</p>
<p>页面请求测试：</p>
<p>**请求页面 <code>http://www.a.com/images/as.jpeg</code> **</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212145141048.png" alt="image-20210209161637773" style="zoom:30%;" />

<p><strong>请求页面 <code>http://www.a.com/a.html</code></strong></p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210209161637773.png" alt="image-20210209161807280" style="zoom:30%;" />



<p><strong>结合两个测试结果，可以得出如下结论：</strong></p>
<p><strong>当我们请求的页面不存在时，会内部跳转到我们制定的页面，并且不会再请求的 <code>uri</code> 中加任何多余字符，就是 <code>domain_name</code> + <code>notfound-uri页面</code>。</strong></p>
<p>比如我们的 <code>domain_name</code> 是 <code>a.com</code> 或者 <code>www.a.om</code> ，<code>uri 页面</code> 是 <code>/notfound.html</code> ，那么当内部重定向到这个页面时，相当于请求 <code>uri</code> 地址是 <code>www.a.com/notfound.html</code> ，至于由哪个页面来响应，要根据这个 <code>uri</code> 的正常响应来查看。</p>
<p>这是最简单的 <code>error_page</code> 用法，我们更多时候会定义多个错误代码，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">	... ...</span><br><span class="line">    <span class="attribute">error_page</span>	<span class="number">404</span>		/<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">error_page</span>	<span class="number">500</span>	<span class="number">502</span>	<span class="number">503</span>	<span class="number">504</span>		/50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 这是最常见的用法，这种方式可以让我们通过自定义错误页面来友好的响应错误信息。但是客户端接收到的代码依然是错误代码。比如上面我们请求 <code>http://www.a.com/a.html</code> 的页面不存在，于是由 <code>/notfound.html</code> 页面进行响应，这个页面虽然找到了，但是客户端看到的代码依然是 <code>404</code> ，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://www.a.com/a.html</span></span><br><span class="line">&lt;h1&gt;Not Found the Page From /data/nginx/a Directory&lt;/h1&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/a.html</span></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 01 Apr 2020 21:58:55 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 57</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5e850954-39&quot;</span><br></pre></td></tr></table></figure>

<p>这个时候，国内的有些浏览器就开始干坏事了，会使用自己的广告页面代替你自定义的错误页面。如果要避免这种根据响应码的页面“劫持”，我们可以通过 <code>error_page</code> 来修改响应码。</p>
<p><strong>【重定义错误响应码】</strong></p>
<p>我们把配置写的简单一些：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">        <span class="attribute">error_page</span>	<span class="number">404</span> =<span class="number">200</span>	/notfound.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次请求咱们之前的不存在页面：<code>http://www.a.com/a.html</code> ，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://www.a.com/a.html</span></span><br><span class="line">&lt;h1&gt;Not Found the Page From /data/nginx/a Directory&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>页面依然不存在，由我们对应的 <code>uri</code> 地址进行响应，此时再查看响应码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/a.html</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 01 Apr 2020 22:08:11 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 57</span><br><span class="line">Last-Modified: Web, 01 Apr 2020 21:36:20 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5e850954-39&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>可以看到响应码是 <code>200</code> ，这样就可以避免某些浏览器或者应用通过错误响应码进行页面劫持了。</p>
<p><strong>【容错处理与使用上游响应码】</strong></p>
<p>在生产上我们经常会这么做，比如我们上线新功能时，为了避免新功能故障导致用户体验较差，会在错误时将用户请求交由原来的服务进行响应，这里就会用到 <code>error_page</code> + <code>location @</code> 功能，用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">        <span class="attribute">error_page</span>	<span class="number">404</span>	<span class="variable">@fallback</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="variable">@fallback</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>	http://10.4.7.101:80;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们将 <code>404</code> 错误（生产环境中你还可以设置很多错误代码，比如 <code>error_page 403 404 408 500 501 502 503 504 @fallback;</code>）使用 <code>@fallback</code> 来响应，然后定义这个基于名称的 <code>location</code> ，然后将其代理至 <code>http://10.4.7.101:80</code> ，注意 <code>proxy_pass</code> 参数我们后面会详细介绍。</p>
<p>我在 <code>10.4.7.101</code> 中简单启动了 <code>nginx</code> 页面，并且创建了两个页面如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /usr/share/nginx/html/a.html</span></span><br><span class="line">&lt;h1&gt;This is the a.html from old-server&lt;/h1&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /usr/share/nginx/html/b.html</span></span><br><span class="line">&lt;h1&gt;This is the b.html from old-server&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到已经由我们的容错服务器进行响应，我们查看下响应代码，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/a.html</span></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 01 Apr 2020 22:39:05 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 44</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Thu. 02 Apr 2020 08:51:50 GMT</span><br><span class="line">ETag: &quot;5e85a7a6-2c&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/b.html</span></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 01 Apr 2020 22:39:35 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 44</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Thu. 02 Apr 2020 08:52:54 GMT</span><br><span class="line">ETag: &quot;5e85a7a6-2c&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>响应码依然是 <code>404</code> ，我们如果想要修改成某个响应码，只需要加上 <code>error_page 404 =200</code> 这样既可，但是我们此时想 <strong>客户端不想显示中间代理节点响应码而是直接显示上游服务器给出的响应码</strong>，比如：如果上游是 <code>200</code> ，则客户端获得的响应码就是 <code>200</code> ；如果上游是 <code>403</code> ，则客户端获得 <code>403</code> ，我们可以这样配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">        <span class="attribute">error_page</span>	<span class="number">404</span> = <span class="variable">@fallback</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="variable">@fallback</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>	http://10.4.7.101:80;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即：<strong>在 <code>error_code</code> 与 <code>@fallback</code> 中间加上 <code>=</code> ，注意两边都有空格，否则会出错。</strong></p>
<p>这是我们访问容错节点的正常页面和非正常页面，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://www.a.com/a.html</span></span><br><span class="line">&lt;h1&gt;This is the a.html from old-server&lt;/h1&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/a.html</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 01 Apr 2020 22:44:57 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 44</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Thu, 02 Apr 2020 08:51:50 GMT</span><br><span class="line">ETag: &quot;5e85a7a6-2c&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>容错节点的正常页面，客户端响应码为 <code>200</code> 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/a.html</span></span><br><span class="line">HTTP/1.1 404 Not Found</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 01 Apr 2020 22:46:16 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 3650</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">ETag: &quot;5e85a7a6-2c&quot;</span><br></pre></td></tr></table></figure>

<p>访问到容错节点不存在的页面，客户端响应代码与容错节点返回代码一致，都是 <code>404</code> 。</p>
<p>此时我们还可以再造一个上游容错节点的错误代码——<code>403</code>，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">chmod</span> 640 /usr/share/nginx/html/b.html</span></span><br></pre></td></tr></table></figure>

<p>客户端访问测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://www.a.com/b.html</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;403 Forbidden&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;403 Forbidden&lt;h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.16.1&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/b.html</span></span><br><span class="line">HTTP/1.1 403 Forbidden</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Wed, 01 Apr 2020 22:48:53 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 153</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>由容错节点返回数据信息以及相应的响应码。</p>
<p><strong>【错误码跳转外部网站】</strong></p>
<p>在使用 <code>error_page</code> 时，同样支持将错误码响应的 <code>uri</code> 指向外网，默认响应码为 <code>302</code> 即临时重定向，我们也可以通过设置，修改成 <code>301</code> 即永久重定向。</p>
<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">        <span class="attribute">error_page</span>	<span class="number">404</span>	 http://www.b.com/index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>正常请求 <code>http://www.b.com/index.html</code> 结果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://www.b.com/index.html</span></span><br><span class="line">&lt;h1&gt;This is b.com page&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>此时我们对**<code>http://www.a.com/a.html</code>** 这个不存在的页面进行请求访问：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl http://www.a.com/a.html</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;302 Found&lt;h1&gt;&lt;/center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>302</code> 的响应码，但是无任何数据。这是因为使用 <code>curl</code> 请求默认是不支持 <code>redirect</code> 重定向的，我们可以加上 <code>-L</code> 参数，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -L http://www.a.com/a.html</span></span><br><span class="line">&lt;h1&gt;This is b.com pagee&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>这样就可以正常跳转，同时我们再确认下响应码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/b.html</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Thu, 02 Apr 2020 02:55:53 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.b.com/index.html</span><br></pre></td></tr></table></figure>

<p>即 <code>302</code> 临时重定向 <code>Moved Temporarily</code> 。在浏览器上访问的话，我们可以看到浏览器地址会跳转至 <code>http://www.b.com/index.html</code> ，如下：</p>
<p>大家可以自行测试下效果。如果我们想修改响应码，可以这样配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">        <span class="attribute">error_page</span>	<span class="number">404</span> =<span class="number">301</span> http://www.b.com/index.html</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -L http://www.a.com/a.html</span></span><br><span class="line">&lt;h1&gt;This is b.com page&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>依然正常跳转，再看下响应码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">curl -I http://www.a.com/a.html</span></span><br><span class="line">HTTP/1.1 301 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Thu, 02 Apr 2020 02:58:19 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.b.com/index.html</span><br></pre></td></tr></table></figure>

<p>已经修改成 <code>301 Moved Permanently</code> ，即永久重定向。需要注意的是：</p>
<p>**跳转到外部 <code>url</code> 仅可以手动从 <code>302</code> 调整成 <code>301</code> ，不支持调整为其他响应码，即使调整了，真正的响应码仍然是 <code>302</code> **</p>
<p>错误码跳转到外部网站我们还是很少使用，大家了解下即可。</p>
<hr>
<h4 id="try-files"><a href="#try-files" class="headerlink" title="try_files"></a><code>try_files</code></h4><p>​    <code>try_files</code>：其作用是按顺序检查文件是否存在，返回第一个找到的文件或文件夹（结尾加斜线表示为文件夹），如果所有的文件或者文件夹都找不到，会进行一个 <strong>内部重定向</strong> 到最后一个参数。</p>
<p>注意：<strong>只有最后一个参数可以引起一个内部重定向，之前的参数只设置内部 <code>URI</code> 的指向。所谓 <code>URI</code> 指向，还是原来的请求，只不过修改请求的文件，但是 “内部重定向” 则是重新发起新请求</strong>。</p>
<p>最后一个参数是回退 <code>URI</code> 且必须存在，否则会出现内部 <code>500</code> 错误。命名的 <code>location</code> 也可以使用在最后一个参数中。与 <code>rewrite</code> 指令不同，如果回退 <code>URI</code> 不是 <strong>基于名称</strong> 的 <code>location</code> 那么 <code>$args</code> 不会自动保留，如果你想保留 <code>$args</code> ，则必须明确声明。如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">try_files</span>	<span class="variable">$uri</span>（文件） <span class="variable">$uri</span>/（文件夹）  /index.php?q=<span class="variable">$uri</span>&amp;args;</span><br></pre></td></tr></table></figure>

<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">try_files</span> file ... uri;</span><br><span class="line">		<span class="attribute">try_files</span> file ... =code;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>我们来演示下常见用法，以及在使用中经常遇到的错误：</p>
<p><strong>【基本用法】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* .*\.(png|jpeg|jpg|gif)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/images;</span><br><span class="line">        <span class="attribute">try_files</span>	<span class="variable">$uri</span>	/default.gif	=<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们这里以图片请求为例，当用户请求的图片不存在时，则使用 <code>/default.gif</code> 来响应，如果该图片依然不存在，则会重定向到 <code>404</code> 页面。</p>
<p><strong>【通过 <code>location</code> 跳转到后端服务】</strong></p>
<p>有时候可能会有这种需求，当我们请求的文件找不到，就希望交给后端的服务器来处理。我们可以这样配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* .*\.(png|jpg|jpeg|gif)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/images;</span><br><span class="line">        <span class="attribute">try_files</span>	<span class="variable">$uri</span>	/default.gif	<span class="variable">@fallback</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="variable">@fallback</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>	http://10.4.7.101;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们依然以请求图片为例，并且在服务器上删除了 <code>default.gif</code> 图片，也就是让 <code>@fallback</code> 来进行响应。注意：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="variable">@fallback</span> &#123;</span><br><span class="line">    	<span class="attribute">proxy_pass</span>		http://10.4.7.101;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种配置会把我们请求的 <code>uri</code> 原封不动的转交给 <code>proxy_pass</code> 服务器，比如我们请求的是 <code>www.a.com/haha/heihei/houhou.jpg</code>  则会向后端 <code>10.4.7.101</code> 节点发起 <code>http://10.4.7.101/haha/heihei/houhou.jpg</code> 这样的请求，所以为了容错，我们在后端节点也要配置容错机制，后端节点配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cat app-php.conf</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.app-php.com app-php.com;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/app-php/;</span><br><span class="line">    <span class="attribute">try_files</span>		<span class="variable">$uri</span>	/home_page.html;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>/home_page.html</code> 的页面内容如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /data/nginx/app-php/home_page.html</span></span><br><span class="line">&lt;h1&gt;我也找不到你访问的页面--来自于 app-php 服务器&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p><strong>注意：<code>charset utf-8</code> 可以让我们中文正常显示。</strong></p>
<p>现在我们对 <code>www.a.com</code> 发起访问测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl http://www.a.com/e.jpg</span></span><br><span class="line">&lt;h1&gt;我也找不到你访问的页面--来自于 app-php 服务器&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>这种使用方式还是很少见的，大家了解下这种用法即可，下面我们来讨论下使用 <code>try_files</code> 最容易产生的问题。</p>
<p><strong>【<code>try_files</code> 常见问题之 <code>500</code> 错误】</strong></p>
<p>我们先来看下下面这个服务端配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* .*\.(png|jpg|jpeg|gif)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/images;</span><br><span class="line">        <span class="attribute">try_files</span>	/images/<span class="variable">$uri</span>	<span class="variable">$uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先需要说明的一点是，咱们的图片依然是放在 <code>/data/nginx/images</code> 路径下的。</p>
<p>当我们请求 <code>www.a.com/a.jpg</code> 时，会先找 <code>$document_root/images/a.jpg</code> ，也即 <code>/data/nginx/images/images/a.jpg</code> 这个文件是不存在的。然后我们希望去找 <code>$document_root/$uri</code> ，即： <code>/data/nginx/images/a.jpg</code> </p>
<p>这个文件是存在的，那么是不是可以正常响应的客户端请求呢？</p>
<p>即造成了内部循环重定向，导致 <code>500</code> 报错。为什么会造成这个问题呢？</p>
<p>这就是我们前面提到的 最后一个参数会导致请求重定向，而不是 <code>uri</code> 查找，如果是 <code>uri</code> 查找，那么会直接找到 <code>$document_root/$uri</code> 文件，而重定向则会发起第二次请求链接，即：<code>http://www.a.com/a.jpg</code></p>
<p>这个请求会再次被 <code>location</code> 匹配到：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~* .*\.(png|jpg|jpeg|gif)$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span>		/data/nginx/images;</span><br><span class="line">    <span class="attribute">try_files</span>	/images/<span class="variable">$uri</span>	<span class="variable">$uri</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>即 又去查找 <code>$document_root/images/$uri</code> ，然后造成了重定向循环，那么如何解决呢？其实非常简单，我们可以将 <code>$uri</code> 变成非最后一个参数，那么它的匹配就变成了 <code>uri</code> 查找，而非重定向，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		www.a.com a.com;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* .*\.(png|jpg|jpeg|gif)$</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/images;</span><br><span class="line">        <span class="attribute">try_files</span>	/images/<span class="variable">$uri</span>	<span class="variable">$uri</span>	<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再次请求 <strong><code>http://www.a.com/a.jpg</code></strong> 即可获取到正确的文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.a.com/a.jpg</span></span><br></pre></td></tr></table></figure>

<p><strong>【<code>try_files</code> 导致的 <code>$query_string</code> 问题】</strong></p>
<p>前面我们提到了相关问题，如果回退 <code>URi</code> （最后一个<code>URI</code>）不是命名的 <code>location</code> 那么 <code>$args</code> 不会自动保留，如果你想保留 <code>$args</code> ，则必须明确声明。解决方案就是显示声明：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?q=<span class="variable">$uri</span>&amp;<span class="variable">$args</span>;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php;</span><br></pre></td></tr></table></figure>

<p>此时你请求的 <code>uri</code> 为 <code>www.a.com/a.php?a=3$b=4</code> ，上面的写法仅会查找<code>www.a.com/a.php</code> 以及 <code>www.a.om/a.php/</code> 与 <code>www.a.com/index.php</code> ，如果希望 <code>index.php</code> 页面能够接收并处理字符串请求，可以这样修改：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">try_files</span>	<span class="variable">$uri</span>	<span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</span><br></pre></td></tr></table></figure>

<p>当然了，前提是你的 <code>index.php</code> 页面支持字符串传入。</p>
<hr>
<h4 id="limit-rate"><a href="#limit-rate" class="headerlink" title="limit_rate"></a><code>limit_rate</code></h4><p>​    **<code>limit_rate</code>**：用于设置服务端响应客户端速度，默认为 <code>0</code> 表示不作限制。但是生产上很多时候我们可能有限速的需求，我们会使用到该指令。需要注意的是。限速是基于 <code>TCP</code> 协议的滑动窗口实现的。</p>
<p>基本用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">limit_rate</span> rate;</span><br><span class="line">Default: <span class="attribute">limit_rate</span> <span class="number">0</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span>, if in <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>限速是针对单个请求连接的，如果客户端同时发起两个请求，则总速率是限速的两倍。</strong></p>
<p>无限速配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /download/</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx;</span><br><span class="line">        <span class="attribute">autoindex</span>	<span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 <code>/data/nginx/download/</code> 下创建一个 <code>13M</code> 大小的文件 <code>a</code> ，现在进行下载：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210209161807280.png" alt="image-20210212110832052" style="zoom:25%;" />

<p>可以看到我的下载速度在不限速的情况下可以达到大概 <code>92.7MB/s</code> ，现在我们进行限速设置，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> 			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /download/</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx;</span><br><span class="line">        <span class="attribute">autoindex</span>	<span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">limit_rate</span>	<span class="number">100k</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载 <code>nginx</code> 之后，我们再来看下下载速度，如下：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212113346166.png" alt="image-20210212111555202" style="zoom:25%;" />

<p>可以看到下载速度已经被限制在 <code>106KB/s</code>。</p>
<p>在上面的配置中我们引入了一个新的配置参数 <code>autoindex</code> ，下面我们介绍下该参数。</p>
<hr>
<h4 id="autoindex"><a href="#autoindex" class="headerlink" title="autoindex"></a><code>autoindex</code></h4><p>​    **<code>autoindex</code>**：用来显示网站某个目录的列表文件，默认是关闭的，这个指令一般是在我们将 <code>Nginx</code> 作为文件服务器提供用户浏览器下载时才会使用的。这个指令来自于模块 <code>ngx_http_autoindex_module</code> ，不过默认已经被编译到 <code>Nginx</code> 当中。基本用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">autoindex</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">autoindex</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>我们可以看下启用和关闭该参数的影响，如下：</p>
<p>不启用 <code>autoindex</code> ：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /download/</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/;</span><br><span class="line">        <span class="attribute">limit_rate</span>	<span class="number">100k</span>;</span><br><span class="line">        <span class="attribute">autoindex</span>	<span class="literal">off</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>浏览器访问：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212145934807.png" alt="image-20210212112855698" style="zoom:25%;" />

<p>看下报错日志：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212153048309.png" alt="image-20210212113029566"></p>
<p>可以看到，提示没有权限读取目录索引，此时我们加上 <code>autoindex on;</code> 参数，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /download/</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/;</span><br><span class="line">        <span class="attribute">limit_rate</span>	<span class="number">100k</span>;</span><br><span class="line">        <span class="attribute">autoindex</span>	<span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时再次访问下 <code>URL</code> 如下：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212113029566.png" alt="image-20210212113346166" style="zoom:25%;" />

<hr>
<p>顺便再说下 <code>charset</code> ，设置字符集。</p>
<h4 id="charset"><a href="#charset" class="headerlink" title="charset"></a><code>charset</code></h4><p>​    **<code>charset</code>**：设置响应头字符集类型，主要是添加响应码报文中的 <code>Content-Type</code> 字段，基本用法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">charset</span>  chatset | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">charset</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span>, if in <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>可以看下我们请求网站的头部信息（我们在 <code>server</code> 段中配置了 <code>charset utf-8;</code>）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I  http://a.host.com</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Fri, 12 Feb 2021 03:44:39 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 95</span><br><span class="line">Last-Modified: Thu, 11 Feb 2021 06:49:44 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;6024d388-5f&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Content-Type: text/html; charset=utf-8</code></p>
<blockquote>
<p><strong><code>Nginx</code> 作为文件服务器的知识补充：</strong></p>
<ol>
<li><p><strong>希望再浏览器读取无后缀名的文件</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ /download/([^\.]+)$</span> &#123;</span><br><span class="line">    <span class="attribute">root</span>	/data/nginx/domain/test;</span><br><span class="line">    <span class="attribute">add_header</span>	Content-Type text/plain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会给所有 <code>download</code> 目录下，所有无后缀名的文件添加头部信息，该头部信息会让 <code>Nginx</code> 以文本方式读取该文件。</p>
</li>
<li><p><strong>希望某些文件不打开，只下载</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> <span class="regexp">~ (.*)\.txt</span> &#123;</span><br><span class="line">    <span class="attribute">add_header</span> Content-Disposition <span class="string">&quot;attachment;&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>	/data/nginx/domain/test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时就会匹配所有 <code>.txt</code> 类型文件，并且将其修改为附件类型，这样 <code>Nginx</code> 就不会读取该文件，而是直接下载。</p>
<p>除此之外，你还能想到什么样的方式？</p>
<p>提示 **<code>/etc/nginx/mime.types</code>**。</p>
</li>
</ol>
</blockquote>
<hr>
<h3 id="3-Nginx-HTTP-访问模块"><a href="#3-Nginx-HTTP-访问模块" class="headerlink" title="3. Nginx HTTP 访问模块"></a>3. <code>Nginx HTTP</code> 访问模块</h3><p>​    在 <code>Nginx</code> 中我们可以非常简单的实现访问限制，所使用的模块时 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_access_module.html"><code>ngx_http_access_module</code></a>这个模块中的指令非常少，只有 <code>allow</code> 和 <code>deny</code> ，如下：</p>
<p><strong>【<code>allow</code> 指令基本语法】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">syntax: <span class="attribute">allow</span> address | CIDR | unix: | all;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span>, limit_except</span><br></pre></td></tr></table></figure>

<p><strong>【<code>deny</code> 指令基本语法】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">deny</span> address | CIDR | unix: | all;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span>, limit_except</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果我们不指定 <code>allow</code> 或者 <code>deny</code>  是不做任何限制的，如果我们制定了条件，则从上往下匹配，一旦匹配到则直接应用，不会再往下继续查找匹配。</p>
<p>如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /download/</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx;</span><br><span class="line">        <span class="attribute">autoindex</span>	<span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">limit_rate</span>	<span class="number">100k</span>;</span><br><span class="line">        <span class="attribute">deny</span>		<span class="number">10.4.7.101</span>;</span><br><span class="line">        <span class="attribute">allow</span>		<span class="number">10.4.7.0</span>/<span class="number">24</span>;</span><br><span class="line">        <span class="attribute">deny</span>		all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我通过客户端 <code>10.4.7.101</code>  进行访问，如下：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212111555202.png" alt="image-20210212145141048" style="zoom:25%;" />

<p>因为直接匹配到 <code>deny 10.4.7.101</code> ，所以直接拒绝。我再通过 <code>10.4.7.102</code> 来访问就是正常的，我们可以是一个 <code>allow</code> 和 <code>deny</code> 来基于用户地址来进行访问限制。</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212110832052.png" alt="image-20210212145934807" style="zoom:25%;" />

<hr>
<h3 id="4-Nginx-HTTP-认证模块"><a href="#4-Nginx-HTTP-认证模块" class="headerlink" title="4. Nginx HTTP 认证模块"></a>4. <code>Nginx HTTP</code> 认证模块</h3><p>​    在 <code>Nginx</code> 中常用的访问控制模块还有 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_auth_basic_module.html"><code>ngx_http_auth_basic_module</code></a>，该模块不同于 <code>ngx_http_access_module</code> ，它是基于用户名密码的限制方式，只有在我们输入了正确的用户名密码之后才能够访问。这个模块也比较简单，只有两个指令，如下：</p>
<p><strong>【auth_basic指令基本用法】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">auth_basic</span> string | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">auth_basic</span>	<span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span>, limi_except</span><br></pre></td></tr></table></figure>

<p>即永安里指定是否启用 <code>HTTP Basic Authentication</code> 协议，默认不启用。其中 <code>auth_basic</code> 后面的字符串会在某些浏览器的加密框上显示。</p>
<p><strong>【auth_basic_user_file 指定 用户名/密码 文件】</strong></p>
<p>基本用法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">auth_basic_user_file</span> file;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span>, limit_except</span><br></pre></td></tr></table></figure>

<p>密码文件格式如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#comment</span><br><span class="line">name1:password1</span><br><span class="line">name2:password2:comment</span><br><span class="line">name3:password3</span><br></pre></td></tr></table></figure>

<p>用户名是明文，密码使用密文，可以使用 <code>htpasswd</code> （由 <code>httpd-tools</code> 提供）或者 <code>openssl passwd</code> 创建，我们来做个演示。</p>
<p>服务端配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx/domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /download/</span> &#123;</span><br><span class="line">        <span class="attribute">root</span>		/data/nginx;</span><br><span class="line">        <span class="attribute">autoindex</span>	<span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">limit_rate</span>	<span class="number">100k</span>;</span><br><span class="line">        <span class="attribute">auth_basic</span>	<span class="string">&quot;Auth Zone&quot;</span>;</span><br><span class="line">        <span class="attribute">auth_basic_user_file</span>	/etc/nginx/conf.d/.htpasswd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>【使用 <code>htpasswd</code> 创建密码】</strong></p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@a conf.d]# htpasswd -cmb .htpasswd tom <span class="number">123456</span></span><br><span class="line">Adding password <span class="keyword">for</span> user tom</span><br><span class="line">[root@a conf.d]# htpasswd -mb .htpasswd jerry <span class="number">123456</span></span><br><span class="line">Adding password <span class="keyword">for</span> user jerry</span><br></pre></td></tr></table></figure>

<p><code>htpasswd</code> 参数说明：</p>
<p><code>-m</code>：用来指定 <code>md5</code> 加密算法；</p>
<p><code>-c</code>：表示创建新文件，只有在第一次创建时使用；</p>
<p><code>-b</code>：在命令行中输入密码，即用户名密码一起输入，这样不太安全，建议不使用 <code>-b</code> ，根据命令行提示输入密码；</p>
<p>此时我们就可以进行访问验证了，如下：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212155346670.png" alt="image-20210212153048309" style="zoom:25%;" />

<p>此时，必须输入正确的用户名密码之后才可以访问。</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210206153806134.png" alt="image-20210212153317273" style="zoom:25%;" />

<p>如果不想使用 <code>htpasswd</code> ，还可以使用 <code>openssl</code> 创建。</p>
<p><strong>【使用 <code>openssl</code> 创建密码】</strong></p>
<p>使用方法比较简单，同样我们使用 <code>md5</code> 加密，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@a conf.d]# openssl passwd -h</span><br><span class="line">Usage: passwd [options] [passwords]</span><br><span class="line">where options are</span><br><span class="line">-crypt             standard Unix password algorithm (default)</span><br><span class="line">-1                 MD5-based password algorithm</span><br><span class="line">-apr1              MD5-based password algorithm, Apache variant</span><br><span class="line">-salt string       use provided salt</span><br><span class="line">-in file           read passwords from file</span><br><span class="line">-stdin             read passwords from stdin</span><br><span class="line">-noverify          never verify when reading password from terminal</span><br><span class="line">-quiet             no warnings</span><br><span class="line">-table             format output as table</span><br><span class="line">-reverse           switch table columns</span><br></pre></td></tr></table></figure>

<p>假如我们设置密码为 <code>123456</code> ，可以这样做：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@a conf.d]# openssl passwd -1 123456</span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash">1$ylbtqarg<span class="variable">$Hv9h9Bfsdzo6heXuoI84s</span>.</span></span><br></pre></td></tr></table></figure>

<p>获得的字符串即是 <code>123456</code> 的 <code>md5</code> 加密后的密文，此时我们给定用户名，使用这个密码添加到密码文件中即可，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@a conf.d]# echo &#x27;amos:$1$ylbtqarg$Hv9h9Bfsdzo6heXuoI84s.&#x27; &gt;&gt; .htpasswd</span><br></pre></td></tr></table></figure>

<p><strong>一定注意 <code>echo</code> 时不要使用双引号，要使用单引号，最好手动复制写到文件中。</strong></p>
<p>现在我们就可以通过 <code>amos</code> 用户， 和 <code>123456</code> 密码进行访问。</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212155445865.png" alt="image-20210212155346670" style="zoom:25%;" />

<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210216173956853.png" alt="image-20210212155445865" style="zoom:25%;" />

<p>同样是没有问题的。</p>
<hr>
<h3 id="5-Nginx-HTTP-rewrite-模块"><a href="#5-Nginx-HTTP-rewrite-模块" class="headerlink" title="5. Nginx HTTP rewrite 模块"></a>5. <code>Nginx HTTP rewrite</code> 模块</h3><p>​    我们在日常 <code>web</code> 网站维护中，经常会出现这样的情况，比如我们曾经使用某个域名，后来又买了新的域名，打算迁移到新域名，但是很多老用户可能还是习惯于使用老域名，此时我们就可以通过 <code>rewrite</code> 进行地址重写，或者叫做重定向。</p>
<p>​    在 <code>Nginx</code> 中可以通过 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_rewrite_module.html"><code>ngx_http_rewrite_module</code></a> 模块来实现地址重写功能（当然，该模块不单是实现地址重写）。所谓地址重写就是将用户请求的 <code>URI</code> 基于 <code>PCRE</code> 正则表达式进行重定向替换。很多同学在这犯迷糊，主要原因一是 <code>flag</code> 标签含义不清楚，另外一个是正则表达式玩的不熟悉。</p>
<p>在 <code>ngx_http_rewrite_module</code> 模块中，指令不多，我们逐一进行介绍。</p>
<h4 id="break"><a href="#break" class="headerlink" title="break"></a><code>break</code></h4><p>​    **<code>break</code>**：该指令用于停止处理当前这一轮的 <code>ngx_http_rewrite_module</code> 指令集。需要注意：当 <code>break</code> 用在 <code>location</code> 段中，除了会终止当前 <code>location</code> 的 <code>rewrite_module</code> 指令集之外，也不在进行其他 <code>location</code> 匹配。单个 <code>break</code> 指令与在 <code>rewrite</code> 标志位中的 <code>break</code> 指令含义相同。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: break;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span>, if</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Stops processing the current set of <code>ngx_http_rewrite_module</code> directives.</p>
<p>If a directive is specified inside the <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html%23location">location</a>, further processing of the request continues in this location.</p>
<p>即：停止执行当前 <code>ngx_http_rewrite_module</code> 指令集中的其他指令，如果在 <code>location</code>  指令中还有其他 <code>非 rewrite_module</code> 指令，则会继续执行该 <code>location</code> 段内的其他指令。</p>
</blockquote>
<h4 id="return"><a href="#return" class="headerlink" title="return"></a><code>return</code></h4><p>​    <strong><code>return</code><strong>：停止处理并返回指定 <code>code</code> 给客户端，也就是程序一但遇到 <code>return</code> 则直接将响应数据返回给客户端，不再进行余下规则的匹配处理。</strong>如果返回非标准的状态码 <code>444</code> 可以直接关闭连接而不返回响应头。</strong>如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@a conf.d]# curl a.host.com/444.html</span><br><span class="line">curl: (52) Empty reply from server</span><br><span class="line">[root@a conf.d]# curl -I a.host.com/444.html</span><br><span class="line">curl: (52) Empty reply from server</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>/444.html</code> 的配置段需要提前配置好，这里不再赘述</p>
<p>一旦 <code>return 444</code> 返回了 <code>text | URL</code> ，此时都会给出响应头。</p>
</blockquote>
<p><code>return</code> 的基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">return</span> code [text];</span><br><span class="line">		<span class="attribute">return</span> code URL;</span><br><span class="line">		<span class="attribute">return</span> URL;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span>, if</span><br></pre></td></tr></table></figure>

<p>可以看到我们可以：</p>
<ul>
<li>直接返回 <code>http code</code> 并且顺便加上文本信息，支持的 <code>code</code> 有：<code>204, 400, 402 - 406, 408, 410, 411, 413, 416, and 500 - 504</code> ；另外，也支持 <code>nginx</code> 特有代码 <code>444</code> ；</li>
<li>也可以返回重定向 <code>code + URL</code> ，支持的重定向代码有：<code>301, 302, 303, 307, 308</code> （对于 <code>307</code> 和 <code>308</code> 代码的出现请参考下方说明内容）；</li>
<li>亦或者直接返回 <code>URL</code> ，只有在使用 <code>302</code> 重定向代码时，可以省略代码参数；</li>
</ul>
<p>从 <code>0.8.42</code> 版开始，可以在指令中指定 **重定向的 <code>URL</code> ** （状态码为 <code>301, 302, 303, 307, 308</code>），或者指定 **响应体 <code>文本</code> ** （状态码为其他值）。响应体文本或重定向 <code>URL</code> 中可以包含变量。作为一种特殊情况，重定向 <code>URL</code> 可以简化当前 <code>server</code> 的本地 <code>URI</code> ，那么完整的重定向 <code>URL</code> 将按照请求协议（<code>$scheme</code>）、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html%23server_name_in_redirect">server_name_in_redirect</a> and <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html%23port_in_redirect">port_in_redirect</a> 指令的配置进行补全。</p>
<p>另外，对于 <code>302</code> 临时重定向，可以只写一个参数，即 <code>return URL</code> （省略 <code>code</code>），但是该 <code>URL</code> 必须以 <code>http</code> 、<code>https</code> 或者 <code>$scheme</code> 开始。</p>
<p>下面是 <code>return</code> 可以使用的 <code>code</code> 以及相关 <code>Nginx</code> 版本信息：</p>
<blockquote>
<p><code>Nginx 0.7.51</code> 及以前：<code>204, 400, 402 - 406, 408, 410, 411, 413, 416, and 500 - 504</code>；</p>
<p><code>Nginx versions 1.1.16 and 1.0.13</code> 及之后 <code>307</code> 才被作为重定向代码；而 <code>308</code> 被认为重定向代码则是在 <code>Nginx 1.13.0</code> 版本及之后。</p>
</blockquote>
<p><strong>【重定向状态码说明】</strong></p>
<table>
<thead>
<tr>
<th>指令代码</th>
<th>协议支持</th>
<th>代码含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>301</code></td>
<td><code>http 1.0</code></td>
<td>永久重定向</td>
</tr>
<tr>
<td><code>302</code></td>
<td><code>http 1.0</code></td>
<td>临时重定向，禁止被缓存</td>
</tr>
<tr>
<td><code>303</code></td>
<td><code>http 1.1</code></td>
<td>临时重定向，允许改变请求方法，禁止被缓存</td>
</tr>
<tr>
<td><code>307</code></td>
<td><code>http 1.1</code></td>
<td>临时重定向，不允许改变请求方法，禁止被缓存</td>
</tr>
<tr>
<td><code>308</code></td>
<td><code>http 1.1</code></td>
<td>永久重定向，不允许改变方法</td>
</tr>
<tr>
<td><code>444</code></td>
<td><code>Nginx 自定义</code></td>
<td>关闭连接</td>
</tr>
</tbody></table>
<p><strong>【code + text】</strong></p>
<p>使用普通 <code>HTTP Code</code> 响应码，即不使用重定向代码。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">404</span> <span class="string">&#x27;Not Found Your IP：<span class="variable">$remote_addr</span>&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>return</code> 中可以使用变量</p>
</blockquote>
<p>当我们请求文件时：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210221201946847.png" alt="image-20210213202952810" style="zoom:33%;" />

<p><strong>【Code + URL/URI】</strong></p>
<p>使用重定向代码加上 <code>URL/URI</code> 来实现重定向跳转。（注意：使用重定向代码 <code>302</code> 也可以实现下面的实验，<code>302</code> 比其他重定向代码特殊在它可以不用加 <code>Code</code> ，也就是仅 <code>URL</code> 参数就能实现跳转）</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log;</span><br><span class="line">    <span class="section">location</span> /a.html &#123;</span><br><span class="line">        <span class="attribute">return</span>		<span class="number">301</span> /<span class="number">1</span>.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看下响应头部：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -I http://a.host.com/a.html</span></span><br><span class="line">HTTP/1.1 301 <span class="attribute">Moved</span> Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Fri, <span class="number">03</span>, Apr <span class="number">2021</span> <span class="number">05</span>:<span class="number">32</span>:<span class="number">03</span> GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">162</span></span><br><span class="line">Location: http://a.host.com/1.html</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>即：本地路径我们可以通过 <code>URI</code> 来实现跳转。如果非本地路径，必须填写完整 <code>URL</code>，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log;</span><br><span class="line">    <span class="section">location</span> /a.html &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">301</span>	http://www.baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/a.html</span></span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Fri, 03, Apr 2021 05:32:03 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Location: http://www.baidu.com</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：如果我们使用浏览器进行测试，需要先清空掉浏览器缓存，否则会一直指向上一次的重定向地址，即 <code>http://a.host.com/1.html</code>，至于为什么会产生这样的情况，与 <code>301</code> 永久重定向代码有关。</p>
</blockquote>
<p><strong>【仅使用URL参数】</strong></p>
<p>当我们使用 <code>302</code> 临时重定向时，可以支持仅使用一个 <code>URL</code> 参数，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log;</span><br><span class="line">    <span class="section">location</span> /a.html &#123;</span><br><span class="line">        <span class="attribute">return</span>		http://b.host.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求报文测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/a.html</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Tue, 16 Feb 2021 09:01:14 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 145</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://b.host.com</span><br></pre></td></tr></table></figure>

<p>可以看到响应码为 <code>302</code>，且跳转的 <code>location</code> 为我们在服务端指定的 <code>http://b.host.com</code>。以上是关于 <code>return</code> 参数的一些用法和注意点。</p>
<hr>
<h4 id="if"><a href="#if" class="headerlink" title="if"></a><code>if</code></h4><p>​    **<code>if</code>**：计算指定的 <code>condition</code> (条件)值。如果为真，执行定义在大括号中的 <code>rewrite</code> 模块指令，并将 <code>if</code> 指令中的配置指定给请求。<code>if</code> 指令会从上一层配置中继承配置。基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">if</span> (condition) &#123; ... &#125;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>匹配条件 <code>condition</code> 可以是下列任意一种：</p>
<ul>
<li>变量名；如果变量值为空或者是以 “<code>0</code>“ 开始的字符串，则条件为假；</li>
<li>使用 “<code>=</code>“ 和 “<code>!=</code>” 运算符比较变量和字符串；</li>
<li>使用 “<code>~</code>“ （大小写敏感）或“<code>~*</code>” （大小写不敏感）和 “<code>!~</code>“ （大小写敏感）或”<code>!~*</code>“（大小写不敏感）运算符匹配变量和正则表达式。正则表达式可以包含匹配组，匹配结果后续可以使用变量 <code>$1</code>..<code>$9</code>引用。如果正则表达式中包含字符“<code>&#125;</code>” 或者 “<code>;</code>”，整个表达式应该被包含在单引号或双引号的引用中。</li>
<li>使用 “<code>-f</code>“ 和 “<code>!-f</code>”运算符检查文件是否存在；</li>
<li>使用 “<code>-d</code>“ 和 “<code>!-d</code>”运算符检查目录是否存在；</li>
<li>使用 “<code>-e</code>“ 和 “<code>!-e</code>”运算符检查文件、目录或符号链接是否存在；</li>
<li>使用 “<code>-x</code>“ 和 “<code>!-x</code>”运算符检查可执行文件；</li>
</ul>
<p>如下为 <code>if</code> 的示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">if</span> (<span class="variable">$http_user_agent</span> <span class="regexp">~ MSIE)</span> &#123;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> /msie/<span class="variable">$1</span> breadk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$http_cookie</span> <span class="regexp">~* &quot;id=([^</span>;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">    <span class="attribute">set</span> <span class="variable">$id</span> <span class="variable">$1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$request_method</span> = POST) &#123;</span><br><span class="line">    <span class="attribute">return</span>	<span class="number">405</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$slow</span>) &#123;</span><br><span class="line">    <span class="attribute">limit_rate</span> <span class="number">10k</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">if</span> (<span class="variable">$invalid_referer</span>) &#123;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意，<strong>如果 <code>condition</code> 中含有运算符，在运算符的两次一定要有空格。</strong>关于更多的 <code>if</code> 相关示例，我们将在生产实战环境与大家做响应的演示。</p>
<hr>
<h4 id="rewrite-log"><a href="#rewrite-log" class="headerlink" title="rewrite_log"></a><code>rewrite_log</code></h4><p>​    <code>rewrite_log</code>：用来设置是否开启 <code>rewrite</code> 日志功能，开启该功能后，当发生 <code>rewrite</code> 规则时，将在日志中生成重写日志，即匹配了哪个重写条件等信息。开启之后，默认会将日志写入到 <code>error_log</code> 中，默认的日志级别为：<code>notice</code> ，基本用法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">rewrite_log</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">rewrite_log</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span>, if</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意：<code>error_log</code> 默认级别为 <code>error</code> ，这个级别是不会记录 <code>rewrite_log</code> 的 <code>notice</code> 级别日志的，需要我们修改 <code>error_log</code> 级别为 <code>info</code> 。</p>
</blockquote>
<p>比如我们上面的设置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> /a.html &#123;</span><br><span class="line">        <span class="attribute">return</span>		http://www.baidu.com;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就会把重写日志写入到 <code>/var/log/nginx/a-error.log</code> ，此时 <code>rewrite</code> 产生的日志级别为 <code>notice</code> 。稍后我们会在介绍 <code>rewrite</code> 参数时，使用到该指令，用来帮助大家理解重写规则。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a><code>set</code></h4><p><code>set</code> ：为指定变量 <code>variable</code> 设置变量值 <code>value</code> 。变量值 <code>value</code> 可以包含文本、变量或者它们的组合。我们一般会结合 <code>if</code> 指令来设置参数，然后完成某些特定操作，稍后会在实战案例中演示。</p>
<p>基本用法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">set</span> <span class="variable">$variable</span> value;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, location. if</span><br></pre></td></tr></table></figure>

<h4 id="uninitialized-variable-warn"><a href="#uninitialized-variable-warn" class="headerlink" title="uninitialized_variable_warn"></a><code>uninitialized_variable_warn</code></h4><p>​    <code>uninitialized_variable_warn</code>：控制是否记录变量未初始化的警告到日志，默认开启，一般不用做额外设置，保持默认即可。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">uninitialized_variable_warn</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">uninitialized_variable_warn</span> <span class="literal">on</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span>, if</span><br></pre></td></tr></table></figure>

<h4 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a><code>rewrite</code></h4><p>接下来，我们介绍该模块中最重要的指令：</p>
<p><code>rewrite</code>：用来根据正则表达式匹配 <code>URI</code>，然后替换成我们期望的 <code>URI</code> 或者 <code>URL</code>，基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">rewrite</span> regex replacement [flag];</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span>, if</span><br></pre></td></tr></table></figure>

<p>如果指定的正则表达式能匹配 <code>URI</code> ，此 <code>URI</code> 将被替换成 <code>replacement</code> 这个新的 <code>URI</code> 。需要注意的是，如果我们设定的匹配规则有问题，可能会出现循环匹配，<code>Nginx</code> 默认最多运行循环十次，否则会以 <code>500</code> 错误中断连接。</p>
<ul>
<li><strong>注意1</strong>：如果匹配了 <code>rewrite</code> 指令，这些指令按其在配置文件中出现的顺序执行。我们可以通过指定 <code>flag</code> 终止后续指令的执行。</li>
<li><strong>注意2</strong>：如果 <code>replacement</code> 的字符串以 “<code>http://</code>“、”<code>https://</code>“或者“<code>$schema</code>” 开头，<code>nginx</code> 将结束执行过程，并返回给客户端一个 <code>302</code> 重定向。</li>
</ul>
<p>可以使用的 <code>flag</code> 参数及含义如下：</p>
<ul>
<li><code>last</code> ：停止执行当前这一轮以及后续 <code>location</code> 的 <code>ngx_http_rewrite_module</code> 指令集，然后利用匹配改变后 <code>URI</code> 重新查找匹配所有 <code>location</code> ，因此不建议在 <code>location</code> 中使用 <code>last</code> 标志位；</li>
<li><code>break</code> ：停止执行当前这一轮的 <code>ngx_http_rewrite_module</code> 指令集（但是在该 <code>location</code> 中的非 <code>ngx_http_rewrite_module</code> 指令会被执行），也不会再查找其他的 <code>location</code> 规则；</li>
<li><code>redirect</code>：在 <code>replacement</code> 字符串未以 “<code>http://</code>“、”<code>https://</code>“或者“<code>$schema</code>”开头时，使用返回状态码为 <code>302</code> 的临时重定向；</li>
<li><code>permanent</code>：返回状态码为 <code>301</code> 的永久重定向。</li>
</ul>
<p>下面我们将通过几个实验实例，来吧这个几个参数功能描述清楚：</p>
<p><strong>【未指定 <code>flag</code> 时，<code>rewrite</code>规则制定顺序】</strong></p>
<p>创建服务端配置文件，以及相应的 <code>html</code> 文件，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">1</span>.html /<span class="number">2</span>.html;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">2</span>.html /<span class="number">3</span>.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">2</span>.html /a.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">3</span>.html /b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要在 <code>/data/nginx/domian</code> 下创建好相应的 <code>html</code> 文件，并写入内容以示区别。比如 <code>1.html</code> 文件中内容为 <code>This is 1.html</code> ，而 <code>2.html</code> 中的文件内容为 <code>This is 2.html</code> 。现在我们来进行请求测试：</p>
<p>请求：<code>http://a.host.com/1.html</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl http://a.host.com/1.html</span></span><br><span class="line">This is b.html</span><br></pre></td></tr></table></figure>

<p>我们开启了重写日志，可以看下重写路径，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 &quot;/1.html&quot; matches &quot;/1.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 rewritten data: &quot;/2.html&quot;, args: &quot;&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 &quot;/2.html&quot; matches &quot;/2.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 rewritten data: &quot;/3.html&quot;, args: &quot;&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 &quot;/3.html&quot; matches &quot;/3.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 rewritten data: &quot;/b.html&quot;, args: &quot;&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 &quot;/1.html&quot; does not match &quot;/b.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:33:07 [notice] 2381#0: *31 &quot;/2.html&quot; does not match &quot;/b.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br></pre></td></tr></table></figure>

<p>我们可以看下重写路径，大致如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.html →  2.html → 3.html → b.html（第一轮重写完成）→ 查找符合的location，于是匹配到location / 下的1.html（不匹配）→ 查找 location / 下的 2.html（不匹配）</span><br></pre></td></tr></table></figure>

<p>可以得出 <strong>结论1：在未指定 <code>flag</code> 时，会顺序匹配 <code>rewrite</code> 规则，并且新改写的 <code>URL</code> 规则会重新进行匹配。</strong></p>
<p><strong>【指定 <code>break</code> 标志位，<code>rewrite</code> 执行过程】</strong></p>
<p>服务端设置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">1</span>.html /<span class="number">2</span>.html <span class="literal">break</span>;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">2</span>.html /<span class="number">3</span>.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">2</span>.html /a.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">3</span>.html /b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210216173624576.png" alt="image-20210216173624576" style="zoom:25%;" />

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl http://a.host.com</span></span><br><span class="line">This is 2.html</span><br></pre></td></tr></table></figure>

<p>看下响应首部：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/1.html</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Tue, 16 Feb 2021 09:36:43 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 15</span><br><span class="line">Last-Modified: Tue, 16 Feb 2021 09:26:03 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;602b8fab-f&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>响应码为 <code>200</code>。</p>
<p>查看重写日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021/02/16 17:37:06 [notice] 2419#0: *36 &quot;/1.html&quot; matches &quot;/1.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:37:06 [notice] 2419#0: *36 rewritten data: &quot;/2.html&quot;, args: &quot;&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com</span><br></pre></td></tr></table></figure>

<p>可以看懂仅发生了一次重写，即 <code>location /</code> 下面的 <code>rewrite 1.html 2.html</code> ，此时 <code>Nginx</code> 就会直接查找文件 <code>$document_root/2.html</code> ，如果有则响应，没有则给出 <code>404</code> 响应。没有在执行后面的 <code>location</code> 规则。</p>
<p><strong>结论2：在指定 <code>flag</code> 为 <code>break</code> 时，会顺序匹配 <code>rewrite</code> 规则，一旦匹配到则终止后面的 <code>rewrite_module</code> 相关指令，并且不再检查后面的 <code>location</code> 规则。</strong></p>
<p>修改服务端配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">1</span>.html /<span class="number">2</span>.html <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">2</span>.html /<span class="number">3</span>.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">2</span>.html /a.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">3</span>.html /b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求：**<code>http://a.host.com/1.html</code>**</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210212153317273.png" alt="image-20210216173956853" style="zoom:25%;" />

<p>看下请求首部：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/1.html</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Fri, 03 Apr 2021 10:21:51 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 15</span><br><span class="line">Last-Modified: Fri, 03 Apr 2021 04:59:05 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5e86c284-f&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>并未发生了重定向，响应 <code>URL</code> 为 <code>http://a.host.com/b.html</code>，我们再看下重写流程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2021/02/16 17:38:59 [notice] 2448#0: *38 &quot;/1.html&quot; matches &quot;/1.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:38:59 [notice] 2448#0: *38 rewritten data: &quot;/2.html&quot;, args: &quot;&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:38:59 [notice] 2448#0: *38 &quot;/2.html&quot; matches &quot;/2.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:38:59 [notice] 2448#0: *38 rewritten data: &quot;/a.html&quot;, args: &quot;&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:38:59 [notice] 2448#0: *38 &quot;/1.html&quot; does not match &quot;/a.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:38:59 [notice] 2448#0: *38 &quot;/2.html&quot; does not match &quot;/a.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br></pre></td></tr></table></figure>

<p>重写流程如下：</p>
<ul>
<li>请求 <code>1.html</code> 匹配到 <code>location /</code> 下的 <code>rewrite 1.html 2.html last;</code> 规则，重写 <code>URI</code> 为 <code>2.html</code> ，遇到 <code>last</code> 标志位，终止该 <code>location</code> 下的所有 <code>rewrite</code> 指令；</li>
<li>使用新生成的 <code>URI</code> 即 <code>2.html</code> 重新自上往下匹配，此时匹配到 <code>location /2.html</code> 配置段下面的 <code>rewrite /2.html a/.html</code> ，此时修改 <code>URI</code> 为 <code>a.html</code>；</li>
<li>使用新生成的 <code>a.html</code> 重新自上往下匹配，匹配到 <code>location /</code> 配置段，不过该配置段中的 <code>rewrite /1.html /2.html last</code> 与 <code>rewrite /2.html /3.html</code> 规则均不满足，因此使用 <code>a.html</code> 页面进行响应；  </li>
</ul>
<p><strong>结论3：在指定 <code>flag</code> 为 <code>last</code> 时，同样会顺序匹配 <code>rewrite</code> 规则，一旦匹配到，则终止该 <code>location</code> 段内以及后续的 <code>location</code> 段中的 <code>rewrite_module</code> 相关指令，并且会使用新的 <code>URI</code> 从新开始一条条的再匹配。</strong></p>
<hr>
<p><strong>【当 <code>rewrite</code> 与 <code>return</code> 指令同时出现】</strong></p>
<p>先来看下与 <code>break</code> 一起使用时，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">1</span>.html /<span class="number">2</span>.html <span class="literal">break</span>;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">2</span>.html /<span class="number">3</span>.html;</span><br><span class="line">        <span class="attribute">return</span>  <span class="number">200</span> <span class="string">&quot;It&#x27;s OK!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">2</span>.html /a.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">3</span>.html /b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求：<code>http://a.host.com/1.html</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl http://a.host.com/1.html</span></span><br><span class="line">This is 2.html</span><br></pre></td></tr></table></figure>

<p>且重写日志与未添加 <code>return</code> 指令时一样，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2021/02/16 17:43:24 [notice] 2497#0: *40 &quot;/1.html&quot; matches &quot;/1.html&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br><span class="line">2021/02/16 17:43:24 [notice] 2497#0: *40 rewritten data: &quot;/2.html&quot;, args: &quot;&quot;, client: 10.4.7.1, server: a.host.com, request: &quot;GET /1.html HTTP/1.1&quot;, host: &quot;a.host.com&quot;</span><br></pre></td></tr></table></figure>

<p>此时我们调整下 <code>return</code> 与 <code>break</code> 的顺序，再次测试：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">2</span>.html /<span class="number">3</span>.html;</span><br><span class="line">        <span class="attribute">return</span>  <span class="number">200</span>		<span class="string">&quot;It&#x27;s OK!&quot;</span>;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">1</span>.html	/<span class="number">2</span>.html <span class="literal">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">2</span>.html /a.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="number">3</span>.html /b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求页面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl http://a.host.com</span></span><br><span class="line">It&#x27;s OK!</span><br></pre></td></tr></table></figure>

<p><strong>结论4：当 <code>rewrite</code> 与 <code>return</code> 同时出现时，按照顺序执行。因为 <code>return</code> 与 <code>rewrite</code> 的 <code>break</code> 和 <code>last</code> 标志位均有中断 <code>rewrite_module</code> 后续指令的功能，所以谁在前面就会导致后面的 <code>rewrite_module</code> 指令无法再执行。</strong></p>
<p>试想一下，当服务端重写规则如下时，请求 <code>http://a.host.com/1.html</code> 响应的网页分别是什么？</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">1</span>.html  /<span class="number">2</span>.html <span class="literal">last</span>;  <span class="comment">#last中断</span></span><br><span class="line">    <span class="attribute">rewrite</span>	 /<span class="number">2</span>.html  /<span class="number">3</span>.html;</span><br><span class="line">    <span class="attribute">return</span>   <span class="number">200</span>      <span class="string">&quot;It&#x27;s OK!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">2</span>.html /a.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">    <span class="attribute">rewrite</span> /<span class="number">3</span>.html /b.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<code>It&#39;s OK!</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">1</span>.html  /<span class="number">2</span>.html <span class="literal">last</span>;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">2</span>.html  /<span class="number">3</span>.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">2</span>.html  /a.html;</span><br><span class="line">    <span class="attribute">return</span>   <span class="number">200</span>      <span class="string">&quot;It&#x27;s OK!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">3</span>.html  /b.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<code>It&#39;s OK!</code></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">1</span>.html  /<span class="number">2</span>.html <span class="literal">last</span>;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">2</span>.html  /<span class="number">3</span>.html;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /<span class="number">2</span>.html &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">2</span>.html  /a.html <span class="literal">last</span>;</span><br><span class="line">    <span class="attribute">return</span>   <span class="number">200</span>      <span class="string">&quot;It&#x27;s OK!&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">    <span class="attribute">rewrite</span>  /<span class="number">3</span>.html  /b.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>答案：<code>a.html</code></p>
<p>如果能想明白，那么 <code>last</code> 与 <code>break</code> 标志位，以及 <code>return</code> 指令的执行顺序就搞清楚了。</p>
<p><strong>【<code>break</code> 与 <code>last</code> 是否会终止除了 <code>rewrite_module</code> 相关的指令】</strong></p>
<p>这里我编译安装了 <code>echo-nginx-module</code> 模块，这是一个第三方模块，稍后会在生产实战篇内容中介绍如何动态编译安装第三方模块。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>  /<span class="number">1</span>.html  /<span class="number">2</span>.html <span class="literal">last</span>;</span><br><span class="line">        <span class="attribute">rewrite</span>  /<span class="number">2</span>.html  /<span class="number">3</span>.html;</span><br><span class="line">        <span class="attribute">echo</span>     <span class="string">&quot;The first paragraph.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>  /<span class="number">3</span>.html  /b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl http://a.host.com/1.html</span></span><br><span class="line">The first paragraph.</span><br></pre></td></tr></table></figure>

<p>可以看到还是执行了 <code>echo</code> 模块指令，注意此时如果把 <code>last</code> 修改成 <code>break</code> 会得出同样的结果。所以我们可以得出的结论是：</p>
<p><strong><code>last</code> 与 <code>break</code> 标志位仅能终止 <code>rewrite_module</code> 相关指令，包括 <code>return</code> 。但是，<code>return</code> 指令会终止所有指令，包括非 <code>rewrite_module</code> 指令。</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span>	<span class="number">200</span>	<span class="string">&quot;Nothing will show you.&quot;</span>;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">1</span>.html	/<span class="number">2</span>.html <span class="literal">break</span>;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">2</span>.html	/<span class="number">3</span>.html;</span><br><span class="line">        <span class="attribute">echo</span> <span class="string">&quot;The first paragraph.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /<span class="number">3</span>.html &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="number">3</span>.html /b.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl http://a.host.com/1.html</span></span><br><span class="line">Nothing will show you.</span><br></pre></td></tr></table></figure>

<p><strong>【关于 <code>redirect （302）</code> 与 <code>permanent （301）</code> 标志位】</strong></p>
<p>​    需要注意：<code>redirect</code> 与 <code>permanent</code> 是重定向用户请求，一旦匹配到，则将匹配后的 <code>URL</code> 直接返回给用户，用户再次请求该 <code>URL</code> ，也会使用该 <code>URL</code> 进行重新匹配，同时响应码为重定向即 <code>301</code> 或者 <code>302</code> 。此时用户浏览器上显示的是重定向的 <code>URL</code> 。而 <code>break</code> 与 <code>last</code> 都是不会是重定向响应码的，且浏览器地址一直未变过，所有的重写数据都发生在 <code>Nginx</code> 服务内部。所以，你如果想让用户看到你的新网址，那么就是用重定向功能。</p>
<p><strong>一般情况下，如果 <code>replacement</code> 的字符串以 <code>http://</code> 、<code>https://</code> 或者 <code>$schema</code> 开头，<code>nginx</code> 将结束执行过程，并返回给客户端一个 <code>302</code> 重定向。</strong>也就是说，如果 <code>replacement</code> 是以 <code>http(s)://</code> 开头，我们就使用 <code>301</code> 或者 <code>302</code> 重定向，最常见的用法就是网站的 <code>http</code> 跳转到 <code>https</code>。比如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 07 Apr 2021 01:06:04 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 154</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://www.jd.com/</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">X-Trace: 302-1586221564158-0-0-0-0-0</span><br><span class="line">Strict-Transport-Security: max-age=360</span><br></pre></td></tr></table></figure>

<p>我们来看下 <code>redirect</code> 与 <code>permanent</code> 的简单用法，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">rewrite_log</span>		<span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_log</span>		/var/log/nginx/a-<span class="literal">error</span>.log <span class="literal">info</span>;</span><br><span class="line">    <span class="section">location</span> /redirect1 &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>	/<span class="literal">redirect</span>1(.*) <span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /redirect2 &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="literal">redirect</span>2(.*) <span class="variable">$1</span> <span class="literal">redirect</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /redirect3 &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="literal">redirect</span>3(.*) http://b.host.com<span class="variable">$1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> /redirect4 &#123;</span><br><span class="line">        <span class="attribute">rewrite</span> /<span class="literal">redirect</span>4(.*) http://b.host.com<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建所需的测试文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;This is a.host.com HomePage&quot;</span> &gt; /data/nginx/domain/index.html</span></span><br></pre></td></tr></table></figure>

<p>分别请求：<code>http://a.host.com/redirectX/index.html</code>，查看响应数据与响应头部：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl -I http://a.host.com/redirect1/index.html</span></span><br><span class="line">HTTP/1.1 301 <span class="attribute">Moved</span> Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Fri, <span class="number">03</span> Apr <span class="number">2020</span> <span class="number">12</span>:<span class="number">09</span>:<span class="number">44</span> GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: <span class="number">162</span></span><br><span class="line">Location: http://a.host.com/index.html</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p><strong>返回 <code>301</code> 永久重定向，因为我们设置了标志位 <code>permanent</code> 。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/redirect2/index.html</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Fri, 03 Apr 2020 12:10:44 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 138</span><br><span class="line">Location: http://a.host.com/index.html</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p><strong>返回 <code>302</code> 临时重定向，因为我们设置了标志位 <code>redirect</code> 。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/redirect3/index.html</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Fri, 03 Apr 2020 12:11:40 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://b.host.com/index.html</span><br></pre></td></tr></table></figure>

<p><strong>返回 <code>302</code> 临时重定向，因为重写规则是以 <code>http</code> 开头，默认使用 <code>302</code> 临时重定向。【注意此时我们没有设置 <code>flag</code> 】</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/redirect4/index.html</span></span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Fri, 03 Apr 2020:12:14:10 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://b.host.com/index.html</span><br></pre></td></tr></table></figure>

<p><strong>返回 <code>301</code> 永久重定向，因为我们在 <code>http</code> 的完整 <code>URL</code> 路径后设置了标志位 <code>permanent</code> 。</strong></p>
<p>以上这些就是 <code>redirect [flag]</code> 标志位的主要作用和简单用法，稍后我们会在生产实战课程中地这些进行综合应用的案例介绍。</p>
<hr>
<h3 id="6-Nginx-HTTP-log-模块"><a href="#6-Nginx-HTTP-log-模块" class="headerlink" title="6. Nginx HTTP log 模块"></a>6. <code>Nginx HTTP log</code> 模块</h3><p>​        我们在 <code>Nginx</code> 中使用 <code>ngx_http_log_module</code> 模块按指定的格式记录访问日志，该模块中涉及的参数不多，主要有 <code>access_log</code> 、<code>log_format</code> 、<code>open_log_file_cache</code> 三个，其中前面两个需要重点掌握，也是我们在日常使用中经常接触到的。</p>
<h4 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a><code>log_format</code></h4><p>​    **<code>log_format</code>**：指定日志格式，可以使用 <code>Nginx</code> 相关模块中的变量，基于语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">log_format</span> name [escape=default|json|<span class="literal">none</span>] string ...;</span><br><span class="line">Default: <span class="attribute">log_format</span> combined <span class="string">&quot;...&quot;</span></span><br><span class="line">Context: http</span><br></pre></td></tr></table></figure>

<p>注意：<code>log_format</code> 指令只能在 <code>http</code> 配置段中使用，默认的日志格式为 <code>combined</code> 。这是默认的 <code>combined</code> 定义格式：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> combined <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>]&#x27;</span></span><br><span class="line">					<span class="string">&#x27;&quot;<span class="variable">$request</span>&quot; <span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &#x27;</span></span><br><span class="line">					<span class="string">&#x27;&quot;<span class="variable">$http_referer</span>&quot; &quot;<span class="variable">$http_user_agent</span>&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>而我们安装的 <code>EPEL</code> 源中的 <code>Nginx</code> 定义的日志格式为 <code>main</code> ：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">				<span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">				<span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>生产上我们一般会根据自己需求去定制日志格式，比如希望通过代理服务器的用户访问主站后，默认的 <code>$remote_addr</code> 就会变成代理服务器的地址，我们一般会需要获取用户的真实地址。</p>
<p><code>log_format</code> </p>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><code>$remote_addr</code></td>
<td>客户端地址</td>
<td><code>219.227.111.255</code></td>
</tr>
<tr>
<td><code>$remote_user</code></td>
<td>客户端用户名称</td>
<td>—</td>
</tr>
<tr>
<td><code>$time_local</code></td>
<td>访问时间和时区</td>
<td><code>18/Jul/2014:17:00:01 +0800</code></td>
</tr>
<tr>
<td><code>$request</code></td>
<td>请求的URI和HTTP协议</td>
<td><code>“GET /article-10000.html HTTP/1.1”</code></td>
</tr>
<tr>
<td><code>$http_host</code></td>
<td>请求地址，即浏览器中你输入的地址（<code>IP</code>或域名）</td>
<td><code>a.host.com 198.98.120.87</code></td>
</tr>
<tr>
<td><code>$status</code></td>
<td><code>HTTP</code> 请求状态</td>
<td><code>200</code></td>
</tr>
<tr>
<td><code>$upstream_status</code></td>
<td><code>upstream</code> 状态</td>
<td><code>200</code></td>
</tr>
<tr>
<td><code>$body_bytes_sent</code></td>
<td>发送给客户端文件内容大小</td>
<td><code>1547</code></td>
</tr>
<tr>
<td><code>$http_referer</code></td>
<td><code>url</code> 跳转来源</td>
<td><code>https://www.google.com/</code></td>
</tr>
<tr>
<td><code>$http_user_agent</code></td>
<td>用户终端浏览器等信息</td>
<td><code>“Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;</code></td>
</tr>
<tr>
<td><code>$ssl_protocol</code></td>
<td><code>SSL</code> 协议版本</td>
<td><code>TLSv1</code></td>
</tr>
<tr>
<td><code>$ssl_cipher</code></td>
<td>交换数据中的算法</td>
<td><code>RC4-SHA</code></td>
</tr>
<tr>
<td><code>$upstream_addr</code></td>
<td>后台 <code>upstream</code> 的地址，即真正提供服务的主机地址</td>
<td><code>10.36.10.80:80</code></td>
</tr>
<tr>
<td><code>$request_time</code></td>
<td>整个请求的总时间</td>
<td><code>0.165</code></td>
</tr>
<tr>
<td><code>$upstream_response_time</code></td>
<td>请求过程中，<code>upstream</code> 响应时间</td>
<td><code>0.002</code></td>
</tr>
</tbody></table>
<p>正确设置 <code>nginx</code> 中 <code>remote_addr</code> 和 <code>x_forwarded_for</code> 参数</p>
<p><strong>什么是 <code>remote_addr</code>：</strong></p>
<p><code>remote_addr</code> 代表客户端的<code>IP</code>，但它的值不是由客户端提供的，而是服务端根据客户端的ip指定的，当你的浏览器访问某个网站时，假设中间没有任何代理，那么网站的 <code>web</code> 服务器（ <code>Nginx</code>，<code>Apache</code>等）就会把<code>remote_addr</code> 设为你的机器 <code>IP</code>，如果你用了某个代理，那么你的浏览器会先访问这个代理，然后再由这个代理转发到网站，这样 <code>web</code> 服务器就会把 <code>remote_addr</code> 设为这台代理机器的 <code>IP</code>。</p>
<p><strong>什么是 <code>x_forwarded_for</code>：</strong></p>
<p>正如上面所述，当你使用了代理时，<code>web</code> 服务器就不知道你的真实 <code>IP</code> 了，为了避免这个情况，代理服务器通常会增加一个叫做 <code>x_forwarded_for</code> 的头信息，把连接它的客户端 <code>IP</code> （即你的上网机器 <code>IP</code> ）加到这个头信息里，这样就能保证网站的 <code>web</code> 服务器能获取到真实 <code>IP</code></p>
<p><strong>使用 <code>HAProxy</code> 做反向代理时：</strong></p>
<p>通常网站为了支撑更大的访问量，会增加很多 <code>web</code> 服务器，并在这些服务器前面增加一个反向代理（如<code>HAProxy</code>），它可以把负载均匀的分布到这些机器上。你的浏览器访问的首先是这台反向代理，它再把你的请求转发到后面的 <code>web</code> 服务器，这就使得 <code>web</code> 服务器会把 <code>remote_addr</code> 设为这台反向代理的 <code>IP</code>，为了能让你的程序获取到真实的客户端 <code>IP</code>，你需要给 <code>HAProxy</code> 增加以下配置</p>
<p>  <code>option forwardfor</code></p>
<p>它的作用就像上面说的，增加一个 <code>x_forwarded_for</code> 的头信息，把客户端的 <code>ip</code> 添加进去，否则的话经测试为空值</p>
<p>如上面的日志格式所示：<code>$http_x_forwarded_for</code> 是客户端真实的IP地址，<code>$remote_addr</code> 是前端 <code>Haproxy</code> 的IP地址</p>
<p>或者：</p>
<p>当 <code>Nginx</code> 处在 <code>HAProxy</code> 后面时，就会把 <code>remote_addr</code> 设为 <code>HAProxy</code> 的 <code>IP</code>，这个值其实是毫无意义的，你可以通过 <code>nginx</code> 的 <code>realip</code> 模块，让它使用 <code>x_forwarded_for</code> 里的值。使用这个模块需要重新编译 <code>Nginx</code>，增加 <code>--with-http_realip_module</code> 参数</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure  --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module \                                --with-http_realip_module --http-log-path=/data/logs/nginx/access.log --error-log-path=/data/logs/nginx/error.log</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">set_real_ip_from</span> <span class="number">10.1.10.0</span>/<span class="number">24</span>;</span><br><span class="line"><span class="attribute">real_ip_header</span> X-Forwarded-For;</span><br></pre></td></tr></table></figure>

<p>上面的两行配置就是把从 <code>10.1.10</code> 这一网段过来的请求全部使用 <code>X-Forwarded-For</code> 里的头信息作为<code>remote_addr</code>，这样此时 <code>remote_addr</code> 就是客户端真实的<code>IP</code>地址</p>
<p><strong><code>X-Forwarded-For</code> 和 <code>X-Real-IP</code> 获取客户端的 <code>ip</code> 的区别：</strong></p>
<p>一般来说，<code>X-Forwarded-For</code> 是用于记录代理信息的，每经过一级代理(匿名代理除外)，代理服务器都会把这次请求的来源 <code>IP</code> 追加在 <code>X-Forwarded-For</code> 中 来自 <code>4.4.4.4</code> 的一个请求，<code>header</code> 包含这样一行 <code>X-Forwarded-For: 1.1.1.1, 2.2.2.2, 3.3.3.3</code> 代表 请求由 <code>1.1.1.1</code> 发出，经过三层代理，第一层是 <code>2.2.2.2</code>，第二层是 <code>3.3.3.3</code>，而本次请求的来源<code>IP 4.4.4.4</code>是第三层代理 而 <code>X-Real-IP</code>，一般只记录真实发出请求的客户端  <code>IP</code>，上面的例子，如果配置了 <code>X-Read-IP</code> ，将会是 <code>X-Real-IP: 1.1.1.1</code> 所以 ，如果只有一层代理，这两个头的值就是一样的 </p>
<h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">$<span class="attribute">args</span>                    <span class="comment">#请求中的参数值</span></span><br><span class="line"><span class="variable">$query_string</span>            <span class="comment">#同 $args</span></span><br><span class="line"><span class="variable">$arg_NAME</span>                <span class="comment">#GET请求中NAME的值</span></span><br><span class="line"><span class="variable">$is_args</span>                 <span class="comment">#如果请求中有参数，值为&quot;?&quot;，否则为空字符串</span></span><br><span class="line"><span class="variable">$uri</span>                     <span class="comment">#请求中的当前URI(不带请求参数，参数位于$args)，可以不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改，$uri不包含主机名，如&quot;/foo/bar.html&quot;。</span></span><br><span class="line"><span class="variable">$document_uri</span>            <span class="comment">#同 $uri</span></span><br><span class="line"><span class="variable">$document_root</span>           <span class="comment">#当前请求的文档根目录或别名</span></span><br><span class="line"><span class="variable">$host</span>                    <span class="comment">#优先级：HTTP请求行的主机名&gt;&quot;HOST&quot;请求头字段&gt;符合请求的服务器名.请求中的主机头字段，如果请求中的主机头不可用，则为服务器处理请求的服务器名称</span></span><br><span class="line"><span class="variable">$hostname</span>                <span class="comment">#主机名</span></span><br><span class="line"><span class="variable">$https</span>                   <span class="comment">#如果开启了SSL安全模式，值为&quot;on&quot;，否则为空字符串。</span></span><br><span class="line"><span class="variable">$binary_remote_addr</span>      <span class="comment">#客户端地址的二进制形式，固定长度为4个字节</span></span><br><span class="line"><span class="variable">$body_bytes_sent</span>         <span class="comment">#传输给客户端的字节数，响应头不计算在内；这个变量和Apache的mod_log_config模块中的&quot;%B&quot;参数保持兼容</span></span><br><span class="line"><span class="variable">$bytes_sent</span>              <span class="comment">#传输给客户端的字节数</span></span><br><span class="line"><span class="variable">$connection</span>              <span class="comment">#TCP连接的序列号</span></span><br><span class="line"><span class="variable">$connection_requests</span>     <span class="comment">#TCP连接当前的请求数量</span></span><br><span class="line"><span class="variable">$content_length</span>          <span class="comment">#&quot;Content-Length&quot; 请求头字段</span></span><br><span class="line"><span class="variable">$content_type</span>            <span class="comment">#&quot;Content-Type&quot; 请求头字段</span></span><br><span class="line"><span class="variable">$cookie_name</span>             <span class="comment">#cookie名称</span></span><br><span class="line"><span class="variable">$limit_rate</span>              <span class="comment">#用于设置响应的速度限制</span></span><br><span class="line"><span class="variable">$msec</span>                    <span class="comment">#当前的Unix时间戳</span></span><br><span class="line"><span class="variable">$nginx_version</span>           <span class="comment">#nginx版本</span></span><br><span class="line"><span class="variable">$pid</span>                     <span class="comment">#工作进程的PID</span></span><br><span class="line"><span class="variable">$pipe</span>                    <span class="comment">#如果请求来自管道通信，值为&quot;p&quot;，否则为&quot;.&quot;</span></span><br><span class="line"><span class="variable">$proxy_protocol_addr</span>     <span class="comment">#获取代理访问服务器的客户端地址，如果是直接访问，该值为空字符串</span></span><br><span class="line"><span class="variable">$realpath_root</span>           <span class="comment">#当前请求的文档根目录或别名的真实路径，会将所有符号连接转换为真实路径</span></span><br><span class="line"><span class="variable">$remote_addr</span>             <span class="comment">#客户端地址</span></span><br><span class="line"><span class="variable">$remote_port</span>             <span class="comment">#客户端端口</span></span><br><span class="line"><span class="variable">$remote_user</span>             <span class="comment">#用于HTTP基础认证服务的用户名</span></span><br><span class="line"><span class="variable">$request</span>                 <span class="comment">#代表客户端的请求地址</span></span><br><span class="line"><span class="variable">$request_body</span>            <span class="comment">#客户端的请求主体：此变量可在location中使用，将请求主体通过proxy_pass，fastcgi_pass，uwsgi_pass和scgi_pass传递给下一级的代理服务器</span></span><br><span class="line"><span class="variable">$request_body_file</span>       <span class="comment">#将客户端请求主体保存在临时文件中。文件处理结束后，此文件需删除。如果需要之一开启此功能，需要设置client_body_in_file_only。如果将次文件传 递给后端的代理服务器，需要禁用request body，即设置proxy_pass_request_body off，fastcgi_pass_request_body off，uwsgi_pass_request_body off，or scgi_pass_request_body off</span></span><br><span class="line"><span class="variable">$request_completion</span>      <span class="comment">#如果请求成功，值为&quot;OK&quot;，如果请求未完成或者请求不是一个范围请求的最后一部分，则为空</span></span><br><span class="line"><span class="variable">$request_filename</span>        <span class="comment">#当前连接请求的文件路径，由root或alias指令与URI请求生成</span></span><br><span class="line"><span class="variable">$request_length</span>          <span class="comment">#请求的长度 (包括请求的地址，http请求头和请求主体)</span></span><br><span class="line"><span class="variable">$request_method</span>          <span class="comment">#HTTP请求方法，通常为&quot;GET&quot;或&quot;POST&quot;</span></span><br><span class="line"><span class="variable">$request_time</span>            <span class="comment">#处理客户端请求使用的时间,单位为秒，精度毫秒； 从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</span></span><br><span class="line"><span class="variable">$request_uri</span>             <span class="comment">#这个变量等于包含一些客户端请求参数的原始URI，它无法修改，请查看$uri更改或重写URI，不包含主机名，例如：&quot;/cnphp/test.php?arg=freemouse&quot;</span></span><br><span class="line"><span class="variable">$scheme</span>                  <span class="comment">#请求使用的Web协议，&quot;http&quot; 或 &quot;https&quot;</span></span><br><span class="line"><span class="variable">$server_addr</span>             <span class="comment">#服务器端地址，需要注意的是：为了避免访问linux系统内核，应将ip地址提前设置在配置文件中</span></span><br><span class="line"><span class="variable">$server_name</span>             <span class="comment">#服务器名</span></span><br><span class="line"><span class="variable">$server_port</span>             <span class="comment">#服务器端口</span></span><br><span class="line"><span class="variable">$server_protocol</span>         <span class="comment">#服务器的HTTP版本，通常为 &quot;HTTP/1.0&quot; 或 &quot;HTTP/1.1&quot;</span></span><br><span class="line"><span class="variable">$status</span>                  <span class="comment">#HTTP响应代码</span></span><br><span class="line"><span class="variable">$time_iso8601</span>            <span class="comment">#服务器时间的ISO 8610格式</span></span><br><span class="line"><span class="variable">$time_local</span>              <span class="comment">#服务器时间（LOG Format 格式）</span></span><br><span class="line"><span class="variable">$cookie_NAME</span>             <span class="comment">#客户端请求Header头中的cookie变量，前缀&quot;$cookie_&quot;加上cookie名称的变量，该变量的值即为cookie名称的值</span></span><br><span class="line"><span class="variable">$http_NAME</span>               <span class="comment">#匹配任意请求头字段；变量名中的后半部分NAME可以替换成任意请求头字段，如在配置文件中需要获取http请求头：&quot;Accept-Language&quot;，$http_accept_language即可</span></span><br><span class="line"><span class="variable">$http_cookie</span></span><br><span class="line"><span class="variable">$http_host</span>               <span class="comment">#请求地址，即浏览器中你输入的地址（IP或域名）</span></span><br><span class="line"><span class="variable">$http_referer</span>            <span class="comment">#url跳转来源,用来记录从那个页面链接访问过来的</span></span><br><span class="line"><span class="variable">$http_user_agent</span>         <span class="comment">#用户终端浏览器等信息</span></span><br><span class="line"><span class="variable">$http_x_forwarded_for</span></span><br><span class="line"><span class="variable">$sent_http_NAME</span>          <span class="comment">#可以设置任意http响应头字段；变量名中的后半部分NAME可以替换成任意响应头字段，如需要设置响应头Content-length，$sent_http_content_length即可</span></span><br><span class="line"><span class="variable">$sent_http_cache_control</span></span><br><span class="line"><span class="variable">$sent_http_connection</span></span><br><span class="line"><span class="variable">$sent_http_content_type</span></span><br><span class="line"><span class="variable">$sent_http_keep_alive</span></span><br><span class="line"><span class="variable">$sent_http_last_modified</span></span><br><span class="line"><span class="variable">$sent_http_location</span></span><br><span class="line"><span class="variable">$sent_http_transfer_encoding</span></span><br></pre></td></tr></table></figure>

<h4 id="日志切割及删除"><a href="#日志切割及删除" class="headerlink" title="日志切割及删除"></a>日志切割及删除</h4><p>1、通过 <code>crontab</code> 执行定时脚本</p>
<p>编辑 <code>vi /home/crontab/cut_nginx_log.sh</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">! /bin/bash</span></span><br><span class="line">logs_path=&quot;/data/wwwlogs/&quot;</span><br><span class="line">DAYS=30（保留一个月）</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以前的日志文件。</span></span><br><span class="line">log_name=&quot;xxx.log&quot;   </span><br><span class="line">pid_path=&quot;/usr/local/nginx/logs/nginx.pid&quot;</span><br><span class="line">mv $&#123;logs_path&#125;$&#123;log_name&#125; $&#123;logs_path&#125;$&#123;log_name&#125;_$(date --date=&quot;LAST   WEEK&quot; +&quot;%Y-%m-d&quot;).log</span><br><span class="line">kill -USR1 `cat $&#123;pid_path&#125;`</span><br></pre></td></tr></table></figure>

<p>上面shell脚本的原理是：先把以前的日志文件移动重命名成一个，目的是就是备份。</p>
<p>按照上个周一的本日来命名，运行脚本的时候时间点是 <code>”2013-09-16”</code> ，那么生成文件名称是 <code>”xxx.log_ 20130909.log”</code>。</p>
<p>在没有执行 kill -USR1 `cat ${pid_path}`之前，即便已经对文件执行了 <code>mv</code> 命令而<strong>改变了文件名称</strong>，<code>nginx</code>还是会向新命名的文件 <code>” xxx.log_ 20130909”</code> 照常写入日志数据的。原因在于：<code>linux</code> 系统中，内核是根据文件描述符来找文件的。</p>
<p><strong>对 <code>linux</code> 文件描述符的理解</strong></p>
<p>文件描述符是 <code>linux</code> 内核为每个打开的文件命名的一个整数标识。</p>
<p><code>linux</code> 内核为每一个进程生成(或者说维护)一个”<strong>文件描述符表</strong>”，这个文件描述符表记录的是“此进程所打开的文件(进行标识)”。</p>
<p>在这里的环境中，<code>nginx</code> 就是一个运行中的进程，这个进程早就打开了一个日志文件，在文件描述符表是记录了文件的。</p>
<p>即便日志文件的路径改变了，但是还是能够找到(根据文件描述符表可以定位)。</p>
<p>当执行命令“kill -USR1 `cat ${pid_path}`”的时候，<code>nginx.pid</code> 文件中保存的其实就是一个数字(自己可以打开看一下，我这里是894)，<code>nginx</code> 将其主进程的 <code>pid</code> (进程号)写入到了 <code>nginx.pid</code> 文件中，所以可以通过cat命令直接拿到其主进程号,直接操作指定的进程号。</p>
<p>kill -USR1 <code>cat $&#123;pid_path&#125;</code> 就等同于</p>
<p>kill –USR1 894  #指定发信号(USR1)信号给这个进程编号。</p>
<p>在 <code>linux</code> 系统中，<code>linux</code> 是通过信号与”正在运行的进程”进行通信的。<code>linux</code> 系统中，也很多预定义好的信号，像 <code>SIGHUP</code>。<code>USR1</code> 是用户自定义信号。可以理解为：进程自己定义接到这个信号该干嘛(也就是进程编写者自己确定收到这个信号干嘛还是什么都不做都行，完全交给开发人员自己决定)。而在 <code>nginx</code> 中，它自己编写了代码处理当我接到 <code>USR1</code> 信号的时候，让 <code>nginx</code> 重新打开日志文件。具体原理如下：</p>
<p>1、<code>nginx</code>  的主进程收到 <code>USR1</code> 信号，会重新打开日志文件(以 <code>nginx</code> 配置文件中的日志名称命名,就是配置文件中 <code>access_log</code> 项所设置的值，如果文件不存在，会自动创建一个新的文件 <code>xxx.log</code> )。</p>
<p>2、然后把日志文件的拥有者改为“工作进程(<code>worker</code>进程)”，目的是让 <code>worker</code> 进程就具备了对日志文件的读写权限（<code>master</code> 和 <code>worker</code> 通常以不同用户运行，所以需要改变拥有者）。</p>
<p>3、<code>nginx</code> 主进程会关闭重名的日志文件(也就是刚才使用 <code>mv</code> 命令重命名成 <code>xxx.log_ 20130909.log</code> 的文件)，<strong>并通知工作进程使用新打开的日志文件</strong>(刚才主进程打开的文件 <code>xxx.log</code> )。具体实现上更细化点就是，主进程把<code>USR1</code> 信号发给 <code>worker</code>，<code>worker</code> 接到这个信号后，会重新打开日志文件(也就是配置文件中约定的 <code>xxx.log</code>)</p>
<p><strong>定时执行脚本</strong></p>
<p>设置上面的 <code>shell</code> 脚本文件加入到定时任务中去。<code>crontab</code> 是 <code>linux</code> 下面一个定时任务进程。开机此进程会启动，它每隔一定时间会去自己的列表中看是否有需要执行的任务。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br><span class="line">\* 04 * * 1 /data/wwwlogs/nginx_log_division.sh</span><br></pre></td></tr></table></figure>

<p>会打开一个文件，加入上面的代码</p>
<p>格式为 “分 时 日 月 星期几 要执行的shell文件路径”。用*可以理解成“每”,每分钟，每个小时，每个月等等。</p>
<p>我设置是在周一凌晨4点运行nginx_log_division.sh脚本，脚本的内容就是重新生成一个新的日志文件。</p>
<p>给脚本执行权限然后配置 <code>crontab</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * root /home/crontab/cut_nginx_log.sh  #表示每天凌晨执行</span><br></pre></td></tr></table></figure>



<p>2、<code>Linux</code> 系统自带的命令 <code>logrotate</code> 对 <code>Nginx</code> 日志进行切割</p>
<p>Nginx安装目录：<code>/usr/local/nginx/</code><br>Nginx日志目录：<code>/usr/local/nginx/logs/、/usr/local/nginx/logs/nginx_logs/</code><br>添加nginx日志切割脚本<br><code>cd  /etc/logrotate.d</code>  #进入目录<br><code>vi  /etc/logrotate.d/nginx</code>  #编辑脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/logs/*.log  /usr/local/nginx/logs/nginx_logs/*.log&#123;</span><br><span class="line">missingok</span><br><span class="line">dateext</span><br><span class="line">notifempty</span><br><span class="line">daily</span><br><span class="line">rotate 7</span><br><span class="line">sharedscripts</span><br><span class="line">postrotate</span><br><span class="line">if [ -f /usr/local/nginx/logs/nginx.pid ]; then</span><br><span class="line">kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`</span><br><span class="line">fi</span><br><span class="line">endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>:wq!</code>  #保存退出</p>
<p>备注：<code>logrotate</code> 相关参数说明<br><code>missingok</code>：忽略错误，如“日志文件无法找到”的错误提示。<br><code>dateext</code>：切换后的日志文件会附加上一个短横线和YYYYMMDD格式的日期，没有这个配置项会附加一个小数点加一个数字序号<br><code>notifempty</code>：如果日志文件为空，不执行切割。<br><code>daily</code>：按天切割日志。可用值月：monthly 周：weekly 年：yearly<br><code>rotate 7</code>：保留最近7天的日志记录<br><code>sharedscripts</code>：只为整个日志组运行一次的脚本<br><code>postrotate</code> 和 <code>endscript</code>：里面指定的命令将被执行。<br><code>compress</code>：在轮循任务完成后，已轮循的归档将使用gzip进行压缩。<br><code>delaycompress</code>：总是与 <code>compress</code> 选项一起用，<code>delaycompress</code> 选项指示 <code>logrotate</code> 不要将最近的归档压缩，压缩将在下一次轮循周期进行。这在你或任何软件仍然需要读取最新归档时很有用。<br><code>create 644 root root:</code>  以指定的权限创建全新的日志文件，同时 <code>logrotate</code> 也会重命名原始日志文件。</p>
<hr>
<p>**<code>access_log</code>**：为访问日志设置路径，格式和缓冲区大小（<code>nginx</code>  访问日志支持缓存），基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">access_log</span> path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];</span><br><span class="line"><span class="attribute">access_log</span> <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">access_log</span> logs/access.log combined;</span><br><span class="line">Context: http, server, <span class="section">location</span>, if in <span class="section">location</span>. limit_except</span><br></pre></td></tr></table></figure>

<p>使用到的参数也比较好理解，<code>path</code> 用来指定日志写入路径，需要注意，我们也可以通过 <code>syslog</code> 写到远程日志服务器<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/syslog.html">参考文件</a>。</p>
<p>默认 <code>Nginx</code> 会首先把日志写到缓冲区中，默认缓冲区大小为 <code>64k</code>，当满足以下条件时，会将日志从缓冲区写入到日志文件中：</p>
<ul>
<li>缓冲区已经写满</li>
<li>缓冲区数据超过 <code>flush</code> 定义的刷新时间</li>
<li>当 <code>worker</code> 进程被重新打开或者关闭的时候</li>
</ul>
<p>另外，<code>gzip</code> 参数可以支持将日志缓冲区中的数据压缩后写入磁盘，同样支持 <code>1~9</code> 压缩级别，默认为 <code>1</code> ，压缩速度最快，压缩率最低。需要注意的是，<code>gzip</code> 压缩并不是实时的，也是需要满足上面的三个条件之一才会进行压缩写入。所以，对于我们经常需要查看日志的业务，不建议使用压缩存储，我们可以借助 <code>logrotate</code> 等系统级工具进行压缩、分割存储。</p>
<p>示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">access_log</span>	/path/to/log.gz combined gzip flush=<span class="number">5m</span>;</span><br></pre></td></tr></table></figure>

<p>对于压缩后的日志文件，我们可以通过 <code>zcat</code> 进行查看。</p>
<p>至于 <code>if=condition</code> 更少使用，使用示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">map</span> <span class="variable">$status</span> <span class="variable">$loggable</span> &#123;</span><br><span class="line">    ~^[23]  0;</span><br><span class="line">    <span class="attribute">default</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">access_log</span> /path/to/access.log combined if=<span class="variable">$loggable</span>;</span><br></pre></td></tr></table></figure>

<p>以上这两个参数是在日志模块中使用频率比较高的，下面这个则很少使用，我们也简单介绍下。</p>
<hr>
<p><code>open_log_file_cache</code> ：定义一个缓存，用来存储频繁使用的 <strong>文件名包含变量</strong> 的日志文件描述符。</p>
<p>基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">open_log_file_cache</span> max=N [inactive=time] [min_uses=N] [valid=time]</span><br><span class="line">		open_log_file_cache <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">open_log_file_cache</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>max</code> </p>
<p>设置缓存中描述符的最大数量；如果缓存被占满，最近最少使用（<code>LRU</code>）的描述符将被关闭。</p>
</li>
<li><p><code>inactive</code></p>
<p>设置缓存文件描述符在多长时间内没有被访问就关闭；默认为 <code>10</code> 秒。</p>
</li>
<li><p><code>min_uses</code></p>
<p>设置在 <code>inactive</code> 参数指定的时间里，最少访问多少次才能使文件描述符保留在缓存中；默认为 <code>1</code>。</p>
</li>
<li><p><code>valid</code></p>
<p>设置一段用户检查超时后文件是否仍以同样名字存在的时间；默认为 <code>60</code> 秒。</p>
</li>
<li><p><code>off</code></p>
<p>禁用缓存。</p>
</li>
</ul>
<p>使用实例：</p>
<blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">open_log_file_cache</span> max=<span class="number">100</span> inactive=<span class="number">20s</span> valid=<span class="number">1m</span> min_uses=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="7-Nginx-HTTP-ssl模块"><a href="#7-Nginx-HTTP-ssl模块" class="headerlink" title="7. Nginx HTTP ssl模块"></a>7. Nginx HTTP ssl模块</h3><p>关于<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html">ngx_http_ssl_module</a> 模块其实我们在之前的优化课程已经介绍过了，这里我们主要给出一个推荐的优化配置示例，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>				<span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">keepalive_timeout</span>	<span class="number">70</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">ssl_protocols</span>		TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>; <span class="comment">#ssl协议</span></span><br><span class="line">        <span class="attribute">ssl_ciphers</span>			AES128-SHA:AES256-SHA:RC4-SHA:DES-CBC3-SHA:RC4-MD5; <span class="comment">#会话加密套件</span></span><br><span class="line">        <span class="attribute">ssl_certificate</span>		/usr/local/nginx/conf/cert.pem;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>	/usr/local/nginx/conf/cert.key;</span><br><span class="line">        <span class="attribute">ssl_session_cache</span>	shared:SSL:<span class="number">10m</span>; <span class="comment">#定义共享缓存，为所有的worker进程提供session缓存服务，1MB可以缓存4000 session会话；所以生产环境单节点中共享缓存的方案使用最多，一般设置大小10M - 20M足够使用了。</span></span><br><span class="line">        <span class="attribute">ssl_session_timeout</span>	<span class="number">30m</span>; <span class="comment">#会话复用的超时时间</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心优化点：</p>
<ul>
<li>set the number of <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/ngx_core_module.html%23worker_processes">worker processes</a> equal to the number of processors 【设置 <code>worker</code> 进程数等于 <code>CPU</code> 核心数】</li>
<li>enable <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html%23keepalive_timeout">keep-alive</a> connections 【启用长连接】</li>
<li>enable the <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html%23ssl_session_cache_shared">shared</a> session cache 【使用共享存储】</li>
<li>disable the <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html%23ssl_session_cache_builtin">built-in</a> session cache 【设置会话存储类型，使用 <code>shared</code> 类型的共享存储】</li>
</ul>
<p>对于 <code>ssl_ciphers</code> 加密套件的选择，一般我们购买的证书厂商都会给出自己支持的套件。我们可以使用 <code>openssl ciphers</code> 来查看服务端支持的哪些加密套件。</p>
<p>另外，还有一个参数可能也会遇到：</p>
<p>**<code>ssl_prefer_server_ciphers</code>**：即当服务端与客户端进行加密套件协商时，优先考虑服务端。基本用法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="8-Nginx-HTTP-referer模块"><a href="#8-Nginx-HTTP-referer模块" class="headerlink" title="8. Nginx HTTP referer模块"></a>8. Nginx HTTP referer模块</h3><p><a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_referer_module.html">ngx_http_referer_module</a> 模块允许拦截 “<strong>Referer</strong>”请求头中还有非法值的请求，阻止它们访问站点。需要注意的是伪造一个有效的 “<strong>Referer</strong>”请求是相当容易的，因此这个模块的预期目的不在于彻底地阻止这些非法请求，而是为了阻止由正常浏览器发出的大规模此类请求（比如防盗链）。还有一点需要注意，即是正常浏览器发送的合法请求，也可能没有 “<strong>Referer</strong>”请求头。该模块涉及到的参数不多，我们简单介绍下：</p>
<p>**<code>referer_hash_bucket_size</code>**：设置用来存储有效 <code>referer</code> 的哈希桶的大小，基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">referer_hash_bucket_size</span> size;</span><br><span class="line">Default: <span class="attribute">referer_hash_bucket_size</span> <span class="number">64</span>;</span><br><span class="line">Context: server, <span class="section">location</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">0</span>.<span class="number">5</span>.</span><br></pre></td></tr></table></figure>

<p>一般使用默认值即可。</p>
<p>**<code>referer_hash_max_size</code>**：设置用来存储有效 <code>referer</code> 的哈希表最大容量。注意：整个哈希表的容量以哈希桶的数量来定义。<code>nginx</code> 不断调整哈希表（以使用更多的哈希桶）直到哈希表容量超过配置的最大值。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">referer_hash_max_size</span> size;</span><br><span class="line">Default: <span class="attribute">referer_hash_max_size</span> <span class="number">2048</span>;</span><br><span class="line">Context: server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>一般情况下这两者默认值也足够使用。下面介绍下 <code>ngx_http_referer_module</code> 模块中最核心的配置参数。</p>
<p>**<code>valid_referer</code>**：用来设置有效请求头。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">valid_referer</span> <span class="literal">none</span> | blocaked | server_names | string ...;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>“Referer”请求头为 指定值 时，内嵌变量 <code>$invalid_referer</code> 被设置为空字符串，否则这个变量会被置成“<code>1</code>”。另外，查找匹配时不区分大小写。</strong></p>
<p>其中 <code>valid_referers</code> 可以使用的指定值如下：</p>
<ul>
<li>**<code>none</code>**：没有 <code>Referer</code> 请求头，一般我们直接访问网站网址就没有 <code>Referer</code> 请求头；</li>
<li>**<code>blocked</code>**：<code>Referer</code> 请求头存在，但是它的值被防火墙或者代理服务器删除；这些值都不以 <code>http://</code> 或者 <code>https://</code> 字符串作为开头；</li>
<li>**<code>server_names</code>**：<code>Referer</code> 请求头包含某个虚拟主机名；</li>
<li>**<code>任意字符</code>**：定义一服务端和可选的 <code>URI</code> 前缀。服务器名运行在开头或结尾使用 <code>*</code> 符号。当 <code>nginx</code> 检查时，<code>Referer</code> 请求头里的服务器端口将被忽略。</li>
<li>**<code>正则表达式</code>**：必须以 <code>~</code> 符号作为开头。需要注意的是表达式会从 <code>http://</code> 或者 <code>https://</code> 之后的文本开始匹配。</li>
</ul>
<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">valid_referers</span> <span class="literal">none</span> <span class="literal">blocked</span> server_names</span><br><span class="line">			   <span class="regexp">*.example.com</span> <span class="regexp">example.*</span> www.example.org/galleries/</span><br><span class="line">			   ~\.google\.;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于为什么要设置哈希表</p>
<p>为了快速处理静态的数据集合，诸如虚拟主机名、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_map_module.html%23map">map</a> 指令的值、<code>MIME</code> 类型和请求头的字段名，<code>nginx</code> 使用了哈希表，在 <code>nginx</code> 启动和更新匹配的过程中，它会尽可能为哈希表选择最小的容量，同时使每个哈希桶的长度不超过设置的配置参数。这些桶用于保存键和对应的哈希表。整个哈希表的容量以哈希桶的数量来定义。<code>nginx</code> 不断调整哈希表直到哈希表容量超过配置的最大值。大部分哈希表都有对应的指令，运行修改这些配置参数。比如，针对虚拟主机名的哈希表，有 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html%23server_names_hash_max_size">server_names_hash_max_size</a> 和 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_core_module.html%23server_names_hash_bucket_size">server_names_hash_bucket_size</a> 两条指令。</p>
<p>哈希桶大小的参数会对齐到处理器缓存线长度的整倍数。这将加上哈希表中的键查找，因为在现代的处理器上，这可以减少内存访问的次数。如果哈希桶大小等于处理器的缓存线长度，那么在最坏情况下，键查找时的内存访问次数是两次— 第一次是计算哈希桶的地址，第二次是在哈希桶内进行键查找。<strong>因此，如果 <code>nginx</code> 提示需要增大哈希表容量或者哈希桶大小时，应优先增大前者。</strong></p>
</blockquote>
<p><strong>【生产示例之防盗链】</strong></p>
<p>我们在生产环境中使用 <code>ngx_http_referer_module</code> 模块基本是用来进行图片防盗链，比如我们的网站中的图片被别的网站引用，导致本网站浪费很多无效的流量。如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单配置域名 b.host.com</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span>		b.host.com;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 设置 B 网站中引用了 a.host.com 中的图片</span></span><br><span class="line"><span class="comment">#cat /data/nginx/domain/index.html</span></span><br><span class="line">&lt;h1&gt;<span class="attribute">This</span> is b.host.com page&lt;/h1&gt;</span><br><span class="line">&lt;img src=<span class="string">&quot;https://a.host.com/images/a.jpeg&quot;</span> height=<span class="string">&quot;200&quot;</span> width=<span class="string">&quot;200&quot;</span> alt=<span class="string">&quot;这是盗用 A 网站的图片&quot;</span>/&gt;</span><br></pre></td></tr></table></figure>

<p>此时访问网站 <code>b.host.com</code> ，如下：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210213202952810.png" alt="image-20210221131823206" style="zoom:33%;" />

<p>可以看到图片正常显示了。此时我们看下 <code>a.host.com</code> 的访问日志，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> a-access.log</span> </span><br><span class="line">10.4.7.1 - -:11429 [21/Feb/2021:14:06:41 +0800] &quot;GET / HTTP/1.1&quot; 304 0 &quot;http://b.host.com&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36&quot; &quot;Host:a.host.com&quot;</span><br></pre></td></tr></table></figure>

<p>其中 <code>$http_referer</code> 为 <code>http://b.host.com</code> ，现在我们想避免这种情况，该如何设置呢。我们可以这样定义：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">return</span>				<span class="number">302</span>	 https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> 	<span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>	<span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>				/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>				utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">valid_referers</span>		<span class="literal">none</span> <span class="literal">blocked</span> a.host.com/images/</span><br><span class="line">        				~\.google\.	~\.baidu\.	~\.bing\. ~\.yahoo\.</span><br><span class="line">        				~\.sogou\.	~\.<span class="number">360</span>\.	~\.so;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$invalid_referer</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>			<span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$http_user_agent</span> <span class="regexp">~* &quot;android|iphone|ipad|pad&quot;</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>			<span class="number">302</span>		http://m.a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>			index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要关注的是这一段：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">valid_referers</span>		<span class="literal">none</span> <span class="literal">blocked</span> a.host.com/images/</span><br><span class="line">    				~\.google\.	~\.baidu\.	~\.bing\. ~\.yahoo\.</span><br><span class="line">    				~\.sogou\.	~\.<span class="number">360</span>\.	~\.so;</span><br><span class="line"><span class="attribute">if</span> ( <span class="variable">$invalid_referer</span> ) &#123;</span><br><span class="line">    <span class="attribute">return</span>			<span class="number">403</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么我们自己还能使用吗，试试看。</p>
<p>同样创建一个引用了相同 <code>URL</code> 的页面，</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /data/nginx/domain/index.html</span></span><br><span class="line">&lt;h1&gt;This is a.host.com page&lt;/h1&gt;</span><br><span class="line">&lt;img src=&quot;https://a.host.com/images/a.jpeg&quot; height=&quot;200&quot; width=&quot;200&quot; alt=&quot;这是我自己的图片&quot;/&gt;</span><br></pre></td></tr></table></figure>



<p>图片显示依然是正常的。</p>
<p>另外，需要说明的一点是，通过搜索引擎进入到我们网站的请求也是很正常的，因此我们也需要把常用的搜索引擎写到白名单列表中。下方是 <code>baidu</code> 搜索引擎的 <code>Referer</code> 请求头，在日志中显示如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>谷歌的 <code>Referer</code> 请求头可能是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>搜狗的 <code>Referer</code> 请求头可能是这样的：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p>大家如果想要使用 <code>referer_module</code> 进行防盗链，需要把白名单指定好，以避免误伤。</p>
<hr>
<h3 id="9-Nginx-HTTP-stub-status-模块"><a href="#9-Nginx-HTTP-stub-status-模块" class="headerlink" title="9. Nginx HTTP stub_status 模块"></a>9. Nginx HTTP stub_status 模块</h3><p>一般情况下我们需要查看 <code>Nginx</code> 的一些数据统计信息来判断当前的运行状态、连接数量等信息。主要使用 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_stub_status_module.html">ngx_http_stub_status_module</a>，该模块中仅有一个指令，但是一般我们会结合 <code>ngx_http_access_module</code> 一起使用，来限制访问该模块的地址。</p>
<p>需要注意的是，如果想使用 <code>ngx_http_stub_status_module</code> 模块，要在编译 <code>Nginx</code> 时指定 <code>--with-http_stub_status_module</code> ，不过我们默认从 <code>EPEL</code> 源中安装的 <code>Nginx</code> 已经把该模块编译进去了。</p>
<h4 id="stub-status"><a href="#stub-status" class="headerlink" title="stub_status"></a>stub_status</h4><p>**<code>stub_status</code>**：用来统计一些基本访问信息，语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: stub_status;</span><br><span class="line">Default: -</span><br><span class="line">Context: server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>nginx 1.7.5</code> 及以前，需要使用 <code>stub_status on;</code> 才能启用该模块；</p>
</blockquote>
<p>使用示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">root</span>				/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>				utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">valid_referers</span>		<span class="literal">none</span> <span class="literal">blocked</span> a.host.com/images/</span><br><span class="line">        				~\.google\.	~\.baidu\.	~\.bing\. ~\.yahoo\.</span><br><span class="line">        				~\.sogou\.	~\.<span class="number">360</span>\.	~\.so;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$invalid_referer</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>			<span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>			index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> = /basic_status &#123;</span><br><span class="line">        stub_status;</span><br><span class="line">        <span class="attribute">allow</span>		<span class="number">10.4.7.101</span>;</span><br><span class="line">        <span class="attribute">allow</span>		<span class="number">10.0.0.0</span>/<span class="number">24</span>;</span><br><span class="line">        <span class="attribute">deny</span>		all;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们访问下该页面（通过客户端地址 <code>10.4.7.101</code>）：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210221142108955.png" alt="image-20210221142108955" style="zoom:33%;" />

<p>其中：</p>
<ul>
<li>**<code>Active connection</code>**：表示当前状态，活动状态的连接数（包括等待连接状态 <code>waiting</code>）;</li>
<li>**<code>accepts</code>**：统计总值，表示已经接受的客户端请求总数；</li>
<li>**<code>handled</code>**：统计总值，表示已经处理完成的客户端请求的总数；</li>
<li>**<code>requests</code>**：统计总值，表示客户端发来的总的请求数；</li>
<li>**<code>Reading</code>**：当前状态，正在读取客户端请求报文首部 <code>Header</code> 的连接数；</li>
<li>**<code>Writing</code>**：当前状态，正在向客户端发送响应报文的连接数；</li>
<li>**<code>Waiting</code>**：当前状态，正在等待客户端发出请求的空闲连接数；</li>
</ul>
<p>对于以上的关键字，我们也可以通过内置变量获取：</p>
<blockquote>
<p>The <code>ngx_http_stub_status_module</code> module supports the following</p>
<p>embedded variables (1.3.14):</p>
<ul>
<li><p><code>$connections_active</code></p>
<p>same as the <code>Active connections</code> value;</p>
</li>
<li><p><code>$connections_reading</code></p>
<p>same as the <code>Reading</code> value;</p>
</li>
<li><p><code>$connections_writing</code></p>
<p>same as the <code>Writing</code> value;</p>
</li>
<li><p><code>$connections_waiting</code></p>
<p>same as the <code>Waiting</code> value.</p>
</li>
</ul>
</blockquote>
<p>另外，生产环境上一般这种统计页面一定会做客户端限制的，如果通过非允许的客户端进行访问则会禁止该请求。</p>
<hr>
<h3 id="10-Nginx-HTTP-proxy-模块"><a href="#10-Nginx-HTTP-proxy-模块" class="headerlink" title="10. Nginx HTTP proxy 模块"></a>10. Nginx HTTP proxy 模块</h3><p>模块 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html">ngx_http_proxy_module</a> 是一个使用频率很高且极其重要的一个模块，该模块设计的指令也非常多，我们将重点介绍常用参数以及调优相关参数。该模块的使用示例如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>			http://localhost:8000;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>	X-Real-IP	<span class="variable">$remote_addr</span>;</span><br><span class="line">    <span class="attribute">proxy_set_header</span>	X-Forward-For	<span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面就来介绍下常用指令。</p>
<h4 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h4><p>**<code>proxy_pass</code>**：该指令是 <code>ngx_http_proxy_module</code> 模块中最重要、最核心的指令，用来指定将用户请求代理至后端的哪个服务器，或者服务器组。基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_pass</span>	URL;</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="section">location</span>, if in <span class="section">location</span>, limit_except</span><br></pre></td></tr></table></figure>

<p>语法非常简单，打死这个指令的坑是最多的。</p>
<p><strong>【第一坑：<code>location</code> 使用正则表达式，<code>proxy_pass</code> 不支持 <code>URI</code>】</strong></p>
<p>我们定义两个服务器，其中服务器 <code>10.4.7.100</code> 作为代理服务器，当访问域名 <code>a.host.com/api</code> 时将请求代理至后端 <code>10.4.7101</code> 节点</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>              <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>         a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>             utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>                /data/nginx/domain;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>            /data/nginx/domain;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /api/</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>      http://10.4.7.101:8080/;</span><br><span class="line">    &#125;     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>语法检查：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@a ~]# nginx -t</span><br><span class="line">nginx: [emerg] &quot;proxy_pass&quot; cannot have URI part in location given by regular expression, or inside named location, or inside &quot;if&quot; statement, or inside &quot;limit_except&quot; block in /etc/nginx/conf.d/domain.conf:10</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test failed</span><br></pre></td></tr></table></figure>

<p>此时我们修改配置，其实只需将 <code>proxy_pass</code> 修改为 <code>http://10.4.7.101:8080</code> 即可。</p>
<p>【注意后面没有任何 <code>URI</code> ，包括 <code>/</code>】</p>
<p>在进行语法检查：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@a ~]# nginx -t</span><br><span class="line">nginx: the configuration file /etc/nginx/nginx.conf syntax is ok</span><br><span class="line">nginx: configuration file /etc/nginx/nginx.conf test is successful</span><br></pre></td></tr></table></figure>

<p>此时后端节点配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="attribute">b</span> api]<span class="comment"># pwd &amp;&amp; ls</span></span><br><span class="line">/data/nginx/domain2/api</span><br><span class="line">index.htm</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        <span class="attribute">listen</span>          <span class="number">8080</span>;</span><br><span class="line">        <span class="attribute">server_name</span>     b.host.com;</span><br><span class="line">        <span class="attribute">root</span>            /data/nginx/domain2;</span><br><span class="line">        <span class="attribute">charset</span>         utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">root</span>    /data/nginx/domain2;</span><br><span class="line">                <span class="attribute">index</span>   index.html;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在后端节点创建一个 <code>index.html</code> 页面，注意该页面的创建路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@b domain2]# cat /data/nginx/domain2/index.html </span><br><span class="line">&lt;h1&gt;this is b.host.com WebSite,File:$document_root/index.html&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>我们通过客户端请求访问（访问：<code>a.host.com</code> 即代理服务器主页，注意此时还不算代理服务器）：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210221205411809.png" alt="image-20210221201946847" style="zoom:33%;" />

<p>再次访问指定的 <code>URI</code> 路径，即：<code>a.host.com/api</code>，如下：<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210223151950218.png" alt="image-20210221205411809" style="zoom:33%;" /></p>
<p>代理至 <code>http://10.4.7.101:8080/api/index.html</code>。</p>
<p><strong>知识点1：当 <code>proxy_pass</code> 后不加 <code>URI</code> 时，会将客户端的原始 <code>URI</code> （包括参数）传递给后端服务。</strong></p>
<hr>
<p><strong>【第二坑：<code>location</code> 使用字符串，<code>proxy_pass</code> 匹配部分 <code>URI</code>】</strong></p>
<p>如上环境，我们修改代理服务器配置，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>              <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>         a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>             utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>                /data/nginx/domain;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>            /data/nginx/domain;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="section">location</span>  /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>      http://b.host.com:8080/;</span><br><span class="line">        <span class="attribute">index</span>           index.html index.php;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：此时我们使用的字符串匹配，所以 <code>proxy_pass</code> 中可以使用 <code>uri</code> ，比如我们就是用 <code>/</code>，再次请求原来的路径 <code>http://a.host.com/api/index.html</code>：</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210223160717725.png" alt="image-20210221210633609" style="zoom:50%;" />

<p>也即是请求的后端地址为 <code>http://10.4.7.101:8080/index.html</code> 即：仅将部分 <code>URI</code> 转发至后端服务器。</p>
<p>那如果此时，我们还希望可以代理至 <code>http://10.4.7.101:8080/api/index.html</code> 该怎么配置呢，也很简单，将 <code>location</code> 配置段中的 <code>proxy_pass</code> 修改如下即可：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span>  /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>      http://b.host.com:8080/api/;</span><br><span class="line">    <span class="attribute">index</span>           index.html index.php;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210221210633609.png" alt="image-20210221211140229"></p>
<p>需要注意，此时 <code>location</code> 中的 <code>URI</code> 是否有 <code>/</code> ，需要和 <code>proxy_pass</code> 中的 <code>URI</code> 最后进行匹配，如下：</p>
<blockquote>
<p><code>location /api/</code> 时，<code>proxy_pass</code> 后端就应该是：<code>http://10.4.7.101:8080/api/</code>，</p>
<p>而如果：</p>
<p><code>location /api</code> 时，<code>proxy_pass</code> 后端就应该是：<code>http://10.4.7.101:8080/api</code>。</p>
</blockquote>
<p>否则可能会出现无法访问的情况，比如：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span>  /api/ &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span>      http://b.host.com:8080/api;</span><br><span class="line">    <span class="attribute">index</span>           index.html index.php;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时如果你请求 <code>a.host.com/api/test.php?a=3&amp;b=4</code></p>
<p>则转到后端变成 <code>http://10.4.7.101:8080/apitest.php?a=3&amp;b=4</code></p>
<p>所以，一定要注意！</p>
<p>除了上面的方法，我们还可以通过引入变量的方式实现，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>              <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>         a.host.com;</span><br><span class="line">    <span class="attribute">charset</span>             utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">root</span>                /data/nginx/domain;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>            /data/nginx/domain;</span><br><span class="line">        <span class="attribute">index</span>           index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span>  /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>      http://b.host.com:8080<span class="variable">$request_uri</span>;</span><br><span class="line">        <span class="attribute">index</span>           index.html index.php;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时客户端的原始完整 <code>URI</code> 都会被传递至后端服务器。</p>
<p><strong>知识点2：在 <code>location</code> 使用字符串匹配时，当 <code>proxy_pass</code> 使用 <code>URI</code> 后端只能获取到前端部分请求 <code>URI</code> （同样包括参数）。</strong></p>
<p><strong>知识点3：在 <code>location</code> 使用字符串匹配时，如果希望获取完整前端 <code>URI</code> ，除了 <code>proxy_pass</code> 不加 <code>URI</code> 之外，还可以通过引入变量 <code>$request_uri</code> 来实现。</strong></p>
<blockquote>
<p>注意：当事员工字符串匹配时，如果 <code>proxy_pass</code> 后端不使用 <code>URI</code> 时，也同样可以实现原始 <code>URI</code> （包括参数）的完全传递。</p>
</blockquote>
<hr>
<p><strong>【第三坑：<code>location</code> 配置段中遇到 <code>rewrite</code> 重写】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">root</span>				/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>				utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>			index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">rewrite</span>			/api/(.*)$ /rewrite/<span class="variable">$1</span> <span class="literal">break</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span>		http://10.4.7.101:8080;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会直接以重写后的 <code>URI</code> 完成传递至后端代理服务器。如下：</p>
<p>先创建后端测试页面。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">cat</span> /data/nginx/domain2/rewrite/index.html</span> </span><br><span class="line">This is b.host.com:8080/rewrite/index.html</span><br></pre></td></tr></table></figure>

<p>再次请求访问 <code>http://a.host.com/api/index.html</code> 会被重写为 <code>http://a.host.com/rewrite/index.html</code> ，然后会将这个请求代理转发至后端 <code>proxy_pass</code> 中，注意此时的 <code>proxy_pass</code> 不支持 <code>URI</code> ，即是写上，也会被忽略掉。</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210221131823206.png" alt="image-20210223151950218" style="zoom:33%;" />

<p><strong>知识点4：当 <code>proxy_pass</code> 与 <code>rewrite</code> 指令在同一个 <code>location</code> 中，会先将请求进行重写，然后将重写的 <code>URI</code> 完全转发至后端服务器，且 <code>proxy_pass</code> 不支持 <code>URI</code> （即是配置上，不会报错，但是会被自动忽略）。</strong></p>
<hr>
<h4 id="proxy-set-header"><a href="#proxy-set-header" class="headerlink" title="proxy_set_header"></a>proxy_set_header</h4><p>**<code>proxy_set_header</code>**：用来添加或者重新定义发往后端服务器的请求头。一般情况下，我们需要指定该参数，用来添加某些特定的请求头，以便在后端服务器中进行一些数据采集，比如：</p>
<p>我们定义两个服务器，其中服务器 <code>10.4.7.100</code> 作为代理服务器，当访问域名 <code>a.host.com/api</code> 时将请求代理至后端 <code>10.4.7.101</code> 节点，基本配置如下：</p>
<p>代理服务器：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">root</span>				/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>				utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">valid_referers</span>		<span class="literal">none</span> <span class="literal">blocked</span> a.host.com/images/</span><br><span class="line">        				~\.google\. ~\.baidu\. ~\.bing\. ~\.yahoo\. ~\.sougou\. ~\.<span class="number">360</span>\. ~\.so;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$invalid_referer</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>			<span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>			index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /api/</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>		http://10.4.7.101:80;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后端服务器（注意：后端服务器我们使用 <code>httpd</code> ，因为其在日志中引用自定义报文首部信息更加简单）</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@b ~]# yum -y install httpd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改配置文件 /etc/httpd/conf/httpd.conf</span></span><br><span class="line">ServerName 80</span><br><span class="line">LogFormat &quot;\&quot;X-Real-IP: %&#123;X-Real-IP&#125;i\&quot; \&quot;X-Forward-For: %&#123;X-Forward-For&#125;i\&quot; %h %l %u %t \&quot;%r\&quot; %&gt;s %b \&quot;%&#123;Referer&#125;i\&quot; \&quot;%&#123;User-Agent&#125;i\&quot;&quot; combined</span><br></pre></td></tr></table></figure>

<p>启动 <code>httpd</code> ：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@b ~]# httpd -t</span><br><span class="line">Syntax OK</span><br><span class="line">[root@b ~]# httpd</span><br><span class="line">httpd (pid 938) already running</span><br></pre></td></tr></table></figure>

<p>注意：我们需要在 <code>$document_root</code> 目录下创建 <code>api</code> 目录，因为此时访问 <code>http://a/host.com/api/abc.html</code> hi把代理至 <code>http://10.4.7.101/api/abc.html</code> 。我们创建的文件如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@b ~]# cat /var/www/html/api/index.html </span><br><span class="line">This is Apache WebSite, File: $document_root/api/index.html</span><br></pre></td></tr></table></figure>

<p>此时我们访问代理服务器，请求 <code>http://a.host.com/api/</code>；</p>
<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210221211140229.png" alt="image-20210223160717725" style="zoom:33%;" />

<p>看下代理服务器日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.4.7.1 - - [23/Feb/2021:16:06:23 +0800] &quot;GET /api/ HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36&quot; &quot;-&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到代理服务器日志上通过变量 <code>$remote_addr</code> 获取的地址是真正的客户端地址。再看下后端服务器日志：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@b ~]# tail -f /var/log/httpd/access_log </span><br><span class="line">&quot;X-Real-IP: -&quot; &quot;X-Forward-For: -&quot; 10.4.7.100 - - [23/Feb/2021:03:06:23 -0500] &quot;GET /api/ HTTP/1.0&quot; 304 - &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到日志服务器中 <code>%h</code> （也就是相当于 <code>nginx</code> 中的 <code>$remote_addr</code> ）的地址是代理服务器地址，这种情况一般不是我们所希望的，因此可以通过修改代理节点的请求头来实现。如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">root</span>				/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>				utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">valid_referers</span>		<span class="literal">none</span> <span class="literal">blocked</span> a.host.com/images/</span><br><span class="line">        				~\.google\. ~\.baidu\. ~\.bing\. ~\.yahoo\. ~\.sougou\. ~\.<span class="number">360</span>\. ~\.so;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$invalid_referer</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>			<span class="number">403</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>			index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* /api/</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>		http://10.4.7.101:80;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Forward-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们在代理服务器请求首部中加了两个变量，即 <code>X-Real_IP</code> 和 <code>X-Forward-For</code> ，在 <code>httpd</code> 的日志中我们可以非常简单对自定义的变量进行引用，但是在 <code>Nginx</code> 上处理起来还是比较复杂的，在 <code>Nginx</code> 中有独立的模块用来专门处理客户端真实地址问题。我们现在再看下代理节点和后端服务器的日志信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代理</span></span><br><span class="line">10.4.7.1 - - [23/Feb/2021:17:26:29 +0800] &quot;GET /api/ HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">后端服务器</span></span><br><span class="line">&quot;X-Real-IP: 10.4.7.1&quot; &quot;X-Forward-For: 10.4.7.1&quot; 10.4.7.100 - - [23/Feb/2021:04:26:29 -0500] &quot;GET /api/ HTTP/1.0&quot; 304 - &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.102 Safari/537.36&quot;</span><br></pre></td></tr></table></figure>

<p>可以看到后端节点通过这两个自定义的变量已经成功获取真实的客户端地址。</p>
<blockquote>
<p>注意：<code>X-Forwarded-For</code> 是一个 <code>HTTP</code> 扩展头部，该请求头的格式非常简单：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For: client, proxy1, proxy2</span><br></pre></td></tr></table></figure>

<p>如果一个 <code>HTTP</code> 请求到达服务器之前，经过了三个代理 <code>Porxy1、Proxy2、Proxy3</code> ，<code>IP</code> 分别为 <code>IP1、IP2、IP3</code> ，用户真实 <code>IP</code> 为 <code>IP0</code> ，那么按照 <code>XFF</code> 标准，服务端最终会收到以下信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded_for: IP0, IP1, IP2</span><br></pre></td></tr></table></figure>

<p><code>Proxy3</code> 直连服务器，他会给 <code>XFF</code> 追加 <code>IP2</code> ，百世它是在帮 <code>Proxy2</code> 转发请求。列表中并没有 <code>IP3</code> ，<code>IP3</code> 可以在服务端通过 <code>Remote Address</code> 字段获得。我们知道 <code>HTTP</code> 连接基于 <code>TCP</code> 连接，<code>HTTP</code> 协议中没有 <code>IP</code> 的概念， <code>Remote Address</code> 来自 <code>TCP</code> 连接，表示与服务端建立 <code>TCP</code> 连接的设备 <code>IP</code> ，在这个例子里就是 <code>IP3</code>。</p>
</blockquote>
<hr>
<p>上面两个参数是 <code>ngx_http_proxy_module</code> 中最重要、最核心的两个参数，大家一定要熟悉掌握，下面我们介绍几个和优化相关的参数。</p>
<h4 id="proxy-cache"><a href="#proxy-cache" class="headerlink" title="proxy_cache"></a>proxy_cache</h4><p>**<code>proxy_cache</code>**：指定用于页面缓存的共享内存。同一块共享内存可以在多个地方使用。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_cache</span> zone | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">proxy_cache</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>至于该参数后的 <code>zone</code> 该如何设置，需要借助下面这个参数。</p>
<hr>
<h4 id="proxy-cache-path"><a href="#proxy-cache-path" class="headerlink" title="proxy_cache_path"></a>proxy_cache_path</h4><p>**<code>proxy_cache_path</code>**：设置缓存的路径和其他参数。缓存数据是保存在文件中的，缓存的键和文件名都是在代理 <code>URL</code> （默认 <code>proxy_cache_key $scheme$proxy_host$request_uri;</code>）上执行 <code>MD5</code> 的结果。<code>levels</code> 参数定义了缓存的层次结构，最多三层结构，每层最多创建 <code>16^2</code> 个目录。如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /data/nginx/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=one:<span class="number">10m</span>;</span><br></pre></td></tr></table></figure>

<p>那么某个文件可能缓存的路径为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/nginx/cache/c/29/b7f54b2df7773722d382f4809d65029c</span><br></pre></td></tr></table></figure>

<p>该参数基本用法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stntax: <span class="attribute">proxy_cache_path</span> path [levels=levels] [use_temp_path=<span class="literal">on</span>|<span class="literal">off</span>] keys_zone=name:size [inactive=time] [max_size=size] [manager_files=number] [manager_sleep=time] [manager_threshold=time] [loader_files=number] [loader_sleep=time] [loader_threshold=time] [purger=<span class="literal">on</span>|<span class="literal">off</span>] [purger_files=number] [purger_sleep=time] [purger_threshold=time];</span><br><span class="line">Default: -</span><br><span class="line">Context: http</span><br></pre></td></tr></table></figure>

<p>另外，还有一点需要注意，被缓存的响应首先写入一个临时文件，然后进行重命名。从 <code>0.8.9</code> 版本开始，临时文件和缓存可以放在不同的文件系统。但请注意，这将导致文件在这两个文件系统中进行拷贝，而不是廉价的重命名操作。因此，针对任何路径，都建议将缓存和 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html%23proxy_temp_path">proxy_temp_path</a> （后面会介绍该指令）指令设置的临时文件目录放到同一文件系统。如果我们将参数 <code>use_temp_path=off</code> ，那么产生的临时文件将直接写入到缓存路径中。</p>
<p>所有活动的键和缓存数据相关的信息（即：元数据信息）都被存放在共享内存中。共享内存通过 <code>keys_zone</code> 参数的 <code>name</code> 和 <code>size</code> 来定义。<code>1M</code> 内存大概可以存储 <code>8000 key</code> （<code>one megabyte zone can store about 8 thousand keys</code>）</p>
<p>被缓存的数据如果在 <code>inactive</code> 参数指定的时间内未被访问，就会被从缓存中移除，不论它是否是刚产生的。<code>inactive</code> 的默认值是 <code>10</code> 分钟。</p>
<h4 id="max-size"><a href="#max-size" class="headerlink" title="max_size"></a>max_size</h4><p><strong><code>max_size</code><strong>：</strong>是指用来存储缓存文件内容的磁盘大小，所以为了性能的提升，也建议将这块区域使用高速 <code>SSD</code> 磁盘，或者使用内存。</strong></p>
<p>基于以上概述，我们可以这样定义 <code>proxy_cache_path</code>：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /var/cache/nginx/proxy_cache</span><br><span class="line">				 levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=proxycache:<span class="number">20m</span></span><br><span class="line">				 inactive=<span class="number">300s</span> max_size=<span class="number">1g</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="proxy-cache-key"><a href="#proxy-cache-key" class="headerlink" title="proxy_cache_key"></a>proxy_cache_key</h4><p>**<code>proxy_cache_key</code>**：定义如何生成缓存的键，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_cache_key</span> string;</span><br><span class="line">Default: <span class="attribute">proxy_cache_key</span> <span class="variable">$scheme</span><span class="variable">$proxy_host</span><span class="variable">$request_uri</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>一般使用默认值即可，生成的 <code>key</code> 的字符串类似于</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> <span class="variable">$scheme</span><span class="variable">$proxy_host</span><span class="variable">$uri</span><span class="variable">$is_args</span><span class="variable">$args</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="proxy-cache-valid"><a href="#proxy-cache-valid" class="headerlink" title="proxy_cache_valid"></a>proxy_cache_valid</h4><p>**<code>proxy_cache_valid</code>**：为不同的响应状态码设置不同的缓存时间。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_cache_valid</span> [code ...] time;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>比如我们可以这样设置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">404</span> <span class="number">1m</span>;</span><br></pre></td></tr></table></figure>

<p>表示对于状态码是 <code>200</code> 或者 <code>302</code> 则缓存 <code>10m</code> ，对于 <code>404</code> 状态码，缓存 <code>1m</code> 。如果我们指定时间 <code>time</code> ，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">5m</span>;</span><br></pre></td></tr></table></figure>

<p>表示只要 <code>200, 301, and 302</code> 状态码的数据会被缓存。我们还可以借助 <code>any</code> 参数来缓存所有响应码的数据，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> <span class="number">301</span>	  <span class="number">1h</span>;</span><br><span class="line"><span class="attribute">proxy_cache_valid</span> any	  <span class="number">1m</span>;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="proxy-temp-path"><a href="#proxy-temp-path" class="headerlink" title="proxy_temp_path"></a>proxy_temp_path</h4><p>**<code>proxy_temp_path</code>**：定义从后端服务器接收的临时文件的存放路径，可以为临时文件路径定义至多三层子目录的目录树。基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_temp_path</span> path [level1 [level2 level3 ]]];</span><br><span class="line">Default: <span class="attribute">proxy_temp_path</span> proxy_temp;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>比如可以这样设置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_temp_path</span> /spool/nginx/proxy_temp <span class="number">1</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>那么临时文件的存储路径可能如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/spool/nginx/proxy_temp/7/45/00000123457</span><br></pre></td></tr></table></figure>

<p>同样，该路径最好设定在高性能 <code>IO</code> 设备，需要注意的是，该目录路径应该和 <code>proxy_cache_path</code> 使用相同的文件系统，如果想存储在内存中，需要将两者都设定在内存，并且考虑大小的限制。</p>
<hr>
<h4 id="proxy-connect-timeout"><a href="#proxy-connect-timeout" class="headerlink" title="proxy_connect_timeout"></a>proxy_connect_timeout</h4><p>**<code>proxy_connect_timeout</code>**：用来设置代理节点与后端服务器建立连接的超时时间，默认为 <code>60s</code> ，一般设置不可超过 <code>75s</code> ，基本语法如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_connect_timeout</span> time;</span><br><span class="line">Default: <span class="attribute">proxy_connect_timeout</span> <span class="number">60s</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>生产上不同设置这么大，可以适当调小此值，比如：<code>proxy_connect_timeout 10s</code>。</p>
<hr>
<h4 id="proxy-send-timeout"><a href="#proxy-send-timeout" class="headerlink" title="proxy_send_timeout"></a>proxy_send_timeout</h4><p>**<code>proxy_send_timeout</code>**：定义向后端服务器传输请求的超时时间。此超时是指相邻两次写操作之间的最长时间间隔，而不是整个请求传输完成的最长时间。如果后端服务器在超时时间段内没有接收到任何数据，连接将被关闭。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_send_timeout</span> time;</span><br><span class="line">Default: <span class="attribute">proxy_send_timeout</span> <span class="number">60s</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="proxy-read-timeout"><a href="#proxy-read-timeout" class="headerlink" title="proxy_read_timeout"></a>proxy_read_timeout</h4><p>**<code>proxy_read_timeout</code>**：定义从后端服务器读取响应的超时时间。此超时是指相邻两次读操作之间的最长时间间隔，而不是整个响应传输完成的最长时间。如果后端服务器咋超时时间段内没有传输任何数据，连接将被关闭。</p>
<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_read_timeout</span> time;</span><br><span class="line">Default: <span class="attribute">proxy_read_timeout</span> <span class="number">60s</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>以上这三个超时时间，建议都调小一些，以便出现问题快速定位。当然，如果网络环境较差，且无法调整，那么可以适当调大此值，以便实现更好的稳定性。</p>
<p>示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span>  		/var/cache/nginx/proxy_cache</span><br><span class="line">				  		levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=proxycache:<span class="number">20m</span></span><br><span class="line">				  		inactive=<span class="number">300s</span> max_size=<span class="number">1g</span>;</span><br><span class="line"><span class="attribute">proxy_connect_timeout</span>	<span class="number">15s</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span>		<span class="number">10s</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span>		<span class="number">10s</span>;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">root</span>				/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>				utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>			index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>		http://b.host.com:8080;</span><br><span class="line">        <span class="attribute">proxy_cache</span>		proxycache;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> <span class="number">301</span> <span class="number">1h</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>proxy_cache_path</code> 只能设置在 <code>http</code> 的上下文中。</p>
<p>我们可以请求之后，看下生成的缓存文件，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@a proxy_cache]# tree /var/cache/nginx/proxy_cache/</span><br><span class="line">/var/cache/nginx/proxy_cache/</span><br><span class="line">└── c</span><br><span class="line">    └── 24</span><br><span class="line">        └── af4240992b8abdc84068f6073c59d24c</span><br></pre></td></tr></table></figure>

<p>做了三次请求，其中有一个为 <code>404</code> ，我们可以看下缓存的文件内容：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@a proxy_cache]# cat  /var/cache/nginx/proxy_cache/c/24/af4240992b8abdc84068f6073c59d24c </span><br><span class="line">&quot;60324ed9-43&quot;h </span><br><span class="line">KEY: http://b.host.com:8080/api/</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Wed, 24 Feb 2021 10:58:21 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 67</span><br><span class="line">Last-Modified: Sun, 21 Feb 2021 12:15:21 GMT</span><br><span class="line">Connection: close</span><br><span class="line">ETag: &quot;60324ed9-43&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"></span><br><span class="line">&lt;h1&gt;this is b.host.com WebSite,File:$document_root/index.html&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>另外，需要注意的是，代理节点和后端服务器之间也可以通过 <code>ssl</code> 加密传输，不过一般生产上不会采用这种方式，主要是因为代理节点一般和后端服务器（组）处于同一个内部网络，内网之间还是比较安全的，使用 <code>ssl</code> 机制会极大的增加连接建立时间，得不偿失。我们只需要保证客户端到代理节点之间的通信是安全加密的就可以了。</p>
<h1 id="Nginx-从入门到企业实战（四）"><a href="#Nginx-从入门到企业实战（四）" class="headerlink" title="Nginx 从入门到企业实战（四）"></a><code>Nginx</code> 从入门到企业实战（四）</h1><h2 id="Nginx-企业级用法"><a href="#Nginx-企业级用法" class="headerlink" title="Nginx 企业级用法"></a><code>Nginx</code> 企业级用法</h2><h3 id="1-Nginx-与-Fast-CGI-构建高速-Web-站点"><a href="#1-Nginx-与-Fast-CGI-构建高速-Web-站点" class="headerlink" title="1. Nginx 与 Fast CGI 构建高速 Web 站点"></a>1. <code>Nginx</code> 与 <code>Fast CGI</code> 构建高速 <code>Web</code> 站点</h3><p>我们在生产运维最熟悉的名词莫过于 <code>LNMP</code> 或者 <code>LAMP</code> ，其中 <code>N</code> 表示 <code>Nginx</code>，而 <code>P</code> 则表示 <code>PHP</code> ，在之前 <code>LAMP</code> 的环境中，<code>Apache</code> 也就是 <code>httpd</code> 支持通过模块的方式调用 <code>php</code> 程序，但是这性能较差，后来出现了 <code>Fast CGI</code> ，而 <code>php-fpm</code> 就是 <code>Fast CGI</code> 的管理器，我们可以在 <code>PHP 5.3.2</code> 及更新版本中直接开启并使用即可。</p>
<p><code>PHP-CGI</code> 解释器每进程消耗 <code>7~25M</code> 内存，生产中我们一般按照 <code>30M</code> 来估计一个进程占用内存，根据机器的内存空间，来进行进程参数的调整。</p>
<blockquote>
<p><code>Fast CGI</code> 是一个常驻的 <code>CGI (Common Gateway Interface)</code> ，它可以一直执行，只要激活后，不会每次都要花费时间去 <code>fork</code> 一次（这是 <code>CGI</code> 最为人诟病的 <code>fork-and-execute</code> 模式）。它还支持分布式的运算，即 <code>Fast CGI</code> 程序可以在网站服务器以外的主机上执行并且接受来自其他网站服务器来的请求。</p>
<p><code>Fast CGI</code> 其主要行为是将 <code>CGI</code> 解释器进程保持在内存中并因此获得较高的性能。我们知道，<code>CGI</code> 解释器的反复加载是 <code>CGI</code> 性能低下的主要原因，如果 <code>CGI</code> 解释器保存在内存中并接受 <code>Fast CGI</code> 进程管理器调度，那么就可以提供良好的性能、伸缩性等。</p>
</blockquote>
<p>我们不侧重介绍 <code>php-fpm</code> ，只简单的介绍下安装和简单优化，重点内容还是 <code>Nginx</code> 与 <code>php-fpm</code> 之间的交互。我们在 <code>10.4.7.101</code> 节点上通过 <code>yum</code> 源安装 <code>php-fpm</code> ，目前 <code>CentOS-7 -Updates</code> 源中最新版本为 <code>php-fpm-5.4.16-48.el7.x86_64</code> 。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@b ~]# rpm -ql php-fpm</span><br><span class="line">/etc/logrotate.d/php-fpm</span><br><span class="line">/etc/php-fpm.conf</span><br><span class="line">/etc/php-fpm.d</span><br><span class="line">/etc/php-fpm.d/www.conf</span><br><span class="line">/etc/sysconfig/php-fpm</span><br><span class="line">/run/php-fpm</span><br><span class="line">/usr/lib/systemd/system/php-fpm.service</span><br><span class="line">/usr/lib/tmpfiles.d/php-fpm.conf</span><br><span class="line">/usr/sbin/php-fpm</span><br><span class="line">/usr/share/doc/php-fpm-5.4.16</span><br><span class="line">/usr/share/doc/php-fpm-5.4.16/fpm_LICENSE</span><br><span class="line">/usr/share/doc/php-fpm-5.4.16/php-fpm.conf.default</span><br><span class="line">/usr/share/fpm</span><br><span class="line">/usr/share/fpm/status.html</span><br><span class="line">/usr/share/man/man8/php-fpm.8.gz</span><br><span class="line">/var/log/php-fpm</span><br></pre></td></tr></table></figure>

<p>其中 <code>/etc/php-fpm.conf</code> 为 <code>php-fpm</code> 的主配置文件，但是其中 <code>php-fpm.d/www.conf</code> 才是我们需要关注的。有几个参数需要我们关注：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen	= <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br></pre></td></tr></table></figure>

<p>设定 <code>php-fpm</code> 监听地址，如果是非本地访问，那么需要修改此监听地址。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen.allowed_clients = <span class="number">127.0</span>.<span class="number">0.1</span></span><br></pre></td></tr></table></figure>

<p>设置允许连接 <code>php-fpm</code> 的客户端地址，多个 <code>IP</code> 地址需要使用逗号 <code>,</code> 隔开，也可以设置为空或者 <code>any</code> 表示允许所有地址连接。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user = apache</span><br><span class="line">group = apache</span><br></pre></td></tr></table></figure>

<p>设置启用 <code>php-fpm</code> 进程的用户和组。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm = <span class="built_in">static</span>|dynamic</span><br></pre></td></tr></table></figure>

<p>设置进程管理方式，可以选址静态 <code>static</code> 或者动态 <code>dynamic</code> ，一般在服务器内存比较小的情况下，选择使用 <code>dynamic</code> ，而如果内存比较充足，又是专用 <code>php-fpm</code> 服务器，可以使用 <code>static</code> ，性能会更好一些。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.max_children = <span class="number">50</span></span><br></pre></td></tr></table></figure>

<p>最大 <code>php-fpm</code> 子进程数，如果是 <code>pm - static</code> ，该值表示 <code>static</code> 固定的子进程数。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.start_servers = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>设置初始启动时的 <code>php-fpm</code> 子进程数，默认情况下，<code>pm.start_servers</code> = <code>min_spare_servers + (max_spare_servers - min_spare_servers) / 2 </code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.min_spare_servers = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>设置空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.max_spare_servers = <span class="number">35</span></span><br></pre></td></tr></table></figure>

<p>设置空闲进程数量最大值，如果空闲进程大于此值，则进行清理。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.max_requests = <span class="number">500</span></span><br></pre></td></tr></table></figure>

<p>设置每个子进程重新创建之前服务的请求数。即当一个 <code>PHP-CGI</code> 进程处理的请求数累积到 <code>500</code> 个后，自动重新启动该进程。对于可能存在内存泄漏的第三方模块来说是非常有用的。如果设置为 <code>0</code> 则一直接受请求。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pm.status_path = /status</span><br></pre></td></tr></table></figure>

<p>设置 <code>php-fpm</code> 状态页面的网址。如果没有设置，则无法访问状态页面。<code>Default Value: not set</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping.path = /ping</span><br></pre></td></tr></table></figure>

<p>设置 <code>php-fpm</code> 监控页面的 <code>ping</code> 网址，如果没有设置，则无法访问 <code>ping</code> 页面。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping.response = pong</span><br></pre></td></tr></table></figure>

<p>用于定义 <code>ping</code> 请求的返回相应，返回为 <code>HTTP 200</code> 的 <code>text/plain</code> 格式文本，默认值：<code>pong</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_slowlog_timeout = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>当一个请求超过该设置的超时时间后，就会将对应的 <code>PHP</code> 调用堆栈信息完整写入到慢日志中。设置为 <code>0</code> 表示 <code>off</code></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_terminate_timeout = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>设置单个请求的超时中止时间。该选项可能会对 <code>php.ini</code> 设置中的 <code>max_execution_time</code> 因为某些特殊原因没有中止运行的脚本有用。设置为 <code>0</code> 表示 <code>off</code> 。当经常出现 <code>502</code> 错误时可以尝试更改此选项。</p>
<blockquote>
<p>注意：此时 <code>Nginx</code> 作为代理服务器响应给客户端 <code>502</code> 代码，是因为 <code>php</code> 进程执行超时，被强制终止，导致无法响应 <code>Nginx</code> 代理进程。</p>
</blockquote>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlimit_files = <span class="number">1024</span></span><br></pre></td></tr></table></figure>

<p>设置文件打开描述符的 <code>rlimit</code> 限制，可以使用 <code>ulimit -n</code> 查看。</p>
<p>示例配置：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[www]</span><br><span class="line">listen = <span class="number">9009</span></span><br><span class="line">listen.allowed_clients = <span class="number">127.0</span>.<span class="number">0.1</span>,<span class="number">10.4</span>.<span class="number">7.100</span></span><br><span class="line">user = apache</span><br><span class="line">group = apache</span><br><span class="line">pm = dynamic</span><br><span class="line">pm.max_children = <span class="number">50</span></span><br><span class="line">pm.start_servers = <span class="number">20</span></span><br><span class="line">pm.min_spare_servers = <span class="number">5</span></span><br><span class="line">pm.max_spare_servers = <span class="number">35</span></span><br><span class="line">pm.max_requests = <span class="number">10240</span></span><br><span class="line">request_terminate_timeout = <span class="number">10</span></span><br><span class="line">request_slowlog_timeout = <span class="number">10</span></span><br><span class="line">slowlog = /<span class="keyword">var</span>/log/php-fpm/www-slow.log</span><br><span class="line">php_admin_value[error_log] = /<span class="keyword">var</span>/log/php-fpm/www-error.log</span><br><span class="line">php_admin_flag[log_errors] = on</span><br><span class="line">php_value[session.save_handler] = files</span><br><span class="line">php_value[session.save_path] = /<span class="keyword">var</span>/lib/php/session</span><br></pre></td></tr></table></figure>

<p>重启或者重载 <code>php-fpm</code> 进程。关于 <code>php-fpm</code> 的知识我们先简单介绍到这。</p>
<p><code>Nginx</code> 不像 <code>httpd</code> 可以通过模块调用 <code>php</code> 程序，他需要通过和 <code>php-fpm</code> 进程进行通信，来实现 <code>php</code> 代码的调用。而在 <code>Nginx</code> 中，我们通过 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html">ngx_http_fastcgi_module</a> 模块与 <code>php-fpm</code> 进程来实现通信交互。该模块的很多用法、指令都和 <code>ngx_http_proxy_module</code> 模块非常接近，其实两个模块就是为了和后端不同协议 (<code>http</code> &amp; <code>FastCGI</code>) 进行交互而设计的。我们直接给出一个生产案例配置，相信有了前面 <code>ngx_http_proxy_module</code> 模块的学习，理解这个案例应该很简单。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span>			/var/cache/nginx/proxy_cache</span><br><span class="line">							levels=<span class="number">1</span>:<span class="number">2</span>    keys_zone=proxycache:<span class="number">20m</span></span><br><span class="line">							inactive=<span class="number">300s</span> max_size=<span class="number">1g</span>;</span><br><span class="line"><span class="attribute">proxy_connect_timeout</span>		<span class="number">15s</span>;</span><br><span class="line"><span class="attribute">proxy_send_timeout</span>			<span class="number">10s</span>;</span><br><span class="line"><span class="attribute">proxy_read_timeout</span>			<span class="number">10s</span>;</span><br><span class="line"><span class="comment">#---------------------------------------------------------------------------</span></span><br><span class="line"><span class="attribute">fastcgi_cache_path</span>			/var/cache/nginx/fcgi_cache</span><br><span class="line">							levels=<span class="number">1</span>:<span class="number">2</span>:<span class="number">1</span> keys_zone=fcgicache:<span class="number">20m</span></span><br><span class="line">							inactive=<span class="number">300s</span> max_size=<span class="number">1g</span>;</span><br><span class="line"><span class="attribute">fastcgi_connect_timeout</span>		<span class="number">15s</span>;</span><br><span class="line"><span class="attribute">fastcgi_send_timeout</span>		<span class="number">15s</span>;</span><br><span class="line"><span class="attribute">fastcgi_read_timeout</span>		<span class="number">15s</span>;</span><br><span class="line"><span class="attribute">fastcgi_keep_conn</span>			<span class="literal">on</span>;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>					<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>				a.host.com;</span><br><span class="line">    <span class="attribute">root</span>					/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>					utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>				index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>			http://b.host.com:8080;</span><br><span class="line">        <span class="attribute">proxy_cache</span>			proxycache;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span>	<span class="number">200</span>	<span class="number">302</span>	<span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span>	<span class="number">301</span>	<span class="number">1h</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span>	any <span class="number">1m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> <span class="regexp">~* \.php$</span> &#123;</span><br><span class="line">        <span class="attribute">fastcgi_pass</span>		<span class="number">10.4.7.101:9009</span>;</span><br><span class="line">        <span class="attribute">fastcgi_index</span>		index.php;</span><br><span class="line">        <span class="attribute">fastcgi_param</span>		SCRIPF_FILENAME		/data/nginx/app-php/<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        <span class="attribute">include</span>				/etc/nginx/fastcgi_params;</span><br><span class="line">        <span class="attribute">fastcgi_cache</span>		fcgicache;</span><br><span class="line">        <span class="attribute">fastcgi_cache_key</span>	<span class="variable">$request_uri</span>;</span><br><span class="line">        <span class="attribute">fastcgi_cache_valid</span>	<span class="number">200</span>	<span class="number">302</span>	<span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">fastcgi_cache_valid</span> <span class="number">301</span>	<span class="number">1h</span>;</span><br><span class="line">        <span class="attribute">fastcgi_cache_valid</span>	any	<span class="number">1m</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在配置完成 <code>Nginx+FastCGI</code> 之后，为了保证 <code>Nginx</code> 下 <code>PHP</code> 环境的高速稳定运行，需要添加一些 <code>FastCGI</code> 优化指令。下面给出一个优化实例，将下面代码添加到 <code>Nginx</code> 主配置文件中的 <code>HTTP</code> 层级。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastcgi_cache_path</span> /usr/local/nginx/fastcgi_cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=TEST:<span class="number">10m</span> inactive=<span class="number">5m</span>;    </span><br><span class="line"><span class="attribute">fastcgi_connect_timeout</span> <span class="number">300</span>;</span><br><span class="line"><span class="attribute">fastcgi_send_timeout</span> <span class="number">300</span>; </span><br><span class="line"><span class="attribute">fastcgi_read_timeout</span> <span class="number">300</span>;  </span><br><span class="line"><span class="attribute">fastcgi_buffer_size</span> <span class="number">64k</span>;</span><br><span class="line"><span class="attribute">fastcgi_buffers</span> <span class="number">4</span> <span class="number">64k</span>; </span><br><span class="line"><span class="attribute">fastcgi_busy_buffers_size</span> <span class="number">128k</span>;   </span><br><span class="line"><span class="attribute">fastcgi_temp_file_write_size</span> <span class="number">128k</span>;    </span><br><span class="line"><span class="attribute">fastcgi_cache</span> TEST;</span><br><span class="line"><span class="attribute">fastcgi_cache_valid</span> <span class="number">200</span> <span class="number">302</span> <span class="number">1h</span>;</span><br><span class="line"><span class="attribute">fastcgi_cache_valid</span> <span class="number">301</span> <span class="number">1d</span>;</span><br><span class="line"><span class="attribute">fastcgi_cache_valid</span> any <span class="number">1m</span>;     </span><br></pre></td></tr></table></figure>

<p>下面是对上述代码的含义进行介绍。</p>
<ul>
<li><p>第一行代码是为 <code>FastCGI</code> 缓存指定一个文件路径、目录结构等级、关键字区域存储时间和非活动删除时间。</p>
</li>
<li><p><code>fastcgi_connect_timeout</code> 指定连接到后端 <code>FastCGI</code> 的超时时间。</p>
</li>
<li><p><code>fastcgi_send_timeout</code> 指定向 <code>FastCGI</code> 传送请求的超时时间，这个值是已经完成两次握手后向 <code>FastCGI</code> 传送请求的超时时间。</p>
</li>
<li><p><code>fastcgi_read_timeout</code> 指定接收 <code>FastCGI</code> 应答的超时时间，这个值是已经完成两次握手后接收 <code>FastCGI</code> 应答的超时时间。</p>
</li>
<li><p><code>fastcgi_buffer_size</code> 用于指定读取 <code>FastCGI</code> 应答第一部分需要用多大的缓冲区，这个值表示将使用 <code>1</code> 个 <code>64KB</code> 的缓冲区读取应答的第一部分（应答头），可以设置为 <code>fastcgi_buffers</code> 选项指定的缓冲区大小。</p>
</li>
<li><p><code>fastcgi_buffers</code> 指定本地需要用多少和多大的缓冲区来缓冲 <code>FastCGI</code> 的应答请求。如果一个 <code>PHP</code> 脚本所产生的页面大小为 <code>256KB</code>，那么会为其分配 <code>4</code> 个 <code>64KB</code> 的缓冲区来缓存；如果页面大小大于 <code>256KB</code>，那么大于<code>256KB</code> 的部分会缓存到 <code>fastcgi_temp</code> 指定的路径中，但是这并不是好方法，因为内存中的数据处理速度要快于硬盘。一般这个值应该为站点中 <code>PHP</code> 脚本所产生的页面大小的中间值，如果站点大部分脚本所产生的页面大小为 <code>256KB</code> ，那么可以把这个值设置为 <code>“16 16k”、“4 64k”</code> 等。</p>
</li>
<li><p><code>fastcgi_busy_buffers_size</code> 的默认值是 <code>fastcgi_buffers</code> 的两倍。</p>
</li>
<li><p><code>fastcgi_temp_file_write_size</code> 表示在写入缓存文件时使用多大的数据块，默认值是 <code>fastcgi_buffers</code> 的两倍。</p>
</li>
<li><p><code>fastcgi_cache</code> 表示开启 <code>FastCGI</code> 缓存并为其指定一个名称。开启缓存非常有用，可以有效降低 <code>CPU</code> 的负载，并且防止 <code>502</code> 错误的发生，但是开启缓存也会引起很多问题，要视具体情况而定。</p>
</li>
<li><p><code>fastcgi_cache_valid</code>、<code>fastcgi</code> 用来指定应答代码的缓存时间，实例中的值表示将 <code>200</code> 和 <code>302</code> 应答缓存一个小时，将 <code>301</code> 应答缓存1天，其他应答均缓存 <code>1</code> 分钟。</p>
</li>
</ul>
<p>这里还有几个需要补充的参数，需要跟大家介绍下：</p>
<p>**<code>fastcgi_pass</code>**：设置后端 <code>FastCGI</code> 服务器的地址，注意后端支持 <code>地址+端口</code> 或者 <code>Unix Socket</code> ，但是不要加 <code>https(s)</code> 或者后面加上 <code>uri</code> ，因为这代理的是 <code>FastCGI</code> 协议，而不是 <code>http(s)</code> 协议。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">fastcgi_pass</span> address;</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="section">location</span>, if in <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastcgi_pass</span>	locathost:<span class="number">9000</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>**<code>fastcgi_index</code>**：用来设置 <code>FastCGI</code> 服务器默认的主页资源，跟我们前面介绍的 <code>index</code> 类似。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">fastcgi_index</span>	name;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastcgi_index</span>	index.php;</span><br></pre></td></tr></table></figure>

<hr>
<p>**<code>fastcgi_param</code>**：设置发往后端 <code>FastCGI</code> 服务器的参数，需要设置的参数很多，不过绝大多数都已经被写入到默认配置文件中了。其中有一条参数非常非常重要，即：</p>
<p><strong>核心传参：<code>fastcgi_param SCRIPT_FILENAME /path/to/PHP-FILE/$fastcgi_script_name;</code> 非常重要</strong></p>
<p>注意：后面的路径一定要写你的 <code>PHP</code> 代码所在的位置，其中 <code>$fastcgi_script_name</code> 会是你访问的 <code>PHP</code> 文件名。</p>
<p>其他的一些参数默认已经被放在 <code>/etc/nginx/fastcgi_params</code> 文件中了，可以使用绝对路径，也可以使用相对路径（相对于 <code>/etc/nginx</code>）。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">fastcgi_param</span> parameter value [if_not_empty];</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastcgi_param</span>	SCRIPT_FILENAME		/data/nginx/app-php/<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line"><span class="attribute">include</span>		/etc/nginx/fastcgi_params;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="fastcgi-keep-conn"><a href="#fastcgi-keep-conn" class="headerlink" title="fastcgi_keep_conn"></a>fastcgi_keep_conn</h4><p>**<code>fastcgi_keep_conn</code>**：用来设置在收到后端服务器响应时，是否立刻关闭连接。默认是 <code>off</code>，最好修改为 <code>on</code> ，表示与后端服务器开启长连接。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">fastcgi_keep_conn</span> <span class="literal">on</span> | <span class="literal">off</span>;</span><br><span class="line">Default: <span class="attribute">fastcgi_keep_conn</span> <span class="literal">off</span>;</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">1</span>.<span class="number">4</span>.</span><br></pre></td></tr></table></figure>

<h4 id="fastcgi-cache-key"><a href="#fastcgi-cache-key" class="headerlink" title="fastcgi_cache_key"></a>fastcgi_cache_key</h4><p>**<code>fastcgi_cache_key</code>**：这个参数需要提及一下，因为在前面 <code>proxy_cache_key</code> 是有默认值的，但是在 <code>fastcgi_module</code> 中没有默认值，需要大家手动设置。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">fastcgi_cache_key</span>	string;</span><br><span class="line">Default: -</span><br><span class="line">Context: http, server, <span class="section">location</span></span><br></pre></td></tr></table></figure>

<p>比如，你可以这样设置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastcgi_cache_key</span>	localhost:<span class="number">900</span><span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure>

<p>其他一些参数这里就不一一介绍了，需要注意的是，开启 <code>fastcgi_cache</code> 会极大的提升性能。生产中一般会通过脚本程序每天定时获取一次页面，以便生产缓存数据（缓存下来的数据为静态页面），提升用户访问速度。</p>
<hr>
<h3 id="2-配置Nginx后端集群环境"><a href="#2-配置Nginx后端集群环境" class="headerlink" title="2. 配置Nginx后端集群环境"></a>2. 配置Nginx后端集群环境</h3><p>在并发量较大的环境下，一般我们会选择横向升级多个节点来解决访问压力问题，在 <code>Nginx</code> 代理设置中，其实也有相应的模块来设定多个后端节点。前面我们跟大家演示的都是单台 <code>Web</code> 或者单台后端节点，下面我们就为大家演示后端集群的代理配置。这里需要引入模块<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html">ngx_http_upstream_module</a>。注意该模块是用来定义后端一组服务器，可以支持的协议除了 <code>http(proxy_pass)</code> 外还有 <code>FastCGI(fastcgi_pass)</code> 、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_uwsgi_module.html%23uwsgi_pass">uwsgi_pass</a>、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_scgi_module.html%23scgi_pass">scgi_pass</a>、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_memcached_module.html%23memcached_pass">memcache_pass</a> 等代理协议。配置示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com		weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com:<span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">server</span> backup1.example.com:<span class="number">8080</span> backup;</span><br><span class="line">    <span class="attribute">server</span> backup2.example.com:<span class="number">8080</span> backup;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>  http://backend;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述配置为最基本用法，我们将对一些常见的配置参数进行介绍。</p>
<p>**<code>upstream</code>**：用来定义一组服务器。这些服务器可以监听不同的端口。而且，监听在 <code>TCP</code> 和 <code>UNIX</code> 域套接字的服务器可以混用。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="section">upstream</span> name &#123; ... &#125;</span><br><span class="line">Default: -</span><br><span class="line">Context: http</span><br></pre></td></tr></table></figure>

<p>示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> backend1.example.com  weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>        max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">server</span> backup1.example.com  backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>nginx</code> 按加权轮转的方式将请求分发到各服务器。在上面的例子中，每 <code>7</code> 个请求会通过以下方式分发：<code>5</code> 个请求分到 <code>backend1.example.com</code> ，一个请求分到第二个服务器，一个请求分到第二个服务器，一个请求分到第三个服务器。与服务器通信的时候，如果出现错误，请求会传给下一个服务器，直到所有可用的服务器都被尝试过。如果所有服务器都返回失败，客户端将会得到最后通信的那个服务器的（失败）响应结果。</p>
<hr>
<p>**<code>server</code>**：定义服务器的地址 <code>address</code> 和其他参数 <code>parameters</code> 。地址可以是域名或者 <code>IP</code> 地址，端口是可选的，或者是指定 <code>unix:</code> 前缀的 <code>UNIX</code> 域套接字的路径。如果没有指定端口，就使用 <code>80</code> 端口。如果一个域名解析到多个 <code>IP</code> ，本质上是定义了多个 <code>server</code>。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">server</span> address [parameters];</span><br><span class="line">Default: - </span><br><span class="line">Context: <span class="section">upstream</span></span><br></pre></td></tr></table></figure>

<p>可用参数：</p>
<ul>
<li><code>weight</code> ：设定服务器的权重，默认是 <code>1</code> ，权重越大，匹配 <code>server</code> 的几率越高。比如：<code>weight=5</code> 所访问的 <code>server</code> 大几率访问 <code>5</code> 次且都会命中 <code>server</code> 的服务器上。 </li>
<li><code>max_conns</code> ：设置后端服务器最大活动连接数，在 <code>Nginx 1.11.5</code> 版本之后支持，默认为 <code>0</code> 表示不限制。</li>
<li><code>max_fails</code> ：设定 <code>Nginx</code> 与后端服务器通信的尝试失败的次数。在 <code>fail_timeout</code> 参数定义的时间段内，如果失败的次数达到此值，<code>Nginx</code> 就认为服务器不可用。在下一个 <code>fail_timeout</code> 时间段，服务器不会再被尝试。失败的尝试次数默认是 <code>1</code> 。设为 <code>0</code> 就会停止统计尝试次数，认为服务器是一直可用的。</li>
<li><code>fail_timeout</code> ：用来设定下面两个时间值：<ul>
<li>统计失败尝试次数的时间段。在这段时间中，服务器失败次数达到 <code>max_fails</code> 指定的尝试次数，服务器就被认为不可用。</li>
<li>服务器被认为不可用的时间段，即一旦被标记为不可用，则在下一个 <code>fail_timeout</code> 时间段内都不会再尝试与此服务器进行连接。</li>
</ul>
</li>
<li><code>backup</code> ：标记为备用服务器。当所有的主服务器不可用以后，请求会被传给这些备用服务器。该参数不可与 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html%23hash"><code>hash</code></a>、<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html%23ip_hash"><code>ip_hash</code></a>、and <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html%23random"><code>random</code></a> 等负载均衡方法一起使用。</li>
<li><code>down</code> ：标记服务器为永久不可用，可以配合 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html%23ip_hash"><code>ip_hash</code></a> 实现灰度发布。</li>
</ul>
<p>还有些参数不常使用，我们就不介绍了，参考 <a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_upstream_module.html%23server">官方文档</a>。</p>
<hr>
<p>**<code>hash</code>**：基于某个 <code>key</code> 的 <code>hash</code> 表 实现请求的后端调度，此处的 <code>key</code> 可以是文本、变量或者二者的结合。</p>
<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">hash</span> key [consistent];</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="section">upstream</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">7</span>.<span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<p>注意：该指令的核心功能可以让我们对请求进行分类，让同一种请求发完到同一个 <code>upstream server</code>，非常实用与后端为 <strong>缓存服务器</strong> （比如 <code>squid</code> 或者 <code>varnish</code> ）的情况。比如我们可以这样配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hash</span> <span class="variable">$request_uri</span>;</span><br></pre></td></tr></table></figure>

<p>但是这样配置有一个核心问题，一旦后端新增或者删除某个节点，可以导致所有缓存都无法命中，造成缓存穿透，出现 “雪崩”等重点故障。不过，也不用担心，我们可以通过添加参数 <code>consistent</code> 参数来实现一致性 <code>hash</code> 算法，将影响降到最低。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">hash</span> <span class="variable">$request_uri</span> consistent;</span><br></pre></td></tr></table></figure>

<p>关于 <code>hash</code> 算法和一致性 <code>hash</code> 算法介绍：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210228233501089.png" alt="image-20210228232929792"></p>
<p>普通 <code>hash</code> 算法，通过将用户请求计算出 <code>hash</code> 值，然后将该 <code>hash</code> 值与节点数量 <code>N</code> 取余，得出请求落到的节点位置。算法非常精确，但是一但节点数据发送变化，可能导致所有缓存数据失效——<strong>于是引入了“一致性 hash 算法”</strong>。</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210228232929792.png" alt="image-20210228233501089"></p>
<p>通过引入了 <code>hash 环</code> （<code>2^32</code> 个位置）的概念，这里涉及到两次 <code>hash</code> 运算，以示对用户请求进行 <code>hash</code> 运算，得出的值与 <code>2^32</code> 取余，会落在环上的某个位置，该位置固定。另外一次是对节点加权后进行 <code>hash</code> 运算，比如：</p>
<p><code>server A weight=1</code> 、<code>server B weight=2</code> 、<code>server C weight=3</code> ，那么节点 <code>A</code> 就会对 <code>hash(A-IP)</code> 得出一个 <code>hash</code> 值；对于节点 <code>B</code> ，就会对 <code>hash(B-IP)</code> 和 <code>hash(B-IP +1)</code> 计算，得出两个 <code>hash</code> 值，依次类推节点 <code>C</code> 。然后三个节点的 <code>hash</code> 值再与 <code>2^32</code> 求余，得出的值也一定会落在 <code>hash</code> 环，且出现的概率与权重有直接关系。然后将请求数据计算出的落点顺时针移动，离该落点最近的节点 <code>hash</code> 求余后的落点，即为请求调度的后端节点。</p>
<p>这样即使一个节点失效，影响只是离该节点位置最近的一些请求落点，而不会导致全局后端节点失效。</p>
<p>解决了这个问题，大家很快发现还有一个问题比较严重，如果：</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210228235334480.png" alt="image-20210228235334480"></p>
<p>即：理想情况下，对节点的 <code>hash</code> 计算落地是均匀分布在 <code>hash</code> 环上，这样可以保证请求调度到各个节点上的几率趋于为均衡状态，但是实际情况几乎不可能实现这种均匀分布，而且极端情况下可能会某个节点（或者多个节点）的多权重位置相近，这就导致调度请求的极不平衡，那这种情况该如何解决呢？</p>
<p><img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210301000312075.png" alt="image-20210301000312075"></p>
<p>即：通过引入虚拟节点的方式来实现。我们知道分配不均衡很大程度上是因为数据量太小（就像抛硬币，当抛的次数越多，正反面的概率就越接近 <code>1:1</code> 平衡），那么我们就可以通过按比例增加服务器的权重来实现这种平衡性。即把服务器的权重全部乘以 <code>100</code> ，那么各服务器之间的权重比率还是不变的。这样就使得我们的 <code>hash</code> 环比较平衡。</p>
<p><a target="_blank" rel="noopener" href="https://www.zsythink.net/archives/1182">白话解析：一致性 <code>hash</code> 算法</a></p>
<hr>
<p>**<code>ip_hash</code>**：指定服务器组的负载均衡（调度）方法，请求基于客户端的 <code>IP</code> 地址在服务器间进行分发。<code>IPv4</code> 地址的前三个字节或者 <code>IPv6</code> 的整个地址，会被用来作为一个散列 <code>key</code> 。这种方法可以确保从同一个客户端过来的请求，会被传给同一台服务器。处理当服务器被认为不可用的时候，这些客户端的请求会被传给其他服务器，而且很有可能也是同一台服务器。基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: ip_hash;</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="section">upstream</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意1：从 <code>1.3.2</code> 和 <code>1.2.2</code> 版本开始支持 <code>IPv6</code> 地址。</p>
<p>注意2：从 <code>1.3.1</code> 和 <code>1.2.2</code> 版本开始，<code>ip_hash</code> 的负载均衡方法才支持设置服务器权重值。</p>
</blockquote>
<p>如果其中一个服务器想暂时移除或者进行灰度发布，应该加上 <code>down</code> 参数。这样可以保留当前客户端 <code>IP</code> 地址散列分布。</p>
<p>例子：</p>
<blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="section">upstream</span> backend &#123;</span><br><span class="line">   ip_hash;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">server</span> backend1.example.com;</span><br><span class="line">   <span class="attribute">server</span> backend2.example.com;</span><br><span class="line">   <span class="attribute">server</span> backend3.example.com down;</span><br><span class="line">   <span class="attribute">server</span> backend4.example.com;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意：<code>ip_hash</code> 也是一致性 <code>hash</code> 算法，主要区别是这里以客户端源 <code>IP</code> 地址（而非 <code>hash consistent</code> 中用户请求的 <code>key</code> ）进行 <code>hash</code> 运算。</p>
<hr>
<p>**<code>keepalive</code>**：为每个 <code>worker</code> 进程保留的空闲长连接数量，这些长连接会被放入缓存，可以节约 <code>Nginx</code> （作为客户端）端口，并减少连接管理的消耗。如果连接数大于这个值时。最久未使用的连接会被关闭。</p>
<blockquote>
<p>需要注意的是，<code>keepalive</code> 指令不会限制 <code>Nginx</code> 进程与上游服务器的连接总数。新的连接总会按需被创建。<code>connections</code> 参数应该稍微设低一点，以便上游服务器也能处理额外新进来的连接。</p>
</blockquote>
<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">keepalive</span> connections;</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="section">upstream</span></span><br><span class="line">This directive appeared in version <span class="number">1</span>.<span class="number">1</span>.<span class="number">4</span>.</span><br></pre></td></tr></table></figure>

<p>另外，我们在 <code>http</code> 或者 <code>FastCGI</code> 的代理中使用该指令，还有一些需要特别注意的点：</p>
<p><strong>对于 <code>HTTP</code> 代理，<a target="_blank" rel="noopener" href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html%23proxy_http_version"><code>proxy_http_version</code></a> 指令应该设置为 <code>1.1</code> ，同时 <code>Connection</code> 头的值也应被清空。</strong></p>
<blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="section">upstream</span> http_backend &#123;</span><br><span class="line">   <span class="attribute">server</span> <span class="number">127.0.0.1:8080</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">keepalive</span> <span class="number">16</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="section">server</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="section">location</span> /http/ &#123;</span><br><span class="line">       <span class="attribute">proxy_pass</span>  http://http_backend;</span><br><span class="line">       <span class="attribute">proxy_http_version</span> <span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">       <span class="attribute">proxy_set_header</span> Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> http_server &#123;</span><br><span class="line">    <span class="attribute">server</span>    	<span class="number">10.4.7.101:8080</span>;</span><br><span class="line">    <span class="attribute">server</span>    	<span class="number">10.4.7.101:8088</span>;</span><br><span class="line">    <span class="attribute">keepalive</span> 	<span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>    	<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>	a.host.com;</span><br><span class="line">    <span class="attribute">root</span>		/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>		utf-<span class="number">8</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>	index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /api/ &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span>	http://http_server;</span><br><span class="line">        <span class="attribute">proxy_set_header</span>	Connection <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="attribute">proxy_http_version</span>	<span class="number">1</span>.<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font size=3 color=red>抓包：<code>tcpdump -i ens32 -nn -vv tcp and port 8080</code></font></p>
<p>可以看到请求协议为 <code>http 1.1</code> ，默认为 <code>http 1.0</code> ，另外，如果不设置 <code>proxy_set_header Connection &quot;&quot;;</code>，则会显示 <code>Connection close</code>。</p>
<p>看下响应报文：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[root@a conf.d]# curl -I a.host.com/api/index.html</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.16.1</span><br><span class="line">Date: Mon, 01 Mar 2021 14:40:58 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 67</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Last-Modified: Sun, 21 Feb 2021 12:15:21 GMT</span><br><span class="line">ETag: &quot;60324ed9-43&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">---------------------------------------------------------------------------</span></span><br><span class="line">[root@b ~]# tcpdump -i ens32 -nn -vv tcp and port 8080</span><br><span class="line">tcpdump: listening on ens32, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">09:40:58.545653 IP (tos 0x0, ttl 64, id 24691, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.4.7.100.57192 &gt; 10.4.7.101.8080: Flags [S], cksum 0xc65c (correct), seq 1756148267, win 29200, options [mss 1460,sackOK,TS val 10080856 ecr 0,nop,wscale 7], length 0</span><br><span class="line">09:40:58.545753 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57192: Flags [S.], cksum 0x22ff (incorrect -&gt; 0x31d7), seq 793879782, ack 1756148268, win 28960, options [mss 1460,sackOK,TS val 10076307 ecr 10080856,nop,wscale 7], length 0</span><br><span class="line">09:40:58.546064 IP (tos 0x0, ttl 64, id 24692, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.100.57192 &gt; 10.4.7.101.8080: Flags [.], cksum 0xd0dd (correct), seq 1, ack 1, win 229, options [nop,nop,TS val 10080857 ecr 10076307], length 0</span><br><span class="line">09:40:58.546194 IP (tos 0x0, ttl 64, id 24693, offset 0, flags [DF], proto TCP (6), length 142)</span><br><span class="line">    10.4.7.100.57192 &gt; 10.4.7.101.8080: Flags [P.], cksum 0x884f (correct), seq 1:91, ack 1, win 229, options [nop,nop,TS val 10080857 ecr 10076307], length 90: HTTP, length: 90</span><br><span class="line">	HEAD /api/index.html HTTP/1.1</span><br><span class="line">	Host: http_server</span><br><span class="line">	User-Agent: curl/7.29.0</span><br><span class="line">	Accept: */*</span><br><span class="line">	</span><br><span class="line">09:40:58.546219 IP (tos 0x0, ttl 64, id 25715, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57192: Flags [.], cksum 0x22f7 (incorrect -&gt; 0xd084), seq 1, ack 91, win 227, options [nop,nop,TS val 10076308 ecr 10080857], length 0</span><br><span class="line">09:40:58.546689 IP (tos 0x0, ttl 64, id 25716, offset 0, flags [DF], proto TCP (6), length 303)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57192: Flags [P.], cksum 0x23f2 (incorrect -&gt; 0x8eec), seq 1:252, ack 91, win 227, options [nop,nop,TS val 10076308 ecr 10080857], length 251: HTTP, length: 251</span><br><span class="line">	HTTP/1.1 200 OK</span><br><span class="line">	Server: nginx/1.16.1</span><br><span class="line">	Date: Mon, 01 Mar 2021 14:40:58 GMT</span><br><span class="line">	Content-Type: text/html; charset=utf-8</span><br><span class="line">	Content-Length: 67</span><br><span class="line">	Last-Modified: Sun, 21 Feb 2021 12:15:21 GMT</span><br><span class="line">	Connection: keep-alive</span><br><span class="line">	ETag: &quot;60324ed9-43&quot;</span><br><span class="line">	Accept-Ranges: bytes</span><br><span class="line">	</span><br><span class="line">09:40:58.547045 IP (tos 0x0, ttl 64, id 24694, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.100.57192 &gt; 10.4.7.101.8080: Flags [.], cksum 0xcf7e (correct), seq 91, ack 252, win 237, options [nop,nop,TS val 10080858 ecr 10076308], length 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有设置代理首部和代理协议，则无法使用代理长连接模式，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭 proxy_set_header 和 proxy_http_version</span></span><br><span class="line">[root@b ~]# tcpdump -i ens32 -nn -vv tcp and port 8080</span><br><span class="line">tcpdump: listening on ens32, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">09:36:03.468713 IP (tos 0x0, ttl 64, id 55788, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.4.7.100.57188 &gt; 10.4.7.101.8080: Flags [S], cksum 0xf60f (correct), seq 3815934047, win 29200, options [mss 1460,sackOK,TS val 9785779 ecr 0,nop,wscale 7], length 0</span><br><span class="line">09:36:03.468785 IP (tos 0x0, ttl 64, id 0, offset 0, flags [DF], proto TCP (6), length 60)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57188: Flags [S.], cksum 0x22ff (incorrect -&gt; 0x771b), seq 3903411878, ack 3815934048, win 28960, options [mss 1460,sackOK,TS val 9781230 ecr 9785779,nop,wscale 7], length 0</span><br><span class="line">09:36:03.469094 IP (tos 0x0, ttl 64, id 55789, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.100.57188 &gt; 10.4.7.101.8080: Flags [.], cksum 0x1622 (correct), seq 1, ack 1, win 229, options [nop,nop,TS val 9785780 ecr 9781230], length 0</span><br><span class="line">09:36:03.469220 IP (tos 0x0, ttl 64, id 55790, offset 0, flags [DF], proto TCP (6), length 151)</span><br><span class="line">    10.4.7.100.57188 &gt; 10.4.7.101.8080: Flags [P.], cksum 0x5961 (correct), seq 1:100, ack 1, win 229, options [nop,nop,TS val 9785780 ecr 9781230], length 99: HTTP, length: 99</span><br><span class="line">	HEAD /api/ HTTP/1.0</span><br><span class="line">	Host: http_server</span><br><span class="line">	Connection: close</span><br><span class="line">	User-Agent: curl/7.29.0</span><br><span class="line">	Accept: */*</span><br><span class="line">	</span><br><span class="line">09:36:03.469246 IP (tos 0x0, ttl 64, id 26952, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57188: Flags [.], cksum 0x22f7 (incorrect -&gt; 0x15c0), seq 1, ack 100, win 227, options [nop,nop,TS val 9781231 ecr 9785780], length 0</span><br><span class="line">09:36:03.469778 IP (tos 0x0, ttl 64, id 26953, offset 0, flags [DF], proto TCP (6), length 298)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57188: Flags [P.], cksum 0x23ed (incorrect -&gt; 0xfbd8), seq 1:247, ack 100, win 227, options [nop,nop,TS val 9781231 ecr 9785780], length 246: HTTP, length: 246</span><br><span class="line">	HTTP/1.1 200 OK</span><br><span class="line">	Server: nginx/1.16.1</span><br><span class="line">	Date: Mon, 01 Mar 2021 14:36:03 GMT</span><br><span class="line">	Content-Type: text/html; charset=utf-8</span><br><span class="line">	Content-Length: 67</span><br><span class="line">	Last-Modified: Sun, 21 Feb 2021 12:15:21 GMT</span><br><span class="line">	Connection: close</span><br><span class="line">	ETag: &quot;60324ed9-43&quot;</span><br><span class="line">	Accept-Ranges: bytes</span><br><span class="line">	</span><br><span class="line">09:36:03.469984 IP (tos 0x0, ttl 64, id 26954, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57188: Flags [F.], cksum 0x22f7 (incorrect -&gt; 0x14c8), seq 247, ack 100, win 227, options [nop,nop,TS val 9781232 ecr 9785780], length 0</span><br><span class="line">09:36:03.470065 IP (tos 0x0, ttl 64, id 55791, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.100.57188 &gt; 10.4.7.101.8080: Flags [.], cksum 0x14bf (correct), seq 100, ack 247, win 237, options [nop,nop,TS val 9785781 ecr 9781231], length 0</span><br><span class="line">09:36:03.470379 IP (tos 0x0, ttl 64, id 55792, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.100.57188 &gt; 10.4.7.101.8080: Flags [F.], cksum 0x14bc (correct), seq 100, ack 248, win 237, options [nop,nop,TS val 9785781 ecr 9781232], length 0</span><br><span class="line">09:36:03.470407 IP (tos 0x0, ttl 64, id 26955, offset 0, flags [DF], proto TCP (6), length 52)</span><br><span class="line">    10.4.7.101.8080 &gt; 10.4.7.100.57188: Flags [.], cksum 0x22f7 (incorrect -&gt; 0x14c6), seq 248, ack 101, win 227, options [nop,nop,TS val 9781232 ecr 9785781], length 0</span><br></pre></td></tr></table></figure>

<hr>
<p>对于 <code>FastCGI</code> 的服务器，需要设置 <code>fastcgi_keep_conn</code> 指令来让启动 <code>keepalive</code> 长连接：</p>
<blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="section">upstream</span> fastcgi_backend &#123;</span><br><span class="line">   <span class="attribute">server</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="attribute">keepalive</span>  <span class="number">8</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br><span class="line">&gt;<span class="section">server</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">       <span class="attribute">locaton</span> /fastcgi/ &#123;</span><br><span class="line">       <span class="attribute">fastcgi_pass</span>  fastcgi_backend;</span><br><span class="line">       <span class="attribute">fastcgi_keep_conn</span> <span class="literal">on</span>;</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>注意1：当使用负载均衡方法不是默认的轮转法时，必须在 <code>keepalive</code> 指令之前配置。</strong></p>
<p><strong>注意2：<code>SCGI and uwsgi protocols</code> 还不支持这种长连接形式。</strong></p>
<hr>
<h4 id="least-conn"><a href="#least-conn" class="headerlink" title="least_conn"></a>least_conn</h4><p>**<code>least_conn</code>**：指定服务器组的负载均衡方法，根据其权重值，将请求发送到活跃连接最少的那台服务器。如果这样的服务器有多台，那就采取有权重的轮转法进行尝试。当我们开启长连接时，可以使用这种调度算法。</p>
<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Syntax: least_conn;</span><br><span class="line">Default: -</span><br><span class="line">Context: <span class="section">upstream</span></span><br><span class="line">This directive appeared in versions <span class="number">1</span>.<span class="number">3</span>.<span class="number">1</span> and <span class="number">1</span>.<span class="number">2</span>.<span class="number">2</span>.</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-Nginx-动态编译模块"><a href="#3-Nginx-动态编译模块" class="headerlink" title="3. Nginx 动态编译模块"></a>3. Nginx 动态编译模块</h3><p><code>Nginx 1.9.11</code> 开始增加加载动态模块支持，从此不再需要替换 <code>Nginx</code> 文件即可增加第三方扩展。下面我们来演示动态编译 <a target="_blank" rel="noopener" href="https://github.com/openresty/echo-nginx-module"><code>echo-nginx-module</code></a> 模块，该模块可以直接输出字符串或者变量等信息，非常方便我们调试。下面为执行步骤，以我们通过 <code>EPEL</code> 源安装的 <code>Nginx</code> 为例，为此模块新增 <code>echo_nginx_module</code> 模块。步骤如下：</p>
<h4 id="3-1-下载与-RPM-包相同版本的-Nginx-源文件"><a href="#3-1-下载与-RPM-包相同版本的-Nginx-源文件" class="headerlink" title="3.1 下载与 RPM 包相同版本的 Nginx 源文件"></a>3.1 下载与 <code>RPM</code> 包相同版本的 <code>Nginx</code> 源文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx -v</span></span><br><span class="line">nginx version: nginx/1.16.1</span><br></pre></td></tr></table></figure>

<p>下载 <code>Nginx-1.16.1</code> <a target="_blank" rel="noopener" href="http://nginx.org/download/nginx-1.16.1.tar.gz">源码包</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">wget http://nginx.org/download/nginx-1.16.1.tar.gz</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">tar xf nginx-1.16.1.tar.gz</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line">nginx-1.16.1  nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>

<p>下载需要编译的模块源码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum -y install git</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/openresty/echo-nginx-module.git</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-查看当前-Nginx-已经编译的模块"><a href="#3-2-查看当前-Nginx-已经编译的模块" class="headerlink" title="3.2 查看当前 Nginx 已经编译的模块"></a>3.2 查看当前 <code>Nginx</code> 已经编译的模块</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nginx -V</span></span><br><span class="line"><span class="attribute">nginx</span> version: nginx/<span class="number">1</span>.<span class="number">16</span>.<span class="number">1</span></span><br><span class="line">built by gcc <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span> <span class="number">20150623</span> (Red Hat <span class="number">4</span>.<span class="number">8</span>.<span class="number">5</span>-<span class="number">44</span>) (GCC) </span><br><span class="line">built with OpenSSL <span class="number">1</span>.<span class="number">1</span>.1c FIPS  <span class="number">28</span> May <span class="number">2019</span> (running with OpenSSL <span class="number">1</span>.<span class="number">1</span>.<span class="number">1g</span> FIPS  <span class="number">21</span> Apr <span class="number">2020</span>)</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --<span class="literal">error</span>-log-path=/var/log/nginx/<span class="literal">error</span>.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-stream_ssl_preread_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-http_auth_request_module --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-<span class="literal">debug</span> --with-cc-opt=<span class="string">&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27;</span> --with-ld-opt=<span class="string">&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27;</span></span><br></pre></td></tr></table></figure>

<p>注意：使用源码包编译新的模块需要确保原来 <code>RPM</code> 包中已经还有的模块必须编译进去，否则会出现 <code>is not binary compatible</code> 的报错。</p>
<p>另外，对于上面的编译参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--with-cc-opt=&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27;</span><br></pre></td></tr></table></figure>

<p><code>--with-cc-opt</code> 设置 <code>C</code> 编译器参数；</p>
<p><code>--with-ld-opt</code> 设置链接文件参数；</p>
<p>这两个参数与红帽设置 <code>RPM</code> 文件的一些参数，我们可以通过 <code>yum install redhat-rpm-config</code> 来获取，否则直接编译会出错。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">yum -y install redhat-rpm-config</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-动态编译模块"><a href="#3-3-动态编译模块" class="headerlink" title="3.3 动态编译模块"></a>3.3 动态编译模块</h4><p>有一些包需要提前安装好，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc libxml2 libxml2-devel libxslt libxslt-devel gd gd-devel pcre pcre-devel perl perl-devel openssl openssl-devel perl-ExtUtils-Embed google-perftools-devel</span><br></pre></td></tr></table></figure>

<p>设置编译参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@a nginx-1.16.1]#./configure --prefix=/usr/share/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --http-client-body-temp-path=/var/lib/nginx/tmp/client_body --http-proxy-temp-path=/var/lib/nginx/tmp/proxy --http-fastcgi-temp-path=/var/lib/nginx/tmp/fastcgi --http-uwsgi-temp-path=/var/lib/nginx/tmp/uwsgi --http-scgi-temp-path=/var/lib/nginx/tmp/scgi --pid-path=/run/nginx.pid --lock-path=/run/lock/subsys/nginx --user=nginx --group=nginx --with-file-aio --with-ipv6 --with-http_ssl_module --with-http_v2_module --with-http_realip_module --with-stream_ssl_preread_module --with-http_addition_module --with-http_xslt_module=dynamic --with-http_image_filter_module=dynamic --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_degradation_module --with-http_slice_module --with-http_stub_status_module --with-http_perl_module=dynamic --with-http_auth_request_module --with-mail=dynamic --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream=dynamic --with-stream_ssl_module --with-google_perftools_module --with-debug --with-cc-opt=&#x27;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -specs=/usr/lib/rpm/redhat/redhat-hardened-cc1 -m64 -mtune=generic&#x27; --with-ld-opt=&#x27;-Wl,-z,relro -specs=/usr/lib/rpm/redhat/redhat-hardened-ld -Wl,-E&#x27; --add-dynamic-module=/root/src/echo-nginx-module/</span><br></pre></td></tr></table></figure>

<p>当没有错误提示时，才可以进行编译：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Configuration summary</span><br><span class="line">  + using system PCRE library</span><br><span class="line">  + using system OpenSSL library</span><br><span class="line">  + using system zlib library</span><br><span class="line"></span><br><span class="line">  nginx path prefix: &quot;/usr/share/nginx&quot;</span><br><span class="line">  nginx binary file: &quot;/usr/sbin/nginx&quot;</span><br><span class="line">  nginx modules path: &quot;/usr/lib64/nginx/modules&quot;</span><br><span class="line">  nginx configuration prefix: &quot;/etc/nginx&quot;</span><br><span class="line">  nginx configuration file: &quot;/etc/nginx/nginx.conf&quot;</span><br><span class="line">  nginx pid file: &quot;/run/nginx.pid&quot;</span><br><span class="line">  nginx error log file: &quot;/var/log/nginx/error.log&quot;</span><br><span class="line">  nginx http access log file: &quot;/var/log/nginx/access.log&quot;</span><br><span class="line">  nginx http client request body temporary files: &quot;/var/lib/nginx/tmp/client_body&quot;</span><br><span class="line">  nginx http proxy temporary files: &quot;/var/lib/nginx/tmp/proxy&quot;</span><br><span class="line">  nginx http fastcgi temporary files: &quot;/var/lib/nginx/tmp/fastcgi&quot;</span><br><span class="line">  nginx http uwsgi temporary files: &quot;/var/lib/nginx/tmp/uwsgi&quot;</span><br><span class="line">  nginx http scgi temporary files: &quot;/var/lib/nginx/tmp/scgi&quot;</span><br><span class="line"></span><br><span class="line">./configure: warning: the &quot;--with-ipv6&quot; option is deprecated</span><br></pre></td></tr></table></figure>

<p>重新编译 <code>Nginx</code> 模块</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@a nginx-1.16.1]# make -j4</span><br></pre></td></tr></table></figure>

<p><font color="#DC143C" size=3><strong>注意：此时已经编译好玩我们所需的模块了，千万不要执行 <code>make install</code> ，否则会覆盖我们原有的 <code>Nginx</code> ！！！</strong></font></p>
<h4 id="3-4-拷贝模块并修改配置文件"><a href="#3-4-拷贝模块并修改配置文件" class="headerlink" title="3.4 拷贝模块并修改配置文件"></a>3.4 拷贝模块并修改配置文件</h4><p>我们刚才编译好的模块位于 <code>./objs/</code> 目录下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@a nginx-1.16.1]# ls ./objs/ngx_http_echo_module.so </span><br><span class="line">./objs/ngx_http_echo_module.so</span><br></pre></td></tr></table></figure>

<p>将该模块拷贝至 <code>Nginx</code> 默认模块路径下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@a nginx-1.16.1]# cp ./objs/ngx_http_echo_module.so /usr/lib64/nginx/modules/</span><br></pre></td></tr></table></figure>

<p>创建模块引入文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@a modules]# echo &quot;load_module &quot;/usr/lib64/nginx/modules/ngx_http_echo_module.so;&quot;&quot; &gt;&gt; /usr/share/nginx/modules/mod-http-echo.conf</span><br></pre></td></tr></table></figure>

<h4 id="3-5-重启-Nginx-进程"><a href="#3-5-重启-Nginx-进程" class="headerlink" title="3.5 重启 Nginx 进程"></a>3.5 重启 <code>Nginx</code> 进程</h4><p>加载动态模块，最好重启 <code>Nginx</code> 进程</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@a modules]# nginx -s stop</span><br><span class="line">[root@a modules]# nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或者</span></span><br><span class="line">[root@a modules]# systemctl restart nginx.service</span><br></pre></td></tr></table></figure>

<p>需要注意：动态加载的模块不支持通过 <code>nginx -V</code> 选项查看。</p>
<h4 id="3-6-简单测试下"><a href="#3-6-简单测试下" class="headerlink" title="3.6 简单测试下"></a>3.6 简单测试下</h4><p>在测试环境或者大家学习的过程中，建议使用 <code>echo</code> 参数，它可以非常方便的调试某些信息，可以直接打印出来，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server</span>        a.host.com;</span><br><span class="line">    <span class="attribute">listen</span>        <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">root</span>		  /data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>		  utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">access_log</span>	  /var/log/nginx/a-access.log mylog;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>	  /data/nginx/domain;</span><br><span class="line">        <span class="attribute">index</span>	  index.html index.php;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /echo/ &#123;</span><br><span class="line">        <span class="attribute">echo</span>  	  <span class="string">&quot;请求信息:<span class="variable">$request_uri</span>&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://public-bucket-butatree-img.oss-cn-hangzhou.aliyuncs.com/img/image-20210301144827010.png" alt="image-20210301144827010" style="zoom:33%;" />

<hr>
<h3 id="4-全站-HTTP-跳转-HTTPS-协议"><a href="#4-全站-HTTP-跳转-HTTPS-协议" class="headerlink" title="4. 全站 HTTP 跳转 HTTPS 协议"></a>4. 全站 <code>HTTP</code> 跳转 <code>HTTPS</code> 协议</h3><p>同样，我们以 <code>http://a.host.com</code> 为例，要求所有访问该页面的请求全部跳转至 <code>https://a.host.com/</code>，且请求的 <code>URI</code> 和参数 <code>$query_string</code> 要保留下来。</p>
<p>先给出常见的几种方法：</p>
<p><strong>【使用 <code>if</code> 进行协议判断】——最差</strong></p>
<p> 这种情况下，多为把 <code>http</code> 和 <code>https</code> 写在了同一个 <code>server</code> 中，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>	<span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$scheme</span> = http )&#123;</span><br><span class="line">        <span class="attribute">rewrite</span> <span class="regexp"> ^/(.*)$</span> https://a.host.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种配置看起来简洁很多，但是性能是最差的。首先每次连接进来都需要 <code>Nginx</code> 进行协议判断，其次判读为 <code>http</code> 协议时进行地址匹配、重写、返回、再次判断，最后还有正则表达式的处理……所以，生产上我们极不建议这种写法。另外，能少用 <code>if</code> 的尽量不用，如果一定要使用，也最好在 <code>location</code> 段，并且结合 <code>return</code> 或者 <code>rewrite ... last</code> 来使用。</p>
<p><strong>【<code>rewrite</code> 方法1】——差</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">rewrite</span> <span class="regexp"> ^/(.*)$</span>  https://a.host.com/<span class="variable">$1</span> <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求测试：**<code>http://a.host.com/a.html?a=3</code>**</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/a.html\?a\=3</span></span><br><span class="line">HTTP/1.1  301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 13:03:01 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://a.host.com/a.html?a=3</span><br></pre></td></tr></table></figure>

<p>可以看到实现了 <code>http</code> 到 <code>https</code> 的跳转，并且保留了参数。</p>
<p><strong>【<code>rewrite</code> 方法2】——好</strong></p>
<p>不使用正则表达式，而使用变量来提升性能：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^</span> https://a.host.com<span class="variable">$request_uri</span>? <span class="literal">permanent</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：<code>$request_uri</code> 已经包含了查询参数，所以要在其重写规则后面加上 <code>?</code> 以禁止再次传递参数。这种方法避免了 <code>Nginx</code> 内部处理正则的性能损坏，相比较上面的方式好了很多。</p>
<p>请求测试：**<code>http://a.host.com/a.html?a=3</code>**</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://a.host.com/a.html\?a\=3</span></span><br><span class="line">HTTP/1.1  301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 13:16:16 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://a.host.com/a.html?a=3</span><br></pre></td></tr></table></figure>

<p><strong>【使用 <code>return</code> 实现最优解】——最好</strong></p>
<p>虽然上面我们使用参数代替了正则，但是 <code>rewrite</code> 规则会先对 <code>URL</code> 进行匹配，匹配上了再执行相应的规则。而 <code>return</code> 没有匹配 <code>URL</code> 层面的性能消耗，直接后面返回用户新的连接，所以是最优的解决方案。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>				<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>			a.host.com;</span><br><span class="line">    <span class="attribute">return</span>			<span class="number">302</span> https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">443</span>	ssl	default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span>	<span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>	<span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：在 <code>return</code> 中，<code>$request_url</code> 后面不用加 <code>?</code> （加 <code>?</code> 用来避免携带参数是 <code>rewrite</code> 中的特性）。</p>
<p>如果希望实现永久重定向，则使用 <code>return 301 https://XXX</code> ，不过我们两个域名都会使用，所以更多情况下使用 <code>302</code> 临时重定向。</p>
<hr>
<h3 id="5-新老域名的替换"><a href="#5-新老域名的替换" class="headerlink" title="5. 新老域名的替换"></a>5. 新老域名的替换</h3><p>比如某些情况下，我们希望使用新的域名，但是一些老用户依然在使用老域名，比如之前京东使用的域名是 <code>http://www.360buy.com</code> ，现在使用 <code>https://www.jd.com</code> ，如果依然希望依然保留原来的域名，但是想让用户切换到新域名，那么我们就可以这么做。</p>
<p>这里我以 <code>b.host.com</code> 作为老域名，新域名为 <code>a.host.com</code> ，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>		b.host.com;</span><br><span class="line">    <span class="attribute">return</span>			<span class="number">301</span>	http://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">return</span>			<span class="number">302</span> https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求测试：**<code>http://b.host.com</code>**</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://b.host.com/</span></span><br><span class="line">HTTP/1.1  301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 7:57:15 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://a.host.com/</span><br></pre></td></tr></table></figure>

<p>可以看到，实现了 <code>301</code> 永久重定向，下面我们测试下参数传递，请求 <strong><code>http://b.host.com/abc/a.html</code></strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://b.host.com/abc/a.html</span></span><br><span class="line">HTTP/1.1  301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 7:57:15 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://a.host.com/abc/a.html</span><br></pre></td></tr></table></figure>

<p>可以看到参数也能够正常传递，我们看下京东是怎么做的，如下图：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://www.360buy.com</span></span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 08:26:06 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 178</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.jd.com/</span><br><span class="line">Age: 3246</span><br><span class="line">Via: http/1.1 ORI-BJ-CM-HT-PCS-48 (jcs [cHs f ]), https/1.1 ORI-CLOUD-JN2-MIX-114 (jcs [cRs f ]), http/1.1 HB-CT-6-MIX-27 (jcs [cRs f ])</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">X-Trace: 301-1614583920748-0-0-0-0-0;301-1614583932764-0-0-0-0-0;301-1614585145568-0-0-0-0-0;301-1614587166906-0-0-0-1-1</span><br></pre></td></tr></table></figure>

<p>同样也是使用 <code>301</code> 永久重定向。再看下参数传递的情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@a conf.d]# curl -I http://www.360buy.com/abc/a.html</span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 08:29:58 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 178</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://www.jd.com/abc/a.html</span><br><span class="line">Age: 0</span><br><span class="line">Via: http/1.1 ORI-BJ-CM-HT-FCS-51 (jcs [cMs f ]), https/1.1 ORI-CLOUD-JN2-MIX-29 (jcs [cMs f ]), http/1.1 HB-CT-6-MIX-19 (jcs [cMs f ])</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">X-Trace: 301-1614587398115-0-0-0-0-0;301-1614587398114-0-0-0-1-1;301-1614587398074-0-0-0-71-71;301-1614587398010-0-0-0-114-114</span><br></pre></td></tr></table></figure>

<p>顺便说下，<code>301</code> 永久重定向，浏览器会缓存重定向后的地址，当用户下次请求时，会直接使用缓存的地址。但是 <code>302</code> 临时重定向则浏览器不会缓存地址，用户下次请求时，会继续请求原来的网站。永久重定向时网络爬虫会爬取新的域名，增加新域名的权重。临时重定向则爬虫不会更新域名，依然使用老域名。所以，如果你的网站不想使用某个域名了，那么使用永久重定向，如果还打算使用，就使用临时重定向，比如我们上面的 <code>http</code> 跳转 <code>https</code> 的应用实例其实就是 <code>302</code> 临时重定向。</p>
<hr>
<h3 id="6-根据浏览器语言跳转不同页面"><a href="#6-根据浏览器语言跳转不同页面" class="headerlink" title="6. 根据浏览器语言跳转不同页面"></a>6. 根据浏览器语言跳转不同页面</h3><p>在一些比较大型全球性的网站，比如 <code>https://developer.mozilla.org</code> 或者 <code>https://www.ibm.com</code> 等，都会有多国语言页面，而且是根据你浏览器语言自动实现的。如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I -H <span class="string">&#x27;accept-language: zh-CN&#x27;</span> https://www.ibm.com/</span></span><br><span class="line">HTTP/1.1 303 See Other</span><br><span class="line">Server: GHost</span><br><span class="line">Content-Length: 0</span><br><span class="line">Location: https://www.ibm.com/cn-zh/?ar=1</span><br><span class="line">Date: Mon, 01 Mar 2021 08:54:30 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">Content-Security-Policy: upgrade-insecure-requests</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意：此时 <code>location https://www.ibm.com/cn-zh/?ar=1</code> ，当我们修改请求头部，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I -H <span class="string">&#x27;accept-language: en-US&#x27;</span> https://www.ibm.com/</span></span><br><span class="line">HTTP/1.1 303 See Other</span><br><span class="line">Server: GHost</span><br><span class="line">Content-Length: 0</span><br><span class="line">Location: https://www.ibm.com/cn-en/?ar=1</span><br><span class="line">Date: Mon, 01 Mar 2021 08:57:56 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">x-content-type-options: nosniff</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">Content-Security-Policy: upgrade-insecure-requests</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br></pre></td></tr></table></figure>

<p>此时 <code>location</code> 跳转到 <code>https://www.ibm.com/cn-zh/?ar=1</code>，像这种功能，我们就要借助 <code>if</code> 与 <code>set</code> 、<code>rewrite</code> 等功能来实现。现在我们来实现这个功能：</p>
<p>我们希望当浏览器语言为 <code>zh|zh-CN</code> 时，访问 <code>https://a.host.com/</code> 跳转到 <code>https://a.host.com/cn-zh</code> ，而当浏览器语言为 <code>en|en-US</code> 时，访问页面跳转到 <code>https://a.host.com/cn-en</code> ，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">return</span>		<span class="number">302</span>	https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>		<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> = / &#123;</span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;zh|zh-CN&quot;)</span> &#123;</span><br><span class="line">            <span class="attribute">set</span>	<span class="variable">$language</span> cn-zh;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;en|en-US&quot;)</span> &#123;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$language</span> cn-en;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">rewrite</span> <span class="regexp"> ^</span> /$ /<span class="variable">$language</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>	index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分别创建 <code>$document_root/&#123;en-zh,cn-zh&#125;</code> 目录，以及相关的 <code>index.html</code> 测试页面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">mkdir</span> -p /data/nginx/domain/&#123;cn-zh,cn-en&#125;</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;中文页面&quot;</span> &gt;&gt; /data/nginx/domain/cn-zh/index.html</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;English Page&quot;</span> &gt;&gt; /data/nginx/domain/cn-en/index.html</span></span><br></pre></td></tr></table></figure>

<p>此时我们修改请求头部，来实现不同的页面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I -k -H <span class="string">&#x27;accept-language: zh&#x27;</span> https://a.host.com/</span></span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 09:14:24 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Location: https://a.host.com/cn-zh/</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>可以看到页面跳转到 <code>https://a.host.com/cn-zh/</code> ，看下响应页面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -L -k -H <span class="string">&#x27;accept-language: zh&#x27;</span> https://a.host.com/</span></span><br><span class="line">中文页面</span><br></pre></td></tr></table></figure>

<p> 现在，我们修改成英文语言，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I -k -H <span class="string">&#x27;accept-language: en&#x27;</span> https://a.host.com/</span></span><br><span class="line">HTTP/1.1 301 Moved Permanently</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 09:17:56 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 162</span><br><span class="line">Location: https://a.host.com/cn-en/</span><br><span class="line">Connection: keep-alive</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -L -k -H <span class="string">&#x27;accept-language: en&#x27;</span> https://a.host.com/</span></span><br><span class="line">English Page</span><br></pre></td></tr></table></figure>

<p>只有访问 <code>http(s)://a.host.com/</code> 即 <code>uri = /</code> 时，才会做语言设置匹配。但是大家思考下，上面的配置有问题吗？加入我使用非 <code>zh|zh-CN|en|en-US</code> 语言访问时，会出现什么问题呢？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I -H <span class="string">&#x27;accept-language: heihei&#x27;</span> https://www.a.com/</span></span><br><span class="line">HTTP/1.1 500 Internal Server Error</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Mon, 01 Mar 2021 09:21:27 GMT</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Length: 170</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure>

<p>可以看到造成了内部循环重定向，服务器出现 <code>500</code> 报错。那么如何解决这个问题呢？</p>
<p>两种实现方案：</p>
<p><strong>【只需要在 <code>rewrite</code> 规则后加上 <code>break</code> 标志位】</strong></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">return</span>		<span class="number">302</span>	https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>		<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> = / &#123;</span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;zh|zh-CN&quot;)</span> &#123;</span><br><span class="line">            <span class="attribute">set</span>	<span class="variable">$language</span> cn-zh;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;en|en-US&quot;)</span> &#123;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$language</span> cn-en;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">rewrite</span> <span class="regexp"> ^</span> /$ /<span class="variable">$language</span> <span class="literal">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>	index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时无论是否能够匹配到 <code>zh|zh-CN|en|en-US</code> 都不会有问题，大家可以试着再去测试下。还有一种方式，我们可以再加一个 <code>if</code> 判断语句，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">return</span>		<span class="number">302</span>	https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>		<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="section">location</span> = / &#123;</span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;zh|zh-CN&quot;)</span> &#123;</span><br><span class="line">            <span class="attribute">set</span>	<span class="variable">$language</span> cn-zh;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;en|en-US&quot;)</span> &#123;</span><br><span class="line">            <span class="attribute">set</span> <span class="variable">$language</span> cn-en;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> !<span class="regexp">~* &quot;zh|zh-CN|en|en-US&quot;)</span> &#123;</span><br><span class="line">            <span class="attribute">return</span> https://a.host.com/index.html;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="attribute">rewrite</span> <span class="regexp"> ^</span> /$ /<span class="variable">$language</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>	index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方法也可以解决，但是多了一次 <code>if</code> 判断，所以还是建议上面的方式。其实解决问题的方法还有很多，前提是大家能够搞清楚 <code>return</code> 、<code>rewrite</code> 以及相关的 <code>flag</code> 的各种功能，当然，最终选择哪种，还需要根据性能参数以及自己网站的设计规划【比如，我们上面设计的方式是，只有访问根时才做语言匹配，你也可以根据任何页面做语言划分】。</p>
<blockquote>
<p>注意：上述设置只能适应于浏览器单语言，如果是同时支持 <code>zh|en</code> 的话，则只能匹配到 <code>zh</code> ，所以我们可以这样修改下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> =/ &#123;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;^(zh|zh-cn)&quot;)</span> &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$language</span> cn-zh;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$http_accept_language</span> <span class="regexp">~* &quot;^(en|en-us)&quot;)</span> &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$language</span> en-us;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">rewrite</span><span class="regexp"> ^/$</span> /<span class="variable">$language</span> <span class="literal">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>知识点：浏览器的请求头 <code>Accept-Language</code> 优先级最高的语言会出现在该字段最左侧。</p>
</blockquote>
<hr>
<h3 id="7-根据客户端不同，使用不同页面响应"><a href="#7-根据客户端不同，使用不同页面响应" class="headerlink" title="7. 根据客户端不同，使用不同页面响应"></a>7. 根据客户端不同，使用不同页面响应</h3><p>有一些用户体验比较好的网站，一般都会适配 <code>PC</code> 端 或者 移动端，即当用户是电脑访问页面 <code>a.host.com</code> 时，使用 <code>www.a.com</code> 进行响应，而用手机或者 <code>pad</code> 访问时，使用 <code>m.a.com</code> 进行响应。现在绝大多数都会使用这种方式去匹配，在早期还有可能会使用不同的 <code>URI</code> 进行响应。比如 <code>www.taobao.com</code> 、<code>www.jd.com</code> 等使用不同子域名进行响应，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I https://www.taobao.com</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: Tengine</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Date: Tue, 02 Mar 2021 06:03:30 GMT</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">x-server-id: 28c3d6b2523ca52cb704b8b5dcd976775d96d7f616d1d61a0dc00e99cabb0a973eab0f4fc94632e9</span><br><span class="line">x-air-hostname: air-ual011015253076.center.na62</span><br><span class="line">x-air-trace-id: 6f3f38a716146650100026052e</span><br><span class="line">Vary: Origin, Ali-Detector-Type, X-Host, Accept-Encoding</span><br><span class="line">Cache-Control: max-age=0, s-maxage=119</span><br><span class="line">etag: W/&quot;1d741-BGNM93NoQWH+EVaITQCqtB/B8xM&quot;</span><br><span class="line">x-readtime: 208</span><br><span class="line">x-via: cn1480.l1, cache14.cn1480, l2nu16-1.l2, cache21.l2nu16-1, wormholesource011001180165.center.na62</span><br><span class="line">x-air-source: proxy</span><br><span class="line">x-xss-protection: 1; mode=block</span><br><span class="line">EagleEye-TraceId: 6f3f38a716146650100026052e</span><br><span class="line">Strict-Transport-Security: max-age=31536000</span><br><span class="line">Timing-Allow-Origin: *, *</span><br><span class="line">Ali-Swift-Global-Savetime: 1614665010</span><br><span class="line">Via: cache21.l2nu16-1[272,200-0,C], cache25.l2nu16-1[199,0], bcache10.cn1607[0,200-0,H], bcache4.cn1607[3,0]</span><br><span class="line">Age: 101</span><br><span class="line">X-Cache: HIT TCP_MEM_HIT dirn:-2:-2</span><br><span class="line">X-Swift-SaveTime: Tue, 02 Mar 2021 06:03:30 GMT</span><br><span class="line">X-Swift-CacheTime: 119</span><br><span class="line">x-air-pt: pt0</span><br><span class="line">EagleId: 7ba06d9816146651118777728e</span><br></pre></td></tr></table></figure>

<p>正常使用电脑端请求没有什么变化，此时我们修改下 <code>User-Agent</code> 看下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I -H <span class="string">&quot;User-Agent: iphone&quot;</span> https://www.taobao.com</span></span><br><span class="line">HTTP/1.1 302 Found</span><br><span class="line">Server: Tengine</span><br><span class="line">Date: Tue, 02 Mar 2021 06:07:32 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 258</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://main.m.taobao.com/?sprefer=sypc00</span><br><span class="line">Via: bcache3.cn1607[,0]</span><br><span class="line">Timing-Allow-Origin: *</span><br><span class="line">EagleId: 7ba06d9716146652520252717e</span><br></pre></td></tr></table></figure>

<p>可以看到当使用移动端时，页面发生了 <code>302</code> 临时重定向，跳转到 <code>http://main.m.taobao.com/?sprefer=sypc00</code> ，我们现在希望也实现类似的功能。</p>
<p>配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">return</span>		<span class="number">302</span>	https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>		<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>     a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$http_user_agent</span> <span class="regexp">~* &quot;android|iphone|ipad|pad&quot;)</span> &#123;</span><br><span class="line">        <span class="attribute">return</span>  <span class="number">302</span>  http://m.a.com<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>  index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>		  <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>	  m.a.com;</span><br><span class="line">    <span class="attribute">server_name</span>   /data/nginx/domain/m;</span><br><span class="line">    <span class="attribute">index</span>         index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请求测试：**<code>https://a.host.com/images/a.jpeg</code>**</p>
<p>使用 <code>PC</code> 端请求：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -K -I https://a.host.com/images/a.jpeg</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 02 Mar 2021 06:17:08 GMT</span><br><span class="line">Content-Type: image/jpeg</span><br><span class="line">Content-Length: 24855</span><br><span class="line">Last-Modified: Tue, 02 Mar 2021 06:10:08 GMT</span><br><span class="line">Contention: keep-alive</span><br><span class="line">ETag: &quot;5e84bf0a-6117&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></table></figure>

<p>可以看到正常 <code>200</code> 响应，并未产生跳转。我们修改请求头之后再去请求，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -K -I -H <span class="string">&quot;User-Agent: iphone&quot;</span> https://a.host.com/images/a.jpeg</span></span><br><span class="line">HTTP/1.1 302 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 02 Mar 2021 06:21:15 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: http://m.a.com/images/a.jpeg</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>location http://m.a.com/images/a.jpeg</code> ，我们在前面介绍过，在 <code>$request_uri</code> 中会携带参数，同时跳转之后依然携带之前的 <code>uri + query_string</code> 才是比较合理的方式。</p>
<p>顺便说一下，通过变量 <code>$http_user_agent</code> 也可以实现网站的防爬虫。实现方式和我们上面的思路大致相同，此处不再赘述。</p>
<hr>
<h3 id="8-使用正则表达式完成某些特性需求"><a href="#8-使用正则表达式完成某些特性需求" class="headerlink" title="8. 使用正则表达式完成某些特性需求"></a>8. 使用正则表达式完成某些特性需求</h3><p>我们不可能介绍所有的生产案例，更多的是以典型案例来讨论解决思路，上面的实例我们实现了根据客户端的某些特征值来实现不同的 <code>URL</code> 重写，但是我们尽可能的避免使用正则表达式，现在我们介绍下正则表达式的使用方法，虽然 <code>Nginx</code> 在处理正则上会耗费一些性能，但是可以实现一些比较 ”高难度“ 的操作。如下：</p>
<p>由于网站 <code>A</code> （域名 <code>api.a.com</code> ）服务器在迁移，暂时将数据都放在了 <code>a.host.com/api</code> 目录下，我们希望用户请求 <code>http://api.a.com/abc/12.html?a=3&amp;b=4</code> 将地址重写为 <code>https://a.host.com/api/abc/12.html?a=3&amp;b=4</code> ，实现方式如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">return</span>          <span class="number">302</span> https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>	        <span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>     a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>            /data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>          utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$http_user_agent</span> <span class="regexp">~* &quot;android|iphone|ipad|pad&quot;)</span> &#123;</span><br><span class="line">        <span class="attribute">return</span>       <span class="number">302</span> http://m.a.com<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>        index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>        <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>   api.a.com;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$host</span> <span class="regexp">~* (.*)\.(.*)\.(.*)</span> ) &#123;</span><br><span class="line">        <span class="attribute">set</span> <span class="variable">$domain1</span> <span class="variable">$1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">return</span>    <span class="number">302</span> https://a.host.com/<span class="variable">$domain1</span><span class="variable">$request_uri</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要清除的知道，究竟需要哪些字符串，然后通过正则表达式来获取，比如上面我们需要二级域名，那么就通过 <code>$host ~* (.*)\.(.*)\.(.*)</code> 方式将域名进行分组，注意这个时候一定要把分组信息通过变量保存下来，以备下面使用。</p>
<p>请求测试：**<code>http://api.a.com/abc/12.html?a=3&amp;b=4</code>**</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://api.a.com/abc/12.html\?a\=3\&amp;b\=4</span></span><br><span class="line">HTTP/1.1  302 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 02 Mar 2021 06:54:45 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://a.host.com/api/abc/12.html?a=3&amp;b=4</span><br></pre></td></tr></table></figure>

<p>自己也可以测试下其他页面，应该都是可以满足我们之前提的需求的。比如，当我们访问根域名时，也会自动跳转，如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I http://api.a.com</span></span><br><span class="line">HTTP/1.1  302 Moved Temporarily</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 02 Mar 2021 06:58:08 GMT</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Content-Length: 138</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Location: https://a.host.com/api/</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="9-使用网站维护页面提高用户体验"><a href="#9-使用网站维护页面提高用户体验" class="headerlink" title="9. 使用网站维护页面提高用户体验"></a>9. 使用网站维护页面提高用户体验</h3><p>很多时候我们选择上线新系统时，用户的访问请求可能会出现一些不太友好的页面，比如服务器无响应、超时等等，一般情况下我们会选择将用户的请求全部重写到某个友好的维护页面，当然，前提是不要大幅度修改 <code>Nginx</code> 配置，比如我们想无论用户请求 <code>http://a.host.com</code> 的任意页面，都返回维护页面 <code>https://a.host.com/maintain.html</code> ，配置如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>		a.host.com;</span><br><span class="line">    <span class="attribute">return</span>			<span class="number">302</span> https://a.host.com<span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>			<span class="number">443</span> ssl default_server;</span><br><span class="line">    <span class="attribute">server_name</span>     a.host.com;</span><br><span class="line">    <span class="attribute">ssl_certificate</span> <span class="string">&quot;/data/nginx/ssl/nginx.crt&quot;</span>;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span> <span class="string">&quot;/data/nginx/ssl/nginx.key&quot;</span>;</span><br><span class="line">    <span class="attribute">root</span>			/data/nginx/domain;</span><br><span class="line">    <span class="attribute">charset</span>			utf-<span class="number">8</span>;</span><br><span class="line">    <span class="attribute">rewrite</span>		<span class="regexp">	^(.*)$</span>	/maintain.html <span class="literal">break</span>;</span><br><span class="line">    <span class="attribute">if</span> ( <span class="variable">$http_user_agent</span> <span class="regexp">~* &quot;android|iphone|ipad|pad&quot;</span> ) &#123;</span><br><span class="line">        <span class="attribute">return</span>		<span class="number">302</span> http://m.a.com<span class="variable">$request_uri</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">index</span>       index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是我们只需要在 <code>server</code> 段配置一条 <code>rewrite ^(.*)$ /maintain.html break;</code> 规则即可。</p>
<blockquote>
<p>另外，大家思考下，可以使用 <code>return 302 URL</code> 、<code>301</code> 或者 <code>302</code> 重定向吗？什么情况下可以，什么情况下不能使用，会造成内部死循环？</p>
<p>知识点：<code>return</code> 返回的 <code>code + URL</code> 如果是本机的，可以使用 <code>uri</code> ，但是如果 <code>return</code> 到本机，则会发生内部重定向过多，导致出现死循环。如果 <code>return</code> 到外网就没有问题。</p>
</blockquote>
<p>创建维护页面：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;&lt;h1&gt; 网站正则维护中，请稍后访问&lt;/h1&gt;&quot;</span> &gt; /data/nginx/domain/maintain.html</span></span><br></pre></td></tr></table></figure>

<p>请求测试：</p>
<p>此时无论我们请求任何页面都会重写 <code>URL</code> ，使用 <code>/maintain.html</code> 页面响应。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -I  -k https://a.host.com/abc/test.html</span></span><br><span class="line">HTTP/1.1  200 OK</span><br><span class="line">Server: nginx</span><br><span class="line">Date: Tue, 02 Mar 2021 07:18:56 GMT</span><br><span class="line">Content-Type: text/html, charset=utf-8</span><br><span class="line">Content-Length: 49</span><br><span class="line">Last-Modified: Tue, 02 Mar 2021 07:10:56 GMT</span><br><span class="line">Connection: keep-alive</span><br><span class="line">ETag: &quot;5e87aa42-31&quot;</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">curl -k https://a.host.com/abc/test.html</span></span><br><span class="line">&lt;h1&gt;网站正在维护中，请稍后访问&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<p>注意：此时不是重定向，而是地址重写。</p>
<hr>
<h3 id="10-使用-Nginx-做四层代理"><a href="#10-使用-Nginx-做四层代理" class="headerlink" title="10. 使用 Nginx 做四层代理"></a>10. 使用 <code>Nginx</code> 做四层代理</h3><p><code>Nginx</code> 从 <code>1.9.0</code> 开始，新增加了一个 <code>stream</code> 模块，用来实现四层协议（<code>TCP</code>）的转发、代理或者负载均衡等。在 <code>1.9.13</code> 版本中，开始支持 <code>UDP</code> 四层代理。生产上有些小型的四层调度可能会使用 <code>Nginx</code> ，我们简单介绍下这个模块的用法。（这个模块中的很多参数和 <code>http</code> 模块非常类似，甚至相同，大家也可以类比去理解）</p>
<p>**<code>listen</code>**：设置四层代理监听地址，基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">listen</span> address:port [ssl] [udp] [proxy_protocol] [backlog=number] [rcvbuf=size]</span><br><span class="line">		[sndbuf=size] [bind] [ipv6only=<span class="literal">on</span>|<span class="literal">off</span>] [reuseport]</span><br><span class="line">		[so_keepalive=<span class="literal">on</span>|<span class="literal">off</span>|[keepidle]:[keepintvl]:[keepcnt]];</span><br><span class="line">Default: -</span><br><span class="line">Context: server</span><br></pre></td></tr></table></figure>

<p>我们在前面 <code>http</code> 核心模块中 <code>listen</code> 指令介绍的一些参数，在这里含义也是一样的，比如 <code>backlog</code> 、<code>reuseport</code> 、<code>so_keepalive</code> 等。</p>
<hr>
<p>**<code>proxy_pass</code>**：设置代理服务器的地址。该地址可以指定为域名或 <code>IP</code> 地址加端口，或 <code>UNIX</code> 套接字路径。</p>
<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_pass</span> address</span><br><span class="line">Default: -</span><br><span class="line">Context: server</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> localhost:<span class="number">12345</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> unix:/tmp/stream.socket;</span><br></pre></td></tr></table></figure>

<p>也可以支持变量：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_pass</span> <span class="variable">$upstream</span>;</span><br></pre></td></tr></table></figure>

<hr>
<p>**<code>proxy_timeout</code>**：在客户端与代理服务器连接上的两次连续读写操作之间设置超时。如果在此时间内没有发送数据，则连接被关闭。默认为 <code>10m</code> ；基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_timeout</span> timeout;</span><br><span class="line">Default: <span class="attribute">proxy_timeout</span> <span class="number">10m</span>;</span><br><span class="line">Context: stream, server</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Set the <code>timeout</code> between two successive read or write operations on client or proxied server connections. If no data is transmitted within this time, the connection is closed.</p>
</blockquote>
<hr>
<p>**<code>proxy_connect_timeout</code>**：设置 <code>Nginx</code> 与被代理的服务器尝试建立连接的超时时长；默认为 <code>60s</code> ；</p>
<p>基本语法：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Syntax: <span class="attribute">proxy_connect_timeout</span> time;</span><br><span class="line">Default: <span class="attribute">proxy_connect_timeout</span> <span class="number">60s</span>;</span><br><span class="line">Context: stream, server</span><br></pre></td></tr></table></figure>

<p>当然，在 <code>stream</code> 中，也可以使用相应的 <code>upstream</code> 模块，模块名称 <code>ngx_stream_upstream_module</code> ，设计到的语法我们在前面的 <code>ngx_http_upstream_module</code> 中都介绍过，只不过支持的参数没有 <code>http_stream</code> 模块中多，示例配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">hash</span> <span class="variable">$remote_addr</span> consistent;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">server</span> backend1.example.com:<span class="number">12345</span> weight=<span class="number">5</span>;</span><br><span class="line">    <span class="attribute">server</span> backend2.example.com:<span class="number">12345</span> max_fails=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">    <span class="attribute">server</span> unix:/tmp/backend3;</span><br><span class="line">    </span><br><span class="line">    <span class="attribute">server</span> backup1.example.com:<span class="number">12345</span> backup;</span><br><span class="line">    <span class="attribute">server</span> backup2.example.com:<span class="number">12345</span> backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>  <span class="number">12345</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span> backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意： <code>ngx_stream_upstream_module</code> 中不支持 <code>ip_hash</code> 调度算法。</p>
<p>生产上一般还是比较少使用 <code>Nginx</code> 做四层代理的，可能有些自己开发的应用确实需要轻量级四层代理，我们此处就以代理后端 <code>SSHD</code> 服务为案例了，姑且不去考虑案例的合理性，只是做技术性演示。</p>
<p>简单示例：</p>
<p>后端两个节点分别为 <code>10.4.7.101</code> 和 <code>10.4.7.102</code> ，其中 <code>sshd</code> 都监听在 <code>22</code> 端口，我们使用 <code>10.4.7.100</code> 的 <code>22022</code> 端口进行代理转发，示例如下：</p>
<p>在 <code>nginx.conf</code> 配置文件中增加如下配置信息：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">stream</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>    /etc/nginx/stream_conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建  <code>/etc/nginx/stream_conf.d/stream.conf</code> 配置文件，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> ssh_back &#123;</span><br><span class="line">    <span class="attribute">server</span>		<span class="number">10.4.7.101:22</span>;</span><br><span class="line">    <span class="attribute">server</span>		<span class="number">10.4.7.102:22</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>		<span class="number">22022</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span>  ssh_back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是最基本的四层代理配置，默认使用轮询算法。我们也可以修改基于客户端地址的一致性 <code>hash</code> 算法，如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> ssh_back &#123;</span><br><span class="line">    <span class="attribute">hash</span>		<span class="variable">$remote_addr</span>  consistent;</span><br><span class="line">    <span class="attribute">server</span>		<span class="number">10.4.7.101:22</span>;</span><br><span class="line">    <span class="attribute">server</span>		<span class="number">10.4.7.102:22</span> max_fail=<span class="number">3</span> fail_timeout=<span class="number">30s</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>		<span class="number">22022</span>;</span><br><span class="line">    <span class="attribute">proxy_pass</span>	ssh_back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就会根据客户端的 <code>IP</code> 地址进行一致性 <code>hash</code> 运算。只有当后端节点出现故障时，才会将请求调度转移到其他节点。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2022-10-31</span><i class="fa fa-tag"></i><a class="tag" href="/tags/Nginx/" title="Nginx">Nginx </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://patmosss.github.io/2022/10/31/Nginx/,Patmos,Nginx,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2022/10/31/ISCSI/" title="ISCSI">Post Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2022/10/29/LFS6-3%E6%9E%84%E5%BB%BA/" title="">Próximo post</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>